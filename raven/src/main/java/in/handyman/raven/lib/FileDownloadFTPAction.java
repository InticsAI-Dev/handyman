package in.handyman.raven.lib;

import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.FileDownloadFTP;
import org.apache.commons.net.PrintCommandListener;
import org.apache.commons.net.ftp.*;
import org.apache.commons.net.util.TrustManagerUtils;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.*;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "FileDownloadFTP")
public class FileDownloadFTPAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final FileDownloadFTP fileDownloadFTP;

    private final Marker aMarker;

    public FileDownloadFTPAction(final ActionExecutionAudit action, final Logger log, final Object fileDownloadFTP) {
        this.fileDownloadFTP = (FileDownloadFTP) fileDownloadFTP;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" FileDownloadFTP:" + this.fileDownloadFTP.getName());
    }

    @Override
    public void execute() throws Exception {
        final String remoteHost = fileDownloadFTP.getHost();
        final String userName = fileDownloadFTP.getUserName();
        final String password = fileDownloadFTP.getPassword();
        final int remotePort = Integer.parseInt(fileDownloadFTP.getPort());
        final int sessionTimeout = Integer.parseInt(fileDownloadFTP.getSessionTimeOut());
        final String destDir = fileDownloadFTP.getDestDir();
        final String remoteFile = fileDownloadFTP.getSourceFile();
        log.info(aMarker, "Got the sftp details for the host {} and user {}", remoteHost, userName);
        FTPSClient ftpClient = new FTPSClient();
        try {
            ftpClient.setEndpointCheckingEnabled(false);
            ftpClient.addProtocolCommandListener(new PrintCommandListener(new PrintWriter(System.out)));
            int reply;
            ftpClient.setConnectTimeout(sessionTimeout);
            ftpClient.connect(remoteHost, remotePort);
            log.info(aMarker, "FTP URL is: {} ", ftpClient.getDefaultPort());
            reply = ftpClient.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftpClient.disconnect();
                throw new Exception("Exception in connecting to FTP Server");
            }
            ftpClient.login(userName, password);
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            ftpClient.enterLocalPassiveMode();
            ftpClient.setUseEPSVwithIPv4(true);
            ftpClient.execPBSZ(0);
            ftpClient.execPROT("P");
            System.setProperty("https.protocols", "TLSv1,TLSv1.1,TLSv1.2");
            ftpClient.setTrustManager(TrustManagerUtils.getAcceptAllTrustManager());
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            log.info(aMarker, "Remote system is  {}", ftpClient.getEnabledCipherSuites());
            log.info(aMarker, "SSL: {}", ftpClient.getEnableSessionCreation());
            log.info(aMarker, "Remote system is {} ", ftpClient.getSystemType());
            log.info(aMarker, "Current directory is {}", ftpClient.printWorkingDirectory());
            ftpDownloadDirectory(ftpClient, remoteFile, "", destDir);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (ftpClient.isConnected()) {
                ftpClient.logout();
                ftpClient.disconnect();
            }
        }
    }

    public void ftpDownloadDirectory(FTPClient ftpClient, String parentDir, String currentDir, String saveDir) throws IOException {
        String dirToList = parentDir;
        if (!currentDir.equals("")) dirToList += "/" + currentDir;
        FTPFile[] subFiles = ftpClient.listFiles(dirToList);
        fileIteration(ftpClient, parentDir, currentDir, saveDir, dirToList, subFiles);
    }

    private void fileIteration(FTPClient ftpClient, String parentDir, String currentDir, String saveDir, String dirToList, FTPFile[] subFiles) throws IOException {
        if (subFiles != null && subFiles.length > 0) {
            subFilesProcessing(ftpClient, parentDir, currentDir, saveDir, dirToList, subFiles);
        }
    }

    private void subFilesProcessing(FTPClient ftpClient, String parentDir, String currentDir, String saveDir, String dirToList, FTPFile[] subFiles) throws IOException {
        for (FTPFile aFile : subFiles) {
            String currentFileName = aFile.getName();
            if (currentFileName.equals(".") || currentFileName.equals(".."))
                continue;
            String filePath = parentDir + File.separator + currentDir + File.separator + currentFileName;
            if (currentDir.equals(""))
                filePath = parentDir + File.separator + currentFileName;
            String newDirPath = saveDir + parentDir + File.separator + currentDir + File.separator + currentFileName;
            if (currentDir.equals(""))
                newDirPath = saveDir + parentDir + File.separator + currentFileName;
            if (aFile.isDirectory())
                createDirectoryForSubFilesAndIterate(ftpClient, saveDir, dirToList, currentFileName, newDirPath);
            else
                downloadSingleFile(ftpClient, filePath, newDirPath);
        }
    }

    private void createDirectoryForSubFilesAndIterate(FTPClient ftpClient, String saveDir, String dirToList, String currentFileName, String newDirPath) throws IOException {
        File newDir = new File(newDirPath);
        boolean created = newDir.mkdirs();
        if (created)
            log.info(aMarker, "Created the directory: {} ", newDirPath);
        else
            log.info(aMarker, "Couldn't create the directory: {} ", newDirPath);
        ftpDownloadDirectory(ftpClient, dirToList, currentFileName, saveDir);
    }

    public void downloadSingleFile(FTPClient ftpClient, String remoteFilePath, String savePath) throws IOException {
        File downloadFile = new File(savePath);
        File parentDir = downloadFile.getParentFile();
        if (!parentDir.exists()){
            boolean createDirSuccessful =parentDir.mkdir();
            if(!createDirSuccessful)
                log.error("Problem in creating the directory {} ",parentDir);
        }
        try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(downloadFile))) {
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            log.info(aMarker, "Download file {} ", savePath);
            boolean success = ftpClient.retrieveFile(remoteFilePath, outputStream);
            if (success)
                log.info(aMarker, "Download the file {} ", remoteFilePath);
            else
                log.info(aMarker, "Couldn't download the file: {} ", remoteFilePath);
        }
    }

    @Override
    public boolean executeIf() throws Exception {
        return fileDownloadFTP.getCondition();
    }
}
