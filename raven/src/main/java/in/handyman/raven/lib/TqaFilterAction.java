package in.handyman.raven.lib;

import co.elastic.clients.elasticsearch.core.SearchResponse;
import co.elastic.clients.elasticsearch.core.search.TotalHits;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.common.collect.Lists;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.TqaFilter;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.InstanceUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "TqaFilter"
)
public class TqaFilterAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final TqaFilter tqaFilter;

    private final Marker aMarker;
    private final ObjectMapper mapper = new ObjectMapper();
    private static final MediaType MediaTypeJSON = MediaType
            .parse("application/json; charset=utf-8");


    public TqaFilterAction(final ActionExecutionAudit action, final Logger log,
                           final Object tqaFilter) {
        this.tqaFilter = (TqaFilter) tqaFilter;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" TqaFilter:" + this.tqaFilter.getName());
    }

    @Override
    public void execute() throws Exception {

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(tqaFilter.getResourceConn());
        final List<Map<String, Object>> synonymsResult = new ArrayList<>();
        final List<Map<String, Object>> inputPathResult = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(tqaFilter.getSynonymSqlQuery());
            formattedQuery.forEach(sqlToExecute -> {
                synonymsResult.addAll(handle.createQuery(sqlToExecute).mapToMap().stream().collect(Collectors.toList()));
            });
        });
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(tqaFilter.getInputFilePathSqlQuery());
            formattedQuery.forEach(sqlToExecute -> {
                inputPathResult.addAll(handle.createQuery(sqlToExecute).mapToMap().stream().collect(Collectors.toList()));
            });
        });

        final String threadCount = tqaFilter.getThreadCount();

        if(threadCount !=null){
            final ExecutorService executorService = Executors.newWorkStealingPool(Integer.parseInt(threadCount));


        }



        createTruePositive(jdbi, synonymsResult, inputPathResult);

        createFalsePositive(jdbi, inputPathResult);

    }

    private void createTruePositive(final Jdbi jdbi, final List<Map<String, Object>> synonymsResult, final List<Map<String, Object>> inputPathResult) throws IOException {

        final String esUsername = action.getContext().get("es.username");
        final String esPassword = action.getContext().get("es.password");
        final String esHostname = action.getContext().get("es.hostname");

        var elasticsearchClient = InstanceUtil.createElasticsearchClient(esUsername, esPassword, esHostname);
        final List<TruePositiveFilterResult> truePositives = new ArrayList<>();

        for (var input : inputPathResult) {

            final String inputFilePath = Optional.ofNullable(input.get("input_file_path")).map(String::valueOf).orElse(null);


            for (var synonym : synonymsResult) {

                final String synonymName = Optional.ofNullable(synonym.get("synonym_name")).map(String::valueOf).orElse(null);
                final Long tsId = Optional.ofNullable(synonym.get("ts_id")).map(String::valueOf).map(Long::valueOf).orElse(null);
                final Long sqId = Optional.ofNullable(synonym.get("sq_id")).map(String::valueOf).map(Long::valueOf).orElse(null);

                if (synonymName != null && inputFilePath != null) {

                    final SearchResponse<Object> filterList = elasticsearchClient
                            .search(s -> s.index("source_of_truth")
                                    .query(q -> q.bool(bool -> bool.must(query ->
                                                    query.matchPhrase(dd -> dd.field("page_content").query(synonymName)))
                                            .must(query ->
                                                    query.matchPhrase(dd -> dd.field("file_path").query(inputFilePath))
                                            )
                                    )), Object.class);

                    log.debug(aMarker, filterList.toString());

                    assert filterList.hits().total() != null;
                    final long hitsCount = Optional.of(filterList.hits().total()).map(TotalHits::value).orElse(0L);
                    truePositives.add(TruePositiveFilterResult.builder()
                            .inputFilePath(inputFilePath)
                            .synonymName(synonymName)
                            .rootPipelineId(action.getRootPipelineId())
                            .truePositiveHitCount(hitsCount)
                            .truthSynonymId(tsId)
                            .synonymQuestionId(sqId)
                            .build());
                }
            }
        }

        List<List<TruePositiveFilterResult>> smallerLists = tqaFilter.getWriteBatchSize() != null
                ? Lists.partition(truePositives, Integer.parseInt(tqaFilter.getWriteBatchSize()))
                : Collections.singletonList(truePositives);

        smallerLists.forEach(truePositiveFilterResults -> {
            jdbi.useTransaction(handle -> {
                final PreparedBatch insertBatch = handle.prepareBatch("INSERT INTO tqa.true_positive_filter_result (input_file_path, synonym_name, truth_synonym_id, synonym_question_id, true_positive_hit_count, root_pipeline_id)" +
                        " VALUES( :inputFilePath , :synonymName , :truthSynonymId , :synonymQuestionId , :truePositiveHitCount , :rootPipelineId );");

                for (var tpfr : truePositiveFilterResults) {
                    insertBatch.bindBean(tpfr).add();
                }

                int[] countArray = insertBatch.execute();
                log.info(aMarker, "inserted {} into true positive result", countArray);

            });

        });

    }

    private void createFalsePositive(final Jdbi jdbi, final List<Map<String, Object>> inputPathResult) {
        final OkHttpClient okHttpClient = InstanceUtil.createOkHttpClient();

        for (var input : inputPathResult) {

            final String inputFilePath = Optional.ofNullable(input.get("input_file_path")).map(String::valueOf).orElse(null);
            final ObjectNode objectNode = mapper.createObjectNode();

            objectNode.put("inputFilePath", inputFilePath);
            objectNode.put("outputDir", tqaFilter.getOutputDir());
            objectNode.put("maxDoctrDiff", tqaFilter.getMaxDoctrDiff());
            objectNode.put("maxQuestionDiff", tqaFilter.getMaxQuestionDiff());


            final String truthExtractorUrl = tqaFilter.getTruthExtractorUrl();
            final Request request = new Request.Builder().url(truthExtractorUrl)
                    .post(RequestBody.create(objectNode.toString(), MediaTypeJSON)).build();

            log.debug(aMarker, "URL {} request body {}", truthExtractorUrl, objectNode);

            try (final Response response = okHttpClient.newCall(request).execute()) {
                final String responseBody = Objects.requireNonNull(response.body()).string();
                if (response.isSuccessful()) {
                    final TruthExtractionResponse truthExtractionResponse = mapper.readValue(responseBody, TruthExtractionResponse.class);
                    final List<FalsePositiveFilterResult> falsePositiveFilterResults = truthExtractionResponse.getQuestionParts().stream()
                            .map(qaPair -> FalsePositiveFilterResult.builder()
                                    .question(qaPair.getQuestionParts()
                                            .stream().map(Part::getContent).collect(Collectors.joining(" ")))
                                    .answerCount(qaPair.getAnswerParts().size())
                                    .inputFilePath(inputFilePath)
                                    .rootPipelineId(action.getRootPipelineId())
                                    .build())
                            .collect(Collectors.toList());

                    List<List<FalsePositiveFilterResult>> smallerLists = tqaFilter.getWriteBatchSize() != null
                            ? Lists.partition(falsePositiveFilterResults, Integer.parseInt(tqaFilter.getWriteBatchSize()))
                            : Collections.singletonList(falsePositiveFilterResults);

                    smallerLists.forEach(truePositiveFilterResults -> {

                        jdbi.useTransaction(handle -> {
                            final PreparedBatch insertBatch = handle.prepareBatch("INSERT INTO tqa.false_positive_filter_result (input_file_path, question, answer_count, root_pipeline_id)" +
                                    " VALUES( :inputFilePath , :question , :answerCount ,:rootPipelineId );");

                            for (var tpfr : truePositiveFilterResults) {
                                insertBatch.bindBean(tpfr).add();
                            }

                            int[] countArray = insertBatch.execute();
                            log.info(aMarker, "inserted {} into false positive result", countArray);

                        });

                    });
                } else {
                    log.error(aMarker, " response failed {} ", responseBody);
                }
            } catch (Exception e) {
                log.error(aMarker, "The Exception occurred ", e);
            }

        }


    }

    @Override
    public boolean executeIf() throws Exception {
        return tqaFilter.getCondition();
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    static
    class TruePositiveFilterResult {

        private String inputFilePath;
        private String synonymName;

        private Long truthSynonymId;
        private Long synonymQuestionId;

        private long truePositiveHitCount;

        private Long rootPipelineId;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    static
    class FalsePositiveFilterResult {

        private String inputFilePath;
        private String question;

        private long answerCount;

        private Long rootPipelineId;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    static
    class TruthExtractionResponse {

        private List<QaPair> questionParts = new ArrayList<>();

    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    static
    class QaPair {

        private Integer id;
        private List<Part> questionParts = new ArrayList<>();
        private List<Part> answerParts = new ArrayList<>();

    }


    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    static
    class Part {

        private String content;
        private PartPosition position;

    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    static
    class PartPosition {

        private Double left;
        private Double upper;
        private Double right;
        private Double lower;
        private String filePath;
    }


}
