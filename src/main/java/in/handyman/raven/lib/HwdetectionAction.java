package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;

import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.Hwdetection;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.InstanceUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "Hwdetection"
)
public class HwdetectionAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;
  final ObjectMapper MAPPER;
  final String URI;
  final OkHttpClient httpclient;
  private static final MediaType MediaTypeJSON = MediaType.parse("application/json; charset=utf-8");

  private final Integer writeBatchSize = 1000;

  private final Hwdetection hwdetection;

  private final Marker aMarker;

  public HwdetectionAction(final ActionExecutionAudit action, final Logger log,
                           final Object hwdetection) {
    this.hwdetection = (Hwdetection) hwdetection;
    this.action = action;
    this.URI = action.getContext().get("copro.hw-detection.url");
    this.MAPPER = new ObjectMapper();
    this.httpclient = InstanceUtil.createOkHttpClient();

    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" Hwdetection:" + this.hwdetection.getName());
  }

  @Override
  public void execute() throws Exception {

    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(hwdetection.getResourceConn());
    final List<handwrittenTable> inputResult = new ArrayList<>();
    jdbi.useTransaction(handle -> {
      final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(hwdetection.getInput());
      AtomicInteger i = new AtomicInteger(0);
      formattedQuery.forEach(sqlToExecute -> {
        Query query = handle.createQuery(sqlToExecute);
        ResultIterable<handwrittenTable> resultIterable = query.mapToBean(handwrittenTable.class);
        List<handwrittenTable> detailList = resultIterable.stream().collect(Collectors.toList());
        inputResult.addAll(detailList);
      });
    });
    List<handwrittenTable> resultQueue = new ArrayList<>();
    inputResult.forEach(result -> {
      if (result.getFilePath() != null) {
        final ObjectNode objectNode = MAPPER.createObjectNode();
        objectNode.put("inputFilePath", result.getFilePath());
        objectNode.put("outputDir", hwdetection.getDirectorypath());
        objectNode.put("modelPath", hwdetection.getModelpath());
        final Request request = new Request.Builder().url(URI)
                .post(RequestBody.create(objectNode.toString(), MediaTypeJSON)).build();
        try (Response response = httpclient.newCall(request).execute()) {
          String responseBody = Objects.requireNonNull(response.body()).string();
          if (response.isSuccessful()) {
            hwclassificationcoproapi output = MAPPER.readValue(responseBody, new TypeReference<>() {
            });
            result.setValueType(output.getDocumentType());
            resultQueue.add(result);
          } else {
            insertSummaryAudit(jdbi, 0, 0, 1, "failed on" + result.getOriginId());

            throw new HandymanException(responseBody);
          }
        } catch (Throwable t) {
          log.error(aMarker, "error inserting row {}", result, t);
        }
      }
      if (resultQueue.size() == this.writeBatchSize) {
        log.info(aMarker, "executing  batch {}", resultQueue.size());
        consumerBatch(jdbi, resultQueue);
        log.info(aMarker, "executed  batch {}", resultQueue.size());
        insertSummaryAudit(jdbi, inputResult.size(), resultQueue.size(), 0, "batch inserted");

        resultQueue.clear();
        log.info(aMarker, "cleared batch {}", resultQueue.size());
      }
    });

    if (!resultQueue.isEmpty()) {
      log.info(aMarker, "executing final batch {}", resultQueue.size());
      consumerBatch(jdbi, resultQueue);
      log.info(aMarker, "executed final batch {}", resultQueue.size());
      insertSummaryAudit(jdbi, inputResult.size(), resultQueue.size(), 0, "final batch inserted");

      resultQueue.clear();
      log.info(aMarker, "cleared final batch {}", resultQueue.size());
    }

  }


  void consumerBatch(final Jdbi jdbi, List<handwrittenTable> resultQueue) {

    try {
      resultQueue.forEach(insert -> {
        jdbi.useTransaction(handle -> {
          try {
            Update update = handle.createUpdate(" INSERT INTO " + hwdetection.getHandwrittenTable() +
                    " ( origin_id, paper_no, file_path,value_type,tenant_id,created_on,last_updated_on) " +
                    " VALUES(:originId, :paperNo, :filePath, :valueType,:tenantId,NOW(),NOW());");
            Update bindBean = update.bindBean(insert);
            bindBean.execute();
          } catch (Throwable t) {
            insertSummaryAudit(jdbi, 0, 0, 1, "failed in bactch for " + insert.getOriginId());
            log.error(aMarker, "error inserting result {}", resultQueue, t);
          }
        });
      });
    } catch (Throwable t) {
      insertSummaryAudit(jdbi, 0, 0, resultQueue.size(), "failed in batch insert");
      log.error(aMarker, "error inserting result {}", resultQueue, t);
    }
  }

  void insertSummaryAudit(final Jdbi jdbi, int rowCount, int executeCount, int errorCount, String comments) {
    IntellimatchAction.SanitarySummary summary = new IntellimatchAction.SanitarySummary().builder()
            .rowCount(rowCount)
            .correctRowCount(executeCount)
            .errorRowCount(errorCount)
            .comments(comments)
            .build();
    jdbi.useTransaction(handle -> {
      Update update = handle.createUpdate("  INSERT INTO " + hwdetection.getAuditTable() +
              " ( row_count, correct_row_count, error_row_count,comments, created_at) " +
              " VALUES(:rowCount, :correctRowCount, :errorRowCount, :comments, NOW());");
      Update bindBean = update.bindBean(summary);
      bindBean.execute();
    });
  }


  @Override
  public boolean executeIf() throws Exception {
    return hwdetection.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class handwrittenSummary {
    int rowCount;
    int correctRowCount;
    int errorRowCount;
    String comments;

  }


  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static  class handwrittenTable {

    String originId;
    Integer paperNo;
    String filePath;
    String valueType;
    String tenantId;
  }
  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class hwclassificationcoproapi {
    String documentType;

  }


}


