package in.handyman.raven.lib;

import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.FolderDeleteByProcess;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "FolderDeleteByProcess"
)
public class FolderDeleteByProcessAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final FolderDeleteByProcess folderDeleteByProcess;

    private static final String PIPELINE_DIRECTORY_INFO_TABLE_NAME = "ingestion.pipeline_directory_info";

    private final Marker aMarker;

    public FolderDeleteByProcessAction(final ActionExecutionAudit action, final Logger log,
                                       final Object folderDeleteByProcess) {
        this.folderDeleteByProcess = (FolderDeleteByProcess) folderDeleteByProcess;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" FolderDeleteByProcess:" + this.folderDeleteByProcess.getName());
    }

    @Override
    public void execute() throws Exception {
        log.info(aMarker, "Folder delete by Process Name Action for {} has been started", folderDeleteByProcess.getName());

        String processNameForDeletion = folderDeleteByProcess.getCleanupProcessName();
        List<String> allowedProcessForDeletion = Optional.ofNullable(processNameForDeletion).map(s ->
                Arrays.stream(s.split(",")).collect(Collectors.toList())).orElse(Collections.emptyList());

        List<FolderDeleteProcessInputTable> folderDeleteProcessInputTables = new ArrayList<>();

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(folderDeleteByProcess.getResourceConn());

        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(folderDeleteByProcess.getQuerySet());
        formattedQuery.forEach(sql -> jdbi.useTransaction(handle ->
                handle.createQuery(sql)
                        .mapToBean(FolderDeleteProcessInputTable.class)
                        .forEach(folderDeleteProcessInputTable -> {
                            String processName = folderDeleteProcessInputTable.getProcessName();
                            if (allowedProcessForDeletion.contains(processName)) {
                                folderDeleteProcessInputTables.add(folderDeleteProcessInputTable);
                            }
                        })));
        log.info("Total folder count of processes found for deletion {} ", folderDeleteProcessInputTables.size());
        folderDeleteProcessInputTables.forEach(folderDeleteProcessInputTable -> deleteFilesAndUpdateStatus(folderDeleteProcessInputTable, jdbi));
        log.info(aMarker, "Folder delete by Process Name Action for {} has been completed", folderDeleteByProcess.getName());


    }

    private void deleteFilesAndUpdateStatus(FolderDeleteProcessInputTable folderDeleteProcessInputTable, Jdbi jdbi) {
        String directoryPath = folderDeleteProcessInputTable.getCurrentDirectoryPath();
        Integer groupId = folderDeleteProcessInputTable.getGroupId();
        String processName = folderDeleteProcessInputTable.getProcessName();
        Long tenantId = folderDeleteProcessInputTable.getTenantId();
        Long rootPipelineId = folderDeleteProcessInputTable.getRootPipelineId();
        boolean isValidFile = isFile(directoryPath);
        if(isValidFile){
            deleteFile(directoryPath);
        }else {
            deleteAllFilesInFolder(directoryPath);
        }

        try (var ignored = jdbi.open()) {
            log.info("Jdbi connection is open, initiating the status updating for folder deletion");
            updateStatusInTable(jdbi, rootPipelineId, groupId, processName, tenantId);
        } catch (Exception e) {
            log.error("Jdbi connection is closed, recreating the connection");
            jdbi = ResourceAccess.rdbmsJDBIConn(folderDeleteByProcess.getResourceConn());
            updateStatusInTable(jdbi, rootPipelineId, groupId, processName, tenantId);
        }

        log.info("Process Status updated to completed status for the process {}, tenantId {}", processName, tenantId);
    }

    private void updateStatusInTable(Jdbi jdbi, Long rootPipelineId, Integer groupId, String processName, Long tenantId) {
        jdbi.useHandle(handle -> {
            String sql = "UPDATE " + PIPELINE_DIRECTORY_INFO_TABLE_NAME + " SET " +
                    " status = 'COMPLETED' " +
                    "WHERE root_pipeline_id = :rootPipelineId " +
                    "AND group_id = :groupId " +
                    "AND process_name = :processName " +
                    "AND tenant_id = :tenantId";

            handle.createUpdate(sql)
                    .bind("rootPipelineId", rootPipelineId)
                    .bind("groupId", groupId)
                    .bind("processName", processName)
                    .bind("tenantId", tenantId)
                    .execute();
        });
    }

    public static boolean isFile(String pathStr) {
        Path path = Paths.get(pathStr);
        return Files.exists(path) && Files.isRegularFile(path);
    }

    public void deleteFile(String filePath) {
        File file = new File(filePath);
        if (file.exists() && file.isFile()) {
            if (file.delete()) {
                log.info("File deleted: {}", filePath);
            } else {
                log.warn("Failed to delete file: {}", filePath);
            }
        } else {
            log.warn("Provided path is not a valid file: {}", filePath);
        }
    }

    public void deleteAllFilesInFolder(String folderPath) {
        File folder = new File(folderPath);
        // Check if the path is a folder
        if (folder.exists() && folder.isDirectory()) {
            log.info("Folder found: {}", folderPath);
            File[] files = folder.listFiles();

            if (files != null) {
                for (File file : files) {
                    // If it's a directory, call this method recursively
                    String absolutePath = file.getAbsolutePath();
                    if (file.isDirectory()) {
                        deleteAllFilesInFolder(absolutePath);
                    } else {
                        if (file.delete()) {
                            log.info("File deleted with path {}", absolutePath);
                        } else {
                            log.info("Not able to delete file with path {}", absolutePath);
                        }
                    }
                }
            }
        } else {
            log.info("Provided path {} is not a folder or it doesn't exist", folderPath);
        }
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    public static class FolderDeleteProcessInputTable {
        private String currentDirectoryPath;
        private Integer groupId;
        private Long tenantId;
        private LocalDateTime createdOn;
        private Long rootPipelineId;
        private String processName;
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    public static class FolderDeleteProcessOutputTable {
        private String filepath;
        private String message;
        private String status;
        private Integer groupId;
        private Long tenantId;
        private Long processId;
        private Long rootPipelineId;
        private LocalDateTime deletedTime;
    }

    @Override
    public boolean executeIf() throws Exception {
        return folderDeleteByProcess.getCondition();
    }
}
