package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.jetbrains.annotations.NotNull;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.URL;
import java.sql.Timestamp;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * ControlDataComparison Action using CoproProcessor pattern
 */
/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    public static final String ACTUAL_ENCRYPTION_VARIABLE = "actual.encryption.variable";
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;
    ActionExecutionAudit actionExecutionAudit = new ActionExecutionAudit();

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
    }

    @Override
    public void execute() throws Exception {
        try {

            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            String querySet = controlDataComparison.getQuerySet();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = getControlDataComparisonQueryInputTables(jdbi, querySet);

            log.info(aMarker, "Total rows returned from the query: {}", controlDataComparisonQueryInputTables.size());

            InticsIntegrity encryptionHandler = SecurityEngine.getInticsIntegrityMethod(action, log);
            log.info(aMarker, "Encryption Handler initialized: {}", encryptionHandler.getEncryptionMethod());

            performDecryption(controlDataComparisonQueryInputTables, encryptionHandler);
            log.info(aMarker, "Decryption process completed");

            // Insert SQL - same column list you used previously
            final String insertSql = "INSERT INTO " + outputTable + " (" +
                    "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " +
                    "paper_no, actual_value, extracted_value, match_status, mismatch_count, " +
                    "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id" +
                    ") VALUES (" +
                    ":rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, " +
                    ":actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId, " +
                    ":classification, :sorContainerId, :sorItemName, :sorItemId" +
                    ")";

            // Build input list by streaming querySet (this is used by CoproProcessor producer)
            final List<URL> dummyNodes = new ArrayList<>(); // not used by this action, but CoproProcessor expects a list
            // create a stopping seed instance of ControlDataComparisonQueryInputTable (empty marker)
            final ControlDataComparisonQueryInputTable stoppingSeed = new ControlDataComparisonQueryInputTable();

            // create CoproProcessor with a LinkedBlockingQueue
            final CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonOutputTable> coproProcessor =
                    new CoproProcessor<>(new LinkedBlockingQueue<>(),
                            ControlDataComparisonOutputTable.class,
                            ControlDataComparisonQueryInputTable.class,
                            controlDataComparison.getResourceConn(), log,
                            stoppingSeed, dummyNodes, action);

            // Start producer
            coproProcessor.startProducer(querySet, parseContextValue(action, "read.batch.size", "100"));

            // create consumer process and start consumers
            ControlDataComparisonConsumerProcess consumerProcess =
                    new ControlDataComparisonConsumerProcess(log, aMarker, action, controlDataComparison.getResourceConn(), outputTable);

            // determine consumer count and write batch size
            int consumerCount = parseContextValue(action, "control.data.consumer.count", "1");
            int writeBatchSize = parseContextValue(action, "write.batch.size", "50");

            log.info(aMarker, "Starting copro consumer with count {} and writeBatchSize {}", consumerCount, writeBatchSize);

            coproProcessor.startConsumer(insertSql, consumerCount, writeBatchSize, consumerProcess);

            log.info(aMarker, "Control Data Comparison Copro Action completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");
        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in ControlDataComparisonAction.execute", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("ControlDataComparison action failed", handymanException, action);
            throw handymanException;
        }
    }

    private int parseContextValue(ActionExecutionAudit action, String key, String defaultValue) {
        String value = action.getContext().getOrDefault(key, defaultValue).trim();
        int result;
        try {
            if (value.isEmpty()) {
                result = Integer.parseInt(defaultValue);
            } else {
                result = Integer.parseInt(value);
            }
        } catch (Exception e) {
            log.warn(aMarker, "Failed to parse context value for key {}. Using default {}", key, defaultValue);
            result = Integer.parseInt(defaultValue);
        }
        return result;
    }

    @NotNull
    public List<ControlDataComparisonQueryInputTable> getControlDataComparisonQueryInputTables(Jdbi jdbi, String querySet) {
        log.info(aMarker,"{}: Executing query set to fetch input data",querySet);
        final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                List<ControlDataComparisonQueryInputTable> results = query.mapToBean(ControlDataComparisonQueryInputTable.class).list();
                controlDataComparisonQueryInputTables.addAll(results);
                log.info(aMarker, "Executed query from index {}", i.get());
            });
        });
        log.info(aMarker, "Total records fetched: {}", controlDataComparisonQueryInputTables.size());
        return controlDataComparisonQueryInputTables;
    }
    //DEBUG ON YOUR OWN RISK
    private void performDecryption(List<ControlDataComparisonQueryInputTable> records,
                                   InticsIntegrity encryptionHandler) {
        log.info(aMarker, "Total records to process for decryption: {}", records.size());
        boolean itemWiseEncryption = Boolean.parseBoolean(
                action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false"));
        boolean actualEncryption = Boolean.parseBoolean(
                action.getContext().getOrDefault(ACTUAL_ENCRYPTION_VARIABLE, "false"));

        if (itemWiseEncryption) {
            log.info(aMarker, "Starting Decryption process for item-wise encryption");
            decryptAndUpdate(records, encryptionHandler, true);
        } else {
            log.info(aMarker, "Skipping Decryption as itemWiseEncryption is false");
        }

        if (actualEncryption) {
            log.info(aMarker, "Starting Decryption process for actual value encryption");
            decryptAndUpdate(records, encryptionHandler, false);
        } else {
            log.info(aMarker, "Skipping Decryption as actualEncryption is false");
        }

    }

    private void decryptAndUpdate(
            List<ControlDataComparisonQueryInputTable> records,
            InticsIntegrity encryptionHandler,
            boolean isExtracted
    ) {
        log.info(aMarker, "Total records to process for decryption (isExtracted={}): {}", isExtracted, records.size());
        List<EncryptionRequestClass> requests = buildDecryptionRequests(records, isExtracted);

        if (requests.isEmpty()) {
            return;
        }

        List<EncryptionRequestClass> responses = encryptionHandler.decrypt(requests);
        Map<String, List<EncryptionRequestClass>> groupedResponses = groupResponsesByRecordId(responses);

        applyDecryptedValues(records, groupedResponses, isExtracted);
    }
    private void applyDecryptedValues(List<ControlDataComparisonQueryInputTable> records,
                                      Map<String, List<EncryptionRequestClass>> groupedResponses,
                                      boolean isExtracted) {
        log.info(aMarker, "Applying decrypted values to records (isExtracted={}): {}", isExtracted, records.size());
        for (ControlDataComparisonQueryInputTable r : records) {
            List<EncryptionRequestClass> respList = groupedResponses.get(String.valueOf(r.getId()));
            if (respList == null) continue;

            // preserve order for multi-value
            respList.sort(Comparator.comparingInt(resp -> {
                if (!resp.getKey().contains("_")) return 0;
                return Integer.parseInt(resp.getKey().substring(resp.getKey().indexOf("_") + 1));
            }));

            String finalValue = respList.stream()
                    .map(EncryptionRequestClass::getValue)
                    .collect(Collectors.joining(","));

            if (isExtracted) {
                r.setExtractedValue(finalValue);
            } else {
                r.setActualValue(finalValue);
            }
        }
    }
    private Map<String, List<EncryptionRequestClass>> groupResponsesByRecordId(
            List<EncryptionRequestClass> responses
    ) {
        log.info("Grouping responses by record ID, total responses: {}", responses.size());
        return responses.stream()
                .collect(Collectors.groupingBy(resp -> {
                    String key = resp.getKey();
                    return key.contains("_") ? key.substring(0, key.indexOf("_")) : key;
                }));
    }

    private List<EncryptionRequestClass> buildDecryptionRequests(
            List<ControlDataComparisonQueryInputTable> records,
            boolean isExtracted
    ) {
        List<EncryptionRequestClass> requests = new ArrayList<>();

        for (ControlDataComparisonQueryInputTable r : records) {
            if (!"t".equalsIgnoreCase(r.getIsEncrypted())) continue;

            String rawVal = isExtracted ? r.getExtractedValue() : r.getActualValue();
            if (rawVal == null || rawVal.isEmpty()) continue;

            if ("multi_value".equalsIgnoreCase(r.getLineItemType()) && rawVal.contains(",")) {
                addMultiValueRequests(requests, r, rawVal);
            } else {
                requests.add(newRequest(String.valueOf(r.getId()), rawVal, r.getEncryptionPolicy()));
            }
        }

        return requests;
    }
    private void addMultiValueRequests(List<EncryptionRequestClass> requests,
                                       ControlDataComparisonQueryInputTable record,
                                       String rawVal) {
        log.info("Adding multi-value requests for record ID: {}", record.getId());
        String[] parts = rawVal.split(",");
        for (int i = 0; i < parts.length; i++) {
            String trimmed = parts[i].trim();
            if (!trimmed.isEmpty()) {
                requests.add(newRequest(record.getId() + "_" + i, trimmed, record.getEncryptionPolicy()));
            }
        }
    }
    private EncryptionRequestClass newRequest(String key, String value, String policy) {
        log.info("Creating request - Key: {}, Policy: {}", key, policy);
        return EncryptionRequestClass.builder()
                .key(key)
                .value(value)
                .policy(policy)
                .build();
    }
    public static String calculateValidationScores(Long mismatchCount, String oneTouch, String lowTouch) {
        String matchStatus;
        if (mismatchCount == 0) {
            matchStatus = "NO TOUCH";
        } else if (mismatchCount <= Long.parseLong(oneTouch)) {
            matchStatus = "ONE TOUCH";
        } else if (mismatchCount <= Long.parseLong(lowTouch)) {
            matchStatus = "LOW TOUCH";
        } else {
            matchStatus = "HIGH TOUCH";
        }
        return matchStatus;
    }

    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }

    /**
     * Output entity used by CoproProcessor as the output target (matches DB columns used previously).
     * Implements CoproProcessor.Entity so default insertion logic in your pipeline can use getRowData()
     */
    public static class ControlDataComparisonOutputTable implements CoproProcessor.Entity {
        private Long rootPipelineId;
        private Timestamp createdOn;
        private Long groupId;
        private String fileName;
        private String originId;
        private String batchId;
        private Long paperNo;
        private String actualValue;
        private String extractedValue;
        private String matchStatus;
        private Long mismatchCount;
        private Long tenantId;
        private String classification;
        private Long sorContainerId;
        private String sorItemName;
        private Long sorItemId;
        private String status;

        public void setRootPipelineId(Long v) { this.rootPipelineId = v; }
        public void setCreatedOn(Timestamp v) { this.createdOn = v; }
        public void setGroupId(Long v) { this.groupId = v; }
        public void setFileName(String v) { this.fileName = v; }
        public void setOriginId(String v) { this.originId = v; }
        public void setBatchId(String v) { this.batchId = v; }
        public void setPaperNo(Long v) { this.paperNo = v; }
        public void setActualValue(String v) { this.actualValue = v; }
        public void setExtractedValue(String v) { this.extractedValue = v; }
        public void setMatchStatus(String v) { this.matchStatus = v; }
        public void setMismatchCount(Long v) { this.mismatchCount = v; }
        public void setTenantId(Long v) { this.tenantId = v; }
        public void setClassification(String v) { this.classification = v; }
        public void setSorContainerId(Long v) { this.sorContainerId = v; }
        public void setSorItemName(String v) { this.sorItemName = v; }
        public void setSorItemId(Long v) { this.sorItemId = v; }
        public void setStatus(String v) { this.status = v; }

        @Override
        public List<Object> getRowData() {
            List<Object> row = new ArrayList<>();
            row.add(rootPipelineId);
            row.add(createdOn);
            row.add(groupId);
            row.add(fileName);
            row.add(originId);
            row.add(batchId);
            row.add(paperNo);
            row.add(actualValue);
            row.add(extractedValue);
            row.add(matchStatus);
            row.add(mismatchCount);
            row.add(tenantId);
            row.add(classification);
            row.add(sorContainerId);
            row.add(sorItemName);
            row.add(sorItemId);
            return row;
        }

        @Override
        public String getStatus() {
            return status;
        }
    }
}
