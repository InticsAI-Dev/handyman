package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sun.xml.bind.v2.runtime.output.SAXOutput;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapter;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapterFactory;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.lib.utils.CustomBatchWithScaling;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;
    private static final String INSERT_INTO = "INSERT INTO";

    // ðŸ”¹ Column list for control data comparison output
    public static final String COLUMN_LIST = "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " +
            "paper_no, actual_value, extracted_value, match_status, mismatch_count, " +
            "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id";

    // ðŸ”¹ Value placeholders (JDBI ? parameters for prepared statement)
    public static final String VAL_STRING_LIST =
            "VALUES(?,?,?,?,?,?,?, ?,?,?,?,?,?,?,?,?)";

    private static final String DEFAULT_SOCKET_TIMEOUT = "100";
    private static final String THREAD_SLEEP_TIME_DEFAULT = "1000";

    private final ObjectMapper objectMapper;
    private final InticsIntegrity securityEngine;

    private final int threadSleepTime;
    private final int writeBatchSize;
    private int readBatchSize;
    private final int timeout;
    private final String targetTableName;
    private final String controlDataComparisonUrl;
    private final String insertQuery;

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
        this.securityEngine = SecurityEngine.getInticsIntegrityMethod(this.action, log);
        this.objectMapper = new ObjectMapper();
        this.timeout = parseContextValue(action, "copro.client.socket.timeout", DEFAULT_SOCKET_TIMEOUT);
        this.threadSleepTime = parseContextValue(action, "copro.client.api.sleeptime", THREAD_SLEEP_TIME_DEFAULT);
        this.writeBatchSize = parseContextValue(action, "write.batch.size", "10");
        this.targetTableName = this.controlDataComparison.getOutputTable();
        this.controlDataComparisonUrl = this.controlDataComparison.getEndPoint();
        this.insertQuery = INSERT_INTO + " " + targetTableName + " (" + COLUMN_LIST + ") " + VAL_STRING_LIST;

    }

    private int parseContextValue(ActionExecutionAudit action, String key, String defaultValue) {
        String value = action.getContext().getOrDefault(key, defaultValue).trim();
        int result;

        if (value.isEmpty()) {
            result = Integer.parseInt(defaultValue);
            log.debug("Context key '{}' is empty or missing. Using default value: {}", key, defaultValue);
        } else {
            result = Integer.parseInt(value);
            log.debug("Context key '{}' found with value: '{}'. Parsed as integer: {}", key, value, result);
        }
        return result;
    }

    @Override
    public void execute() throws Exception {
        try {

            final List<URL> urls = Optional.ofNullable(controlDataComparisonUrl).map(s -> Arrays.stream(s.split(",")).map(urlItem -> {
                try {
                    return new URL(urlItem);
                } catch (MalformedURLException e) {
                    log.error("Error in processing the URL {}", urlItem, e);
                    throw new HandymanException("Error in processing the URL", e, action);
                }
            }).collect(Collectors.toList())).orElse(Collections.emptyList());
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            String querySet = controlDataComparison.getQuerySet();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = getControlDataComparisonQueryInputTables(jdbi,querySet);

            log.info(aMarker, "Total rows returned from the query: {}", controlDataComparisonQueryInputTables.size());

            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            Map<String, String> decryptedActualMap = new HashMap<>();
            Map<String, String> decryptedExtractedMap = new HashMap<>();
            boolean itemWiseEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false"));
            boolean actualEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault("actual.encryption.variable", "false"));

            // Decryption logic
            if (itemWiseEncryption) {
                Map<String, List<ControlDataComparisonQueryInputTable>> groupedByOrigin = controlDataComparisonQueryInputTables.stream()
                        .filter(r -> "t".equalsIgnoreCase(r.getIsEncrypted()))
                        .collect(Collectors.groupingBy(ControlDataComparisonQueryInputTable::getOriginId));

                for (Map.Entry<String, List<ControlDataComparisonQueryInputTable>> entry : groupedByOrigin.entrySet()) {
                    String originId = entry.getKey();
                    List<ControlDataComparisonQueryInputTable> encryptedItems = entry.getValue();

                    // Decrypt actual values if actualEncryption is true
                    if (actualEncryption) {
                        List<EncryptionRequestClass> actualValueFields = encryptedItems.stream()
                                .filter(r -> {
                                    if (r.getActualValue() == null || r.getActualValue().trim().isEmpty()) {
                                        log.info(aMarker, "Skipping decryption for actualValue (null or empty) for originId: {}, sorItemName: {} when isEncrypted is true",
                                                originId, r.getSorItemName());
                                        return false;
                                    }
                                    return true;
                                })
                                .map(r -> new EncryptionRequestClass(r.getEncryptionPolicy(), r.getActualValue(), r.getSorItemName()))
                                .collect(Collectors.toList());

                        if (!actualValueFields.isEmpty()) {
                            try {
                                log.info(aMarker, "Decrypting ACTUAL values for originId: {}", originId);
                                List<EncryptionRequestClass> decryptedActuals = encryption.decrypt(actualValueFields);
                                decryptedActuals.forEach(decrypted -> {
                                    String key = originId + "|" + decrypted.getKey();
                                    decryptedActualMap.put(key, decrypted.getValue());
                                });
                                log.info(aMarker, "Actual value decryption successful for originId: {}", originId);
                            } catch (Exception e) {
                                log.error(aMarker, "Actual value decryption failed for originId: {}", originId, e);
                            }
                        }
                    }

                    // Decrypt extracted values
                    List<EncryptionRequestClass> extractedValueFields = encryptedItems.stream()
                            .filter(r -> {
                                if (r.getExtractedValue() == null || r.getExtractedValue().trim().isEmpty()) {
                                    log.info(aMarker, "Skipping decryption for extractedValue (null or empty) for originId: {}, sorItemName: {} when isEncrypted is true",
                                            originId, r.getSorItemName());
                                    return false;
                                }
                                return true;
                            })
                            .map(r -> new EncryptionRequestClass(r.getEncryptionPolicy(), r.getExtractedValue(), r.getSorItemName()))
                            .collect(Collectors.toList());

                    if (!extractedValueFields.isEmpty()) {
                        try {
                            log.info(aMarker, "Decrypting EXTRACTED values for originId: {}", originId);
                            List<EncryptionRequestClass> decryptedExtracted = encryption.decrypt(extractedValueFields);
                            decryptedExtracted.forEach(decrypted -> {
                                String key = originId + "|" + decrypted.getKey();
                                decryptedExtractedMap.put(key, decrypted.getValue());
                            });
                            log.info(aMarker, "Extracted value decryption successful for originId: {}", originId);
                        } catch (Exception e) {
                            log.error(aMarker, "Extracted value decryption failed for originId: {}", originId, e);
                        }
                    }
                }
            } else {
                log.info(aMarker, "Skipping decryption as itemWiseEncryption is false");
            }
            int consumerApiCount = 0;
            CustomBatchWithScaling customBatchWithScaling = new CustomBatchWithScaling(action, log);
            boolean isPodScalingCheckEnabled = customBatchWithScaling.isPodScalingCheckEnabled();
            if (isPodScalingCheckEnabled) {
                log.info(aMarker, "Pod Scaling Check is enabled, computing consumer API count using CustomBatchWithScaling");
                consumerApiCount = customBatchWithScaling.computeSorTransactionApiCount();
            }

            log.info(aMarker, "Consumer API count for kvp action is {}", consumerApiCount);

            readBatchSize = parseContextValue(action, "read.batch.size", "10");
            if (consumerApiCount >= readBatchSize) {
                log.info(aMarker, "Consumer API count {} is greater than read batch size {}, setting read batch size to consumer API count", consumerApiCount, readBatchSize);
                readBatchSize = consumerApiCount;
            } else {
                log.info(aMarker, "Consumer API count {} is less than or equal to read batch size {}, keeping read batch size as is", consumerApiCount, readBatchSize);
            }

            final CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonResult> coproProcessor = getTableCoproProcessor(urls);
            Thread.sleep(threadSleepTime);

            final ControlDataComparisonConsumerProcess controlDataComparisonConsumerProcess = new ControlDataComparisonConsumerProcess(log, aMarker, action,controlDataComparison.getResourceConn(), controlDataComparisonQueryInputTables, decryptedActualMap, decryptedExtractedMap, outputTable);
            coproProcessor.startConsumer(insertQuery, consumerApiCount, writeBatchSize, controlDataComparisonConsumerProcess);
            log.info(aMarker, " LLM kvp Action has been completed {}  ", controlDataComparison.getName());


            log.info(aMarker, "Control Data Comparison Action has been completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");

        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    private @NotNull CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonResult> getTableCoproProcessor(List<URL> urls) {
        ControlDataComparisonQueryInputTable neonQueryInputTable = new ControlDataComparisonQueryInputTable();
        final CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonResult> coproProcessor =
                new CoproProcessor<>(new LinkedBlockingQueue<>(),
                        ControlDataComparisonResult.class,
                        ControlDataComparisonQueryInputTable.class,
                        controlDataComparison.getResourceConn(), log,
                        neonQueryInputTable, urls, action);

        coproProcessor.startProducer(controlDataComparison.getQuerySet(), readBatchSize);
        return coproProcessor;
    }

    @NotNull
    public List<ControlDataComparisonQueryInputTable> getControlDataComparisonQueryInputTables(Jdbi jdbi,String querySet) {
        final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                List<ControlDataComparisonQueryInputTable> results = query
                        .mapToBean(ControlDataComparisonQueryInputTable.class)
                        .list();
                controlDataComparisonQueryInputTables.addAll(results);
                log.info(aMarker, "Executed query from index {}", i.get());
            });
        });
        return controlDataComparisonQueryInputTables;
    }

    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}