package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ControlDataComparison;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ControlDataComparison"
)
public class ControlDataComparisonAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final ControlDataComparison controlDataComparison;

  private static Logger log = null;

  private final Marker aMarker;

  public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log,
                                     final Object controlDataComparison) {
    this.controlDataComparison = (ControlDataComparison) controlDataComparison;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" ControlDataComparison:"+this.controlDataComparison.getName());
  }

  private static final List<String> POSSIBLE_DATE_FORMATS = List.of(
          "M/d/yyyy", "MM/dd/yyyy", "yyyy-MM-dd", "yyyy/MM/dd",
          "dd/MM/yyyy", "d/M/yyyy", "MMM dd, yyyy", "dd-MMM-yyyy"
  );

  private static final String THRESHOLD_ONE_TOUCH = "1";
  private static final String THRESHOLD_LOW_TOUCH = "3";
  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
      log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

      String outputTable = controlDataComparison.getOutputTable();
      final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(controlDataComparison.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "executing query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<ControlDataComparisonQueryInputTable> resultIterable = query.mapToBean(ControlDataComparisonQueryInputTable.class);
          List<ControlDataComparisonQueryInputTable> publishQueryInputs = resultIterable.stream().collect(Collectors.toList());
          controlDataComparisonQueryInputTables.addAll(publishQueryInputs);
          log.info(aMarker, "executed query from index {}", i.get());
        });
      });

      controlDataComparisonQueryInputTables.forEach(controlDataComparisonQueryInput -> {
        try {
          doControlDataValidation(controlDataComparisonQueryInput, jdbi, outputTable);
        } catch (JsonProcessingException e) {
          throw new RuntimeException(e);
        }
      });

      log.info(aMarker, "Control Data Comparison Action has been completed {}  ", controlDataComparison.getName());
    } catch (Exception e) {
      action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
      log.error(aMarker, "Error in execute method for Control Data Comparison ", e);
      throw new HandymanException("Error in execute method for Control Data Comparison", e, action);
    }
  }

  private void doControlDataValidation(ControlDataComparisonQueryInputTable controlDataComparisonQueryInputTable, Jdbi jdbi, String outputTable) throws JsonProcessingException {
    log.info("Processing the Control Data Comparison input data ControlDataComparisonQueryInputTable: {}", controlDataComparisonQueryInputTable);

    Long tenantId = controlDataComparisonQueryInputTable.getTenantId();
    String originId = controlDataComparisonQueryInputTable.getOriginId();
    Long groupId = controlDataComparisonQueryInputTable.getGroupId();
    Long paperNo = controlDataComparisonQueryInputTable.getPaperNo();
    String batchId = controlDataComparisonQueryInputTable.getBatchId();
    Long rootPipelineId  = controlDataComparisonQueryInputTable.getRootPipelineId();
    String extractedValue = controlDataComparisonQueryInputTable.getExtractedValue();
    String actualValue = controlDataComparisonQueryInputTable.getActualValue();
    String allowedAdapters = controlDataComparisonQueryInputTable.getAllowedAdapter();
    String fileName = controlDataComparisonQueryInputTable.getFileName();

    //'date','date_reg'
    Long mismatchCount;
    if(allowedAdapters.equals("date")  || allowedAdapters.equals("date_reg")){
      try {
        mismatchCount = dateValidation(extractedValue, actualValue, "yyyy/MM/dd");
        String matchStatus = calculateValidationScores(mismatchCount);
        log.info("Inserting date type data validation at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName);
      } catch (HandymanException e) {
        throw new HandymanException("Error while inserting date type data validation", e, action);
      }
    }
    //gender
    else if(allowedAdapters.equals("gender")) {
      try {
        mismatchCount = genderValidation(extractedValue, actualValue);
        String matchStatus = calculateValidationScores(mismatchCount);
        log.info("Inserting gender type data validation at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName);
      } catch (HandymanException e) {
        throw new HandymanException("Error while inserting gender type data validation.", e ,action);
      }
    }
    else {
      try {
        mismatchCount = dataValidation(extractedValue, actualValue);
        String matchStatus = calculateValidationScores(mismatchCount);
        log.info("Inserting string type data validation at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName);
      } catch (HandymanException e) {
        throw new HandymanException("Error while inserting gender type data validation.", e, action);
      }
    }
  }

  private void insertExecutionInfo(Jdbi jdbi, String outputTable, Long rootPipelineId, Long groupId, Long tenantId, String originId, String batchId, Long paperNo, String actualValue, String extractedValue, String matchStatus, Long mismatchCount, String fileName) {
    jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable + "(root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, paper_no, actual_value, extracted_value, match_status, mismatch_count, tenant_id) " +
                    "VALUES(:rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, :actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId);")
            .bind("rootPipelineId", rootPipelineId)
            .bind("createdOn", LocalDate.now())
            .bind("groupId", groupId)
            .bind("batchId", batchId)
            .bind("fileName",fileName)
            .bind("originId", originId)
            .bind("paperNo", paperNo)
            .bind("actualValue", actualValue)
            .bind("extractedValue", extractedValue)
            .bind("matchStatus", matchStatus)
            .bind("mismatchCount", mismatchCount)
            .bind("tenantId", tenantId)
            .execute());
  }

  public String calculateValidationScores(Long mismatchCount) {
    String matchStatus;
    if (mismatchCount == 0) {
      matchStatus = "NO TOUCH";
    } else if (mismatchCount <= Long.parseLong(THRESHOLD_ONE_TOUCH)) {
      matchStatus = "ONE TOUCH";
    } else if (mismatchCount <= Long.parseLong(THRESHOLD_LOW_TOUCH)) {
      matchStatus = "LOW TOUCH";
    } else {
      matchStatus = "HIGH TOUCH";
    }
    return matchStatus;
  }

  public static Long dataValidation(String extractedData, String actualData) {
    if (extractedData == null || extractedData.isEmpty()) {
      log.error("Invalid input for extractedData={}", extractedData);
      return (long) actualData.length();
    }
    if (actualData == null || actualData.isEmpty()){
      log.error("Invalid input for actualData={}", actualData);
      return (long) extractedData.length();
    }

    // Normalize by removing spaces and special characters
    String normalizedExtracted = extractedData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
    String normalizedActual = actualData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();

    // Compute Levenshtein Distance
    int distance = LevenshteinDistance.getDefaultInstance().apply(normalizedExtracted, normalizedActual);

    // If exact match (after normalization), return 0
    if (distance == 0) {
      return 0L;
    }

    // Check if actualData (normalized) is fully contained in extractedData (normalized)
    if (normalizedExtracted.contains(normalizedActual)) {
      return 0L;
    }

    // Check if both strings contain the same words in any order (ignoring spaces & special chars)
    Set<String> extractedWords = new HashSet<>(Arrays.asList(extractedData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));
    Set<String> actualWords = new HashSet<>(Arrays.asList(actualData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));

    if (extractedWords.equals(actualWords)) {
      return 0L; // Words are the same but in a different order
    }

    return (long) distance;
  }

  public static Long dateValidation(String extractedDate, String actualDate, String inputFormat) {
    if (extractedDate == null || extractedDate.isEmpty()) {
      log.error("Invalid input for extractedDate={}", extractedDate);
      return (long) actualDate.length();
    }
    if (actualDate == null || actualDate.isEmpty()){
      log.error("Invalid input for actualDate={}", actualDate);
      return (long) extractedDate.length();
    }

    String extractedLocalDate = null;

    try {
      if (extractedDate.matches("\\d{8}")) {
        extractedLocalDate = parseEightDigitDate(extractedDate, inputFormat);
      }

      if (extractedLocalDate == null) {
        extractedLocalDate =  parseDateWithFormat(extractedDate, inputFormat);
      }
    } catch (DateTimeParseException e) {
      log.error("Invalid extracted date format: {}", extractedDate);
      return (long) actualDate.length();
    }

    String actualLocalDate;
    try {
      actualLocalDate = parseDateWithFormat(actualDate, inputFormat);
    } catch (DateTimeParseException e) {
      log.error("Invalid actual date format: {}", actualDate);
      return (long) actualDate.length();
    }

    return getMismatchCount(extractedLocalDate, actualLocalDate);
  }

  private static String parseDateWithFormat(String date, String inputFormat) {
    for (String format : POSSIBLE_DATE_FORMATS) {
      try {
        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern(format);
        LocalDate parsedDate = LocalDate.parse(date, inputFormatter);

        DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
        return parsedDate.format(outputFormatter);
      } catch (DateTimeParseException ignored) {
      }
    }
    return date;
  }

  private static String parseEightDigitDate(String date, String inputFormat) {
    String[] possibleFormats = {"yyyyMMdd", "MMddyyyy", "ddMMyyyy"};

    for (String format : possibleFormats) {
      try {
        String reformattedDate = reformatEightDigitDate(date, format);
        if (reformattedDate.isEmpty()) continue;

        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        LocalDate parsedDate = LocalDate.parse(reformattedDate, inputFormatter);

        DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
        return parsedDate.format(outputFormatter);
      } catch (DateTimeParseException | NullPointerException ignored) {
      }
    }
    return null;
  }

  private static String reformatEightDigitDate(String date, String format) {
    if (date.length() != 8) return "";
    try {
        switch (format) {
            case "yyyyMMdd":
                return date.substring(0, 4) + "-" + date.substring(4, 6) + "-" + date.substring(6, 8);
            case "MMddyyyy":
                return date.substring(4, 8) + "-" + date.substring(0, 2) + "-" + date.substring(2, 4);
            case "ddMMyyyy":
                return date.substring(4, 8) + "-" + date.substring(2, 4) + "-" + date.substring(0, 2);
        }
    } catch (Exception ignored) {
    }
    return "";
  }

  public Long genderValidation(String extractedGender, String generatedGender) {
    String formattedExtractedGender = normalizeGender(extractedGender);
    String formattedGeneratedGender = normalizeGender(generatedGender);

    // If either gender is invalid, return -1
    if (formattedExtractedGender.equals("Invalid") || formattedGeneratedGender.equals("Invalid")) {
      return -1L;
    }

    // If gender values do not match, return total character count of extracted gender
    return formattedExtractedGender.equalsIgnoreCase(formattedGeneratedGender)
            ? 0L  // No mismatch
            : (long) formattedExtractedGender.length();
  }

  private String normalizeGender(String gender) {
    if (gender == null) return "Invalid";

    gender = gender.trim().toLowerCase();

    switch (gender) {
      case "m":
      case "male":
        return "Male";
      case "f":
      case "female":
        return "Female";
      default:
        return "Invalid";
    }
  }

  // Custom method to calculate mismatch count manually
  private static Long getMismatchCount(String str1, String str2) {
    int mismatchCount = 0;
    int length = Math.max(str1.length(), str2.length());

    for (int i = 0; i < length; i++) {
      char c1 = (i < str1.length()) ? str1.charAt(i) : '\0';
      char c2 = (i < str2.length()) ? str2.charAt(i) : '\0';

      if (c1 != c2) {
        mismatchCount++;
      }
    }

    return (long) mismatchCount;
  }

  @Override
  public boolean executeIf() throws Exception {
    return controlDataComparison.getCondition();
  }
}
