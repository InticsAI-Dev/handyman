package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapter;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapterFactory;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Query;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    public static final String ACTUAL_ENCRYPTION_VARIABLE = "actual.encryption.variable";
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;
    ActionExecutionAudit actionExecutionAudit = new ActionExecutionAudit();

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
    }

    @Override
    public void execute() throws Exception {
        try {

            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            String querySet = controlDataComparison.getQuerySet();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = getControlDataComparisonQueryInputTables(jdbi, querySet);

            log.info(aMarker, "Total rows returned from the query: {}", controlDataComparisonQueryInputTables.size());

            InticsIntegrity encryptionHandler = SecurityEngine.getInticsIntegrityMethod(action, log);

            performDecryption(controlDataComparisonQueryInputTables, encryptionHandler);

            invokeValidationPerRecord(controlDataComparisonQueryInputTables, jdbi, outputTable, encryptionHandler);

            log.info(aMarker, "Control Data Comparison Action has been completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");

        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    //DEBUG ON YOUR OWN RISK
    private void performDecryption(List<ControlDataComparisonQueryInputTable> records,
                                   InticsIntegrity encryptionHandler) {
        boolean itemWiseEncryption = Boolean.parseBoolean(
                action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false"));
        boolean actualEncryption = Boolean.parseBoolean(
                action.getContext().getOrDefault(ACTUAL_ENCRYPTION_VARIABLE, "false"));

        if (itemWiseEncryption) {
            log.info(aMarker, "Starting Decryption process for item-wise encryption");
            decryptAndUpdate(records, encryptionHandler, true);
        } else {
            log.info(aMarker, "Skipping Decryption as itemWiseEncryption is false");
        }

        if (actualEncryption) {
            log.info(aMarker, "Starting Decryption process for actual value encryption");
            decryptAndUpdate(records, encryptionHandler, false);
        } else {
            log.info(aMarker, "Skipping Decryption as actualEncryption is false");
        }
    }

    //DEBUG ON YOUR OWN RISK
    private void performEncryption(
            List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables,
            InticsIntegrity encryptionHandler
    ) {
        boolean itemWiseEncryption = Boolean.parseBoolean(
                action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false")
        );
        boolean actualEncryption = Boolean.parseBoolean(
                action.getContext().getOrDefault(ACTUAL_ENCRYPTION_VARIABLE, "false")
        );

        if (itemWiseEncryption) {
            log.info(aMarker, "Starting Encryption process for item-wise encryption");
            encryptAndApply(controlDataComparisonQueryInputTables, encryptionHandler, true);
        } else {
            log.info(aMarker, "Skipping Encryption as itemWiseEncryption is false");
        }

        if (actualEncryption) {
            log.info(aMarker, "Starting Encryption process for actual encryption");
            encryptAndApply(controlDataComparisonQueryInputTables, encryptionHandler, false);
        } else {
            log.info(aMarker, "Skipping Encryption as actualEncryption is false");
        }
    }

    private void decryptAndUpdate(
            List<ControlDataComparisonQueryInputTable> records,
            InticsIntegrity encryptionHandler,
            boolean isExtracted
    ) {
        List<EncryptionRequestClass> requests = buildDecryptionRequests(records, isExtracted);

        if (requests.isEmpty()) {
            return;
        }

        List<EncryptionRequestClass> responses = encryptionHandler.decrypt(requests);
        Map<String, List<EncryptionRequestClass>> groupedResponses = groupResponsesByRecordId(responses);

        applyDecryptedValues(records, groupedResponses, isExtracted);
    }

    /**
     * Builds decryption requests from records.
     */
    private List<EncryptionRequestClass> buildDecryptionRequests(
            List<ControlDataComparisonQueryInputTable> records,
            boolean isExtracted
    ) {
        List<EncryptionRequestClass> requests = new ArrayList<>();

        for (ControlDataComparisonQueryInputTable r : records) {
            if (!"t".equalsIgnoreCase(r.getIsEncrypted())) continue;

            String rawVal = isExtracted ? r.getExtractedValue() : r.getActualValue();
            if (rawVal == null || rawVal.isEmpty()) continue;

            if ("multi_value".equalsIgnoreCase(r.getLineItemType()) && rawVal.contains(",")) {
                addMultiValueRequests(requests, r, rawVal);
            } else {
                requests.add(newRequest(String.valueOf(r.getId()), rawVal, r.getEncryptionPolicy()));
            }
        }

        return requests;
    }

    /**
     * Adds split requests for multi-value fields.
     */
    private void addMultiValueRequests(List<EncryptionRequestClass> requests,
                                       ControlDataComparisonQueryInputTable record,
                                       String rawVal) {
        String[] parts = rawVal.split(",");
        for (int i = 0; i < parts.length; i++) {
            String trimmed = parts[i].trim();
            if (!trimmed.isEmpty()) {
                requests.add(newRequest(record.getId() + "_" + i, trimmed, record.getEncryptionPolicy()));
            }
        }
    }

    /**
     * Builds a single request object.
     */
    private EncryptionRequestClass newRequest(String key, String value, String policy) {
        return EncryptionRequestClass.builder()
                .key(key)
                .value(value)
                .policy(policy)
                .build();
    }

    /**
     * Groups responses by record id (ignores multi-value suffix).
     */
    private Map<String, List<EncryptionRequestClass>> groupResponsesByRecordId(
            List<EncryptionRequestClass> responses
    ) {
        return responses.stream()
                .collect(Collectors.groupingBy(resp -> {
                    String key = resp.getKey();
                    return key.contains("_") ? key.substring(0, key.indexOf("_")) : key;
                }));
    }

    /**
     * Applies decrypted values back to records.
     */
    private void applyDecryptedValues(List<ControlDataComparisonQueryInputTable> records,
                                      Map<String, List<EncryptionRequestClass>> groupedResponses,
                                      boolean isExtracted) {
        for (ControlDataComparisonQueryInputTable r : records) {
            List<EncryptionRequestClass> respList = groupedResponses.get(String.valueOf(r.getId()));
            if (respList == null) continue;

            // preserve order for multi-value
            respList.sort(Comparator.comparingInt(resp -> {
                if (!resp.getKey().contains("_")) return 0;
                return Integer.parseInt(resp.getKey().substring(resp.getKey().indexOf("_") + 1));
            }));

            String finalValue = respList.stream()
                    .map(EncryptionRequestClass::getValue)
                    .collect(Collectors.joining(","));

            if (isExtracted) {
                r.setExtractedValue(finalValue);
            } else {
                r.setActualValue(finalValue);
            }
        }
    }


    private void encryptAndApply(
            List<ControlDataComparisonQueryInputTable> records,
            InticsIntegrity encryptionHandler,
            boolean isExtracted
    ) {
        List<EncryptionRequestClass> requests = buildEncryptionRequests(records, isExtracted);

        if (requests.isEmpty()) {
            log.info(aMarker, "No records found for encryption [{}]",
                    isExtracted ? "ExtractedValue" : "ActualValue");
            return;
        }

        List<EncryptionRequestClass> responses = encryptionHandler.encrypt(requests);
        Map<String, List<EncryptionRequestClass>> groupedResponses = groupResponsesByRecordId(responses);

        applyEncryptedValues(records, groupedResponses, isExtracted);
    }

    /**
     * Builds encryption requests (single + multi expanded).
     */
    private List<EncryptionRequestClass> buildEncryptionRequests(
            List<ControlDataComparisonQueryInputTable> records,
            boolean isExtracted
    ) {
        List<EncryptionRequestClass> requests = new ArrayList<>();

        for (ControlDataComparisonQueryInputTable r : records) {
            if (!"t".equalsIgnoreCase(r.getIsEncrypted())) continue;

            String rawVal = isExtracted ? r.getExtractedValue() : r.getActualValue();
            if (rawVal == null || rawVal.isEmpty()) continue;

            if ("multi_value".equalsIgnoreCase(r.getLineItemType()) && rawVal.contains(",")) {
                addMultiValueRequests(requests, r, rawVal);
            } else {
                requests.add(newRequest(String.valueOf(r.getId()), rawVal, r.getEncryptionPolicy()));
            }
        }
        return requests;
    }


    /**
     * Applies encrypted values back to the original records.
     */
    private void applyEncryptedValues(List<ControlDataComparisonQueryInputTable> records,
                                      Map<String, List<EncryptionRequestClass>> groupedResponses,
                                      boolean isExtracted) {
        for (ControlDataComparisonQueryInputTable r : records) {
            List<EncryptionRequestClass> respList = groupedResponses.get(String.valueOf(r.getId()));
            if (respList == null) continue;

            // Preserve order for multi-value
            respList.sort(Comparator.comparingInt(resp -> {
                if (!resp.getKey().contains("_")) return 0;
                return Integer.parseInt(resp.getKey().substring(resp.getKey().indexOf("_") + 1));
            }));

            String finalValue = respList.stream()
                    .map(EncryptionRequestClass::getValue)
                    .collect(Collectors.joining(","));

            if (isExtracted) {
                r.setExtractedValue(finalValue);
            } else {
                r.setActualValue(finalValue);
            }
        }
    }



    @NotNull
    public List<ControlDataComparisonQueryInputTable> getControlDataComparisonQueryInputTables(Jdbi jdbi, String querySet) {
        final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                List<ControlDataComparisonQueryInputTable> results = query.mapToBean(ControlDataComparisonQueryInputTable.class).list();
                controlDataComparisonQueryInputTables.addAll(results);
                log.info(aMarker, "Executed query from index {}", i.get());
            });
        });
        return controlDataComparisonQueryInputTables;
    }

    public void invokeValidationPerRecord(
            List<ControlDataComparisonQueryInputTable> originalRecords,
            Jdbi jdbi,
            String outputTable,
            InticsIntegrity encryptionHandler
    ) throws JsonProcessingException {

        if (originalRecords == null || originalRecords.isEmpty()) {
            return;
        }

        // Validate + insert + encrypt in one pipeline
        List<ControlDataComparisonQueryInputTable> processedRecords =
                originalRecords.stream()
                        .map(this::doControlDataValidationByAdapters)
                        .collect(Collectors.toList());


        // if performEncryption must be on validated records
        performEncryption(processedRecords, encryptionHandler);

        insertExecutionInfo(jdbi, outputTable, processedRecords);

    }



    private ControlDataComparisonQueryInputTable doControlDataValidationByAdapters(ControlDataComparisonQueryInputTable comparisonInputLineItem) {
        String lowTouch = action.getContext().get("control.data.low.touch.threshold");
        String oneTouch = action.getContext().get("control.data.one.touch.threshold");

        String adapterKey = comparisonInputLineItem.getAllowedAdapter() != null ? comparisonInputLineItem.getAllowedAdapter() : "string";
        ComparisonAdapter adapter = ComparisonAdapterFactory.getAdapter(adapterKey);

        Long mismatchCount = adapter.validate(comparisonInputLineItem, action, log);

        String matchStatus = calculateValidationScores(mismatchCount, oneTouch, lowTouch);

        comparisonInputLineItem.setMatchStatus(matchStatus);
        comparisonInputLineItem.setMismatchCount(mismatchCount);
        return comparisonInputLineItem;
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, List<ControlDataComparisonQueryInputTable> controlDataInputLineItems) {
        if (controlDataInputLineItems == null || controlDataInputLineItems.isEmpty()) {
            return;
        }

        jdbi.useHandle(handle -> {
            String sql = "INSERT INTO " + outputTable + " (" + "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " + "paper_no, actual_value, extracted_value, match_status, mismatch_count, " + "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id" + ") VALUES (" + ":rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, " + ":actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId, " + ":classification, :sorContainerId, :sorItemName, :sorItemId" + ")";

            PreparedBatch batch = handle.prepareBatch(sql);

            for (ControlDataComparisonQueryInputTable item : controlDataInputLineItems) {
                log.info("Queueing data validation result for origin id: {} and paper no: {} and sor item name: {} " + "with match status: {} and mismatch count: {}", item.getOriginId(), item.getPaperNo(), item.getSorItemName(), item.getMatchStatus(), item.getMismatchCount());

                String classification = determineClassification(item.getActualValue(), item.getExtractedValue(), item.getMatchStatus());

                batch.bind("rootPipelineId", item.getRootPipelineId()).bind("createdOn", LocalDate.now()).bind("groupId", item.getGroupId()).bind("fileName", item.getFileName()).bind("originId", item.getOriginId()).bind("batchId", item.getBatchId()).bind("paperNo", item.getPaperNo()).bind("actualValue", item.getActualValue()).bind("extractedValue", item.getExtractedValue()).bind("matchStatus", item.getMatchStatus()).bind("mismatchCount", item.getMismatchCount()).bind("tenantId", item.getTenantId()).bind("classification", classification).bind("sorContainerId", item.getSorContainerId()).bind("sorItemName", item.getSorItemName()).bind("sorItemId", item.getSorItemId()).add();
            }

            int[] counts = batch.execute();
            log.info("Batch insert completed. Inserted {} rows into {}", counts.length, outputTable);
        });
    }


    private String determineClassification(String actualValue, String extractedValue, String matchStatus) {
        String normalizedActual = actualValue == null ? "" : actualValue.trim();
        String normalizedExtracted = extractedValue == null ? "" : extractedValue.trim();

        boolean actualEmpty = normalizedActual.isEmpty();
        boolean extractedEmpty = normalizedExtracted.isEmpty();

        if ("NO TOUCH".equals(matchStatus) && actualEmpty && extractedEmpty) {
            return "TN";
        }

        if ("NO TOUCH".equals(matchStatus) && !actualEmpty && !extractedEmpty) {
            return "TP";
        }

        if (actualEmpty && !extractedEmpty) {
            return "FN";
        }

        if (!actualEmpty && (extractedEmpty || !"NO TOUCH".equals(matchStatus))) {
            return "FP";
        }

        return "UNKNOWN";
    }

    public static String calculateValidationScores(Long mismatchCount, String oneTouch, String lowTouch) {
        String matchStatus;

        if (mismatchCount == 0) {
            matchStatus = "NO TOUCH";
        } else if (mismatchCount <= Long.parseLong(oneTouch)) {
            matchStatus = "ONE TOUCH";
        } else if (mismatchCount <= Long.parseLong(lowTouch)) {
            matchStatus = "LOW TOUCH";
        } else {
            matchStatus = "HIGH TOUCH";
        }
        return matchStatus;
    }


    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}