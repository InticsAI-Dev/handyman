package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapter;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapterFactory;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.lib.utils.CustomBatchWithScaling;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;
    private static final String INSERT_INTO = "INSERT INTO";

    // ðŸ”¹ Column list for control data comparison output
    public static final String COLUMN_LIST = "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " +
            "paper_no, actual_value, extracted_value, match_status, mismatch_count, " +
            "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id";

    // ðŸ”¹ Value placeholders (JDBI ? parameters for prepared statement)
    public static final String VAL_STRING_LIST =
            "VALUES(?,?,?,?,?,?,?, ?,?,?,?,?,?,?,?,?)";

    private static final String DEFAULT_SOCKET_TIMEOUT = "100";
    private static final String THREAD_SLEEP_TIME_DEFAULT = "1000";

    private final ObjectMapper objectMapper;
    private final InticsIntegrity securityEngine;

    private final int threadSleepTime;
    private final int writeBatchSize;
    private int readBatchSize;
    private final int timeout;
    private final String targetTableName;
    private final String controlDataComparisonUrl;
    private final String insertQuery;


    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
        this.securityEngine = SecurityEngine.getInticsIntegrityMethod(this.action, log);
        this.objectMapper = new ObjectMapper();
        this.timeout = parseContextValue(action, "copro.client.socket.timeout", DEFAULT_SOCKET_TIMEOUT);
        this.threadSleepTime = parseContextValue(action, "copro.client.api.sleeptime", THREAD_SLEEP_TIME_DEFAULT);
        this.writeBatchSize = parseContextValue(action, "write.batch.size", "10");
        this.targetTableName = this.controlDataComparison.getOutputTable();
        this.controlDataComparisonUrl = this.controlDataComparison.getEndPoint();
        this.insertQuery = INSERT_INTO + " " + targetTableName + " (" + COLUMN_LIST + ") " + VAL_STRING_LIST;

    }

    private int parseContextValue(ActionExecutionAudit action, String key, String defaultValue) {
        String value = action.getContext().getOrDefault(key, defaultValue).trim();
        int result;

        if (value.isEmpty()) {
            result = Integer.parseInt(defaultValue);
            log.debug("Context key '{}' is empty or missing. Using default value: {}", key, defaultValue);
        } else {
            result = Integer.parseInt(value);
            log.debug("Context key '{}' found with value: '{}'. Parsed as integer: {}", key, value, result);
        }
        return result;
    }

    @Override
    public void execute() throws Exception {
        try {

            final List<URL> urls = Optional.ofNullable(controlDataComparisonUrl).map(s -> Arrays.stream(s.split(",")).map(urlItem -> {
                try {
                    return new URL(urlItem);
                } catch (MalformedURLException e) {
                    log.error("Error in processing the URL {}", urlItem, e);
                    throw new HandymanException("Error in processing the URL", e, action);
                }
            }).collect(Collectors.toList())).orElse(Collections.emptyList());

            int consumerApiCount = 0;
            CustomBatchWithScaling customBatchWithScaling = new CustomBatchWithScaling(action, log);
            boolean isPodScalingCheckEnabled = customBatchWithScaling.isPodScalingCheckEnabled();
            if (isPodScalingCheckEnabled) {
                log.info(aMarker, "Pod Scaling Check is enabled, computing consumer API count using CustomBatchWithScaling");
                consumerApiCount = customBatchWithScaling.computeSorTransactionApiCount();
            }

            if (consumerApiCount <= 0) {
                log.info(aMarker, "No kvp consumer API count found using kube client, using existing context value");
                String key = "Radon.kvp.consumer.API.count";
                consumerApiCount = parseContextValue(action, key, "1");
            }
            log.info(aMarker, "Consumer API count for kvp action is {}", consumerApiCount);

            readBatchSize = parseContextValue(action, "read.batch.size", "10");
            if (consumerApiCount >= readBatchSize) {
                log.info(aMarker, "Consumer API count {} is greater than read batch size {}, setting read batch size to consumer API count", consumerApiCount, readBatchSize);
                readBatchSize = consumerApiCount;
            } else {
                log.info(aMarker, "Consumer API count {} is less than or equal to read batch size {}, keeping read batch size as is", consumerApiCount, readBatchSize);
            }

            final CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonResult> coproProcessor = getTableCoproProcessor(urls);
            Thread.sleep(threadSleepTime);

            final ControlDataComparisonConsumerProcess controlDataComparisonConsumerProcess = new ControlDataComparisonConsumerProcess(log, aMarker, action,controlDataComparison.getResourceConn());
            coproProcessor.startConsumer(insertQuery, consumerApiCount, writeBatchSize, controlDataComparisonConsumerProcess);
            log.info(aMarker, " LLM kvp Action has been completed {}  ", controlDataComparison.getName());


            log.info(aMarker, "Control Data Comparison Action has been completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");

        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    private @NotNull CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonResult> getTableCoproProcessor(List<URL> urls) {
        ControlDataComparisonQueryInputTable neonQueryInputTable = new ControlDataComparisonQueryInputTable();
        final CoproProcessor<ControlDataComparisonQueryInputTable, ControlDataComparisonResult> coproProcessor =
                new CoproProcessor<>(new LinkedBlockingQueue<>(),
                        ControlDataComparisonResult.class,
                        ControlDataComparisonQueryInputTable.class,
                        controlDataComparison.getResourceConn(), log,
                        neonQueryInputTable, urls, action);

        coproProcessor.startProducer(controlDataComparison.getQuerySet(), readBatchSize);
        return coproProcessor;
    }

    @NotNull
    public List<ControlDataComparisonQueryInputTable> getControlDataComparisonQueryInputTables(Jdbi jdbi,String querySet) {
        final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                List<ControlDataComparisonQueryInputTable> results = query
                        .mapToBean(ControlDataComparisonQueryInputTable.class)
                        .list();
                controlDataComparisonQueryInputTables.addAll(results);
                log.info(aMarker, "Executed query from index {}", i.get());
            });
        });
        return controlDataComparisonQueryInputTables;
    }

    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}