package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.encryption.SecurityEngine;
import in.handyman.raven.lib.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.lib.model.ControlDataComparison;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ControlDataComparison"
)
public class ControlDataComparisonAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final ControlDataComparison controlDataComparison;

  private final Logger log;

  private final Marker aMarker;

  public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log,
                                     final Object controlDataComparison) {
    this.controlDataComparison = (ControlDataComparison) controlDataComparison;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" ControlDataComparison:"+this.controlDataComparison.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
      log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

      String outputTable = controlDataComparison.getOutputTable();
      final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(controlDataComparison.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "executing query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<ControlDataComparisonQueryInputTable> resultIterable = query.mapToBean(ControlDataComparisonQueryInputTable.class);
          List<ControlDataComparisonQueryInputTable> publishQueryInputs = resultIterable.stream().collect(Collectors.toList());
          controlDataComparisonQueryInputTables.addAll(publishQueryInputs);
          log.info(aMarker, "executed query from index {}", i.get());
        });
      });

      controlDataComparisonQueryInputTables.forEach(controlDataComparisonQueryInput -> {
        try {
          doControlDataValidation(controlDataComparisonQueryInput, jdbi, outputTable);
        } catch (JsonProcessingException e) {
          HandymanException handymanException = new HandymanException(e);
          HandymanException.insertException("Control data comparison Input table failed {}:", handymanException, action);
        }
      });

      log.info(aMarker, "Control Data Comparison Action has been completed {}  ", controlDataComparison.getName());
    } catch (Exception e) {
      action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
      log.error(aMarker, "Error in execute method for Control Data Comparison ", e);
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("Control data comparison failed {}:", handymanException, action);
    }
  }

  private void doControlDataValidation(ControlDataComparisonQueryInputTable controlDataComparisonQueryInputTable, Jdbi jdbi, String outputTable) throws JsonProcessingException {
    log.info("Processing the Control Data Comparison input data ControlDataComparisonQueryInputTable: {}", controlDataComparisonQueryInputTable);

    Long tenantId = controlDataComparisonQueryInputTable.getTenantId();
    String originId = controlDataComparisonQueryInputTable.getOriginId();
    Long groupId = controlDataComparisonQueryInputTable.getGroupId();
    Long paperNo = controlDataComparisonQueryInputTable.getPaperNo();
    String batchId = controlDataComparisonQueryInputTable.getBatchId();
    Long rootPipelineId  = controlDataComparisonQueryInputTable.getRootPipelineId();
    String extractedValue = controlDataComparisonQueryInputTable.getExtractedValue();
    String actualValue = controlDataComparisonQueryInputTable.getActualValue();
    String allowedAdapters = controlDataComparisonQueryInputTable.getAllowedAdapter();
    String fileName = controlDataComparisonQueryInputTable.getFileName();
    String sorItemName = controlDataComparisonQueryInputTable.getSorItemName();
    String encryptionPolicy = controlDataComparisonQueryInputTable.getEncryptionPolicy();
    String isEncrypted = controlDataComparisonQueryInputTable.getIsEncrypted();

    InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action);
    String encryptData = action.getContext().getOrDefault("pipeline.end.to.end.encryption","false");
    if (Objects.equals(encryptData, "true")) {
      if (Objects.equals(isEncrypted, "t")) {
        log.info("Decryption started for the sorItem {}: for Data comparison.", sorItemName);
        extractedValue = encryption.decrypt(controlDataComparisonQueryInputTable.getExtractedValue(), encryptionPolicy, sorItemName);
        log.info("Decryption completed for the sorItem {}: for Data comparison.", sorItemName);
      }
    }
    //'date','date_reg'
    Long mismatchCount;
    if(allowedAdapters.equals("date")  || allowedAdapters.equals("date_reg")){
      try {
        String finalDateFormat = action.getContext().get("control.data.date.comparison.format");
        mismatchCount = dateValidation(extractedValue, actualValue, finalDateFormat);
        String matchStatus = calculateValidationScores(mismatchCount);
        log.info("Encryption started for the date sorItem {}:", sorItemName);
        if (Objects.equals(encryptData, "true")) {
          if (Objects.equals(isEncrypted, "t")) {
            extractedValue = encryption.encrypt(extractedValue, encryptionPolicy, sorItemName);
          }
        }
        log.info("Encryption completed for the date sorItem {}:", sorItemName);
        log.info("Inserting date type data validation at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName);
      } catch (HandymanException e) {
        HandymanException handymanException = new HandymanException(e);
        HandymanException.insertException("Error while inserting date type data validation", handymanException, action);
      }
    }
    //gender
    else if(allowedAdapters.equals("gender")) {
      try {
        mismatchCount = genderValidation(extractedValue, actualValue);
        String matchStatus = calculateValidationScores(mismatchCount);
        log.info("Encryption started for the gender sorItem {}:", sorItemName);
        if (Objects.equals(encryptData, "true")) {
          if (Objects.equals(isEncrypted, "t")) {
            extractedValue = encryption.encrypt(extractedValue, encryptionPolicy, sorItemName);
          }
        }
        log.info("Encryption completed for the gender sorItem {}:", sorItemName);
        log.info("Inserting gender type data validation at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName);
      } catch (HandymanException e) {
        HandymanException handymanException = new HandymanException(e);
        HandymanException.insertException("Error while inserting gender type data validation.", handymanException ,action);
      }
    }
    else {
      try {
        mismatchCount = dataValidation(extractedValue, actualValue);
        String matchStatus = calculateValidationScores(mismatchCount);
        log.info("Encryption started for the sorItem {}:", sorItemName);
        if (Objects.equals(encryptData, "true")) {
          if (Objects.equals(isEncrypted, "t")) {
            extractedValue = encryption.encrypt(extractedValue, encryptionPolicy, sorItemName);
          }
        }
        log.info("Encryption completed for the sorItem {}:", sorItemName);
        log.info("Inserting string type data validation at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName);
      } catch (HandymanException e) {
        HandymanException handymanException = new HandymanException(e);
        HandymanException.insertException("Error while inserting generic type data validation {}:", handymanException, action);
      }
    }
  }

  private void insertExecutionInfo(Jdbi jdbi, String outputTable, Long rootPipelineId, Long groupId,
                                   Long tenantId, String originId, String batchId, Long paperNo,
                                   String actualValue, String extractedValue, String matchStatus,
                                   Long mismatchCount, String fileName) {
    String classification = determineClassification(actualValue, extractedValue, matchStatus);

    jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable +
                    "(root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " +
                    "paper_no, actual_value, extracted_value, match_status, mismatch_count, " +
                    "tenant_id, classification) " +
                    "VALUES(:rootPipelineId, :createdOn, :groupId, :fileName, :originId, " +
                    ":batchId, :paperNo, :actualValue, :extractedValue, :matchStatus, " +
                    ":mismatchCount, :tenantId, :classification);")
            .bind("rootPipelineId", rootPipelineId)
            .bind("createdOn", LocalDate.now())
            .bind("groupId", groupId)
            .bind("batchId", batchId)
            .bind("fileName",fileName)
            .bind("originId", originId)
            .bind("paperNo", paperNo)
            .bind("actualValue", actualValue)
            .bind("extractedValue", extractedValue)
            .bind("matchStatus", matchStatus)
            .bind("mismatchCount", mismatchCount)
            .bind("tenantId", tenantId)
            .bind("classification", classification)
            .execute());
  }


  private String determineClassification(String actualValue, String extractedValue, String matchStatus) {
    String normalizedActual = actualValue == null ? "" : actualValue.trim();
    String normalizedExtracted = extractedValue == null ? "" : extractedValue.trim();

    boolean actualEmpty = normalizedActual.isEmpty();
    boolean extractedEmpty = normalizedExtracted.isEmpty();

    // True Negative - Both empty and NO TOUCH
    if ("NO TOUCH".equals(matchStatus) && actualEmpty && extractedEmpty) {
      return "TN";
    }

    // True Positive - Both non-empty and NO TOUCH
    if ("NO TOUCH".equals(matchStatus) && !actualEmpty && !extractedEmpty) {
      return "TP";
    }

    // False Positive - Actual empty but extracted present
    if (actualEmpty && !extractedEmpty) {
      return "FP";
    }

    // False Negative cases:
    // 1. Actual present but extracted empty
    // 2. Both present but mismatch (any touch status except NO TOUCH)
    if (!actualEmpty && (extractedEmpty || !"NO TOUCH".equals(matchStatus))) {
      return "FN";
    }

    // Default case (shouldn't normally reach here)
    return "UNKNOWN";
  }

  public String calculateValidationScores(Long mismatchCount) {
    String matchStatus;
    String lowTouch = action.getContext().get("control.data.low.touch.threshold");
    String oneTouch = action.getContext().get("control.data.one.touch.threshold");
    if (mismatchCount == 0) {
      matchStatus = "NO TOUCH";
    } else if (mismatchCount <= Long.parseLong(oneTouch)) {
      matchStatus = "ONE TOUCH";
    } else if (mismatchCount <= Long.parseLong(lowTouch)) {
      matchStatus = "LOW TOUCH";
    } else {
      matchStatus = "HIGH TOUCH";
    }
    return matchStatus;
  }

  public Long dataValidation(String extractedData, String actualData) {
    if (extractedData == null || extractedData.isEmpty()) {
      log.error("Invalid input for extractedData={}", extractedData);
      return actualData == null ? 0L : (long) actualData.length();
    }
    if (actualData == null || actualData.isEmpty()){
      log.error("Invalid input for actualData={}", actualData);
      return (long) extractedData.length();
    }

    String normalizedExtracted = extractedData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
    String normalizedActual = actualData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();

    int distance = LevenshteinDistance.getDefaultInstance().apply(normalizedExtracted, normalizedActual);

    if (distance == 0) {
      return 0L;
    }

    if (normalizedExtracted.contains(normalizedActual)) {
      return 0L;
    }

    Set<String> extractedWords = new HashSet<>(Arrays.asList(extractedData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));
    Set<String> actualWords = new HashSet<>(Arrays.asList(actualData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));

    if (extractedWords.equals(actualWords)) {
      return 0L;
    }

    return (long) distance;
  }

  public Long dateValidation(String extractedDate, String actualDate, String inputFormat) {
    if (extractedDate == null || extractedDate.isEmpty()) {
      log.error("Invalid input for extractedDate={}", extractedDate);
      return actualDate == null ? 0L : (long) actualDate.length();
    }
    if (actualDate == null || actualDate.isEmpty()){
      log.error("Invalid input for actualDate={}", actualDate);
      return (long) extractedDate.length();
    }

    String extractedLocalDate = null;

    try {
      if (extractedDate.matches("\\d{8}")) {
        extractedLocalDate = parseEightDigitDate(extractedDate, inputFormat);
      }

      if (extractedLocalDate == null) {
        extractedLocalDate =  parseDateWithFormat(extractedDate, inputFormat);
      }
    } catch (DateTimeParseException e) {
      log.error("Invalid extracted date format: {}", extractedDate);
      return (long) actualDate.length();
    }

    String actualLocalDate;
    try {
      actualLocalDate = parseDateWithFormat(actualDate, inputFormat);
    } catch (DateTimeParseException e) {
      log.error("Invalid actual date format: {}", actualDate);
      return (long) actualDate.length();
    }

    return getMismatchCount(extractedLocalDate, actualLocalDate);
  }

  private String parseDateWithFormat(String date, String inputFormat) {
    String allowedFormats = action.getContext().get("date.input.formats");

    List<DateTimeFormatter> dateInputFormats = Optional.of(allowedFormats)
            .map(s -> Arrays.stream(s.split(";"))
                    .map(DateTimeFormatter::ofPattern)
                    .collect(Collectors.toList()))
            .orElse(Collections.emptyList());

    for (DateTimeFormatter inputFormatter : dateInputFormats) {
      try {
        LocalDate parsedDate = LocalDate.parse(date, inputFormatter);

        DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
        return parsedDate.format(outputFormatter);
      } catch (DateTimeParseException ignored) {
        log.error("Error in parsing the date format for input {} to format {}", inputFormat, date);
      }
    }
    return date;
  }

  private String parseEightDigitDate(String date, String inputFormat) {
    String[] possibleFormats = {"yyyyMMdd", "MMddyyyy", "ddMMyyyy", "MMyyyydd"};

    for (String format : possibleFormats) {
      try {
        String reformattedDate = reformatEightDigitDate(date, format);
        if (reformattedDate.isEmpty()) continue;

        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        LocalDate parsedDate = LocalDate.parse(reformattedDate, inputFormatter);

        DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
        return parsedDate.format(outputFormatter);
      } catch (DateTimeParseException | NullPointerException ignored) {
        log.error("Error in parsing the Eight digit date format for input {} to format {}", inputFormat, date);
      }
    }
    return null;
  }

  private String reformatEightDigitDate(String date, String format) {
    if (date.length() != 8) return "";
    try {
        switch (format) {
            case "yyyyMMdd":
                return date.substring(0, 4) + "-" + date.substring(4, 6) + "-" + date.substring(6, 8);
            case "MMddyyyy":
                return date.substring(4, 8) + "-" + date.substring(0, 2) + "-" + date.substring(2, 4);
            case "ddMMyyyy":
                return date.substring(4, 8) + "-" + date.substring(2, 4) + "-" + date.substring(0, 2);
        }
    } catch (Exception ignored) {
      log.error("Error in reformatting the Eight digit date format for input {} to format {}", format, date);
    }
    return "";
  }

  public Long genderValidation(String extractedGender, String generatedGender) {
    if (extractedGender == null) {
      log.error("Invalid input for extractedGender: null");
      return generatedGender == null ? 0L : (long) generatedGender.length();
    }
    if (generatedGender == null) {
      log.error("Invalid input for generatedGender: null");
      return (long) extractedGender.length();
    }
    String formattedExtractedGender = normalizeGender(extractedGender);
    String formattedGeneratedGender = normalizeGender(generatedGender);

    if (formattedExtractedGender.equals("Invalid") || formattedGeneratedGender.equals("Invalid")) {
      return 1L;
    }

    return formattedExtractedGender.equalsIgnoreCase(formattedGeneratedGender)
            ? 0L  // No mismatch
            : (long) formattedExtractedGender.length();
  }

  private String normalizeGender(String gender) {
    if (gender == null) return "Invalid";

    gender = gender.trim().toLowerCase();

    switch (gender) {
      case "m":
      case "male":
        return "Male";
      case "f":
      case "female":
        return "Female";
      default:
        return "Invalid";
    }
  }

  private Long getMismatchCount(String str1, String str2) {
    int mismatchCount = 0;
    int length = Math.max(str1.length(), str2.length());

    for (int i = 0; i < length; i++) {
      char c1 = (i < str1.length()) ? str1.charAt(i) : '\0';
      char c2 = (i < str2.length()) ? str2.charAt(i) : '\0';

      if (c1 != c2) {
        mismatchCount++;
      }
    }

    return (long) mismatchCount;
  }

  @Override
  public boolean executeIf() throws Exception {
    return controlDataComparison.getCondition();
  }
}