 package in.handyman.raven.lib;

 import com.fasterxml.jackson.core.JsonProcessingException;
 import in.handyman.raven.core.encryption.SecurityEngine;
 import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
 import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
 import in.handyman.raven.exception.HandymanException;
 import in.handyman.raven.lambda.access.ResourceAccess;
 import in.handyman.raven.lambda.action.ActionExecution;
 import in.handyman.raven.lambda.action.IActionExecution;
 import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
 import in.handyman.raven.lib.model.ControlDataComparison;
 import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
 import in.handyman.raven.util.CommonQueryUtil;
 import org.apache.commons.text.similarity.LevenshteinDistance;
 import org.jdbi.v3.core.Jdbi;
 import org.jdbi.v3.core.result.ResultIterable;
 import org.jdbi.v3.core.statement.Query;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;

 import java.time.LocalDate;
 import java.time.format.DateTimeFormatter;
 import java.time.format.DateTimeParseException;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Collectors;

 import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(controlDataComparison.getQuerySet());
                AtomicInteger i = new AtomicInteger(0);
                formattedQuery.forEach(sqlToExecute -> {
                    log.info(aMarker, "executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<ControlDataComparisonQueryInputTable> resultIterable = query.mapToBean(ControlDataComparisonQueryInputTable.class);
                    List<ControlDataComparisonQueryInputTable> publishQueryInputs = resultIterable.stream().collect(Collectors.toList());
                    controlDataComparisonQueryInputTables.addAll(publishQueryInputs);
                    log.info(aMarker, "executed query from index {}", i.get());
                });
            });
            log.info(aMarker, "Control data comparison total rows returned from the query {}", controlDataComparisonQueryInputTables.size());

            String kafkaComparison = action.getContext().getOrDefault("kafka.production.activator", "false");
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            if (Objects.equals(kafkaComparison, "true")) {
                // Batch decryption for encrypted, non-empty extractedValues and actualValues
                List<EncryptionRequestClass> decryptionRequests = new ArrayList<>();
                controlDataComparisonQueryInputTables.forEach(input -> {
                    String sorItemName = input.getSorItemName();
                    String encryptionPolicy = input.getEncryptionPolicy();
                    // Handle extractedValue
                    if (Objects.equals(input.getIsEncrypted(), "t") && input.getExtractedValue() != null && !input.getExtractedValue().isEmpty()) {
                        if ("multi_value".equals(input.getLineItemType())) {
                            String[] elements = input.getExtractedValue().split(",");
                            for (int i = 0; i < elements.length; i++) {
                                String element = elements[i].trim();
                                if (!element.isEmpty()) {
                                    decryptionRequests.add(new EncryptionRequestClass(encryptionPolicy, element, sorItemName + "_extracted_" + i));
                                }
                            }
                        } else {
                            decryptionRequests.add(new EncryptionRequestClass(encryptionPolicy, input.getExtractedValue(), sorItemName + "_extracted"));
                        }
                    }
                    // Handle actualValue
                    if (Objects.equals(input.getIsEncrypted(), "t") && input.getActualValue() != null && !input.getActualValue().isEmpty()) {
                        if ("multi_value".equals(input.getLineItemType())) {
                            String[] elements = input.getActualValue().split(",");
                            for (int i = 0; i < elements.length; i++) {
                                String element = elements[i].trim();
                                if (!element.isEmpty()) {
                                    decryptionRequests.add(new EncryptionRequestClass(encryptionPolicy, element, sorItemName + "_actual_" + i));
                                }
                            }
                        } else {
                            decryptionRequests.add(new EncryptionRequestClass(encryptionPolicy, input.getActualValue(), sorItemName + "_actual"));
                        }
                    }
                });

                if (!decryptionRequests.isEmpty()) {
                    try {
                        List<EncryptionRequestClass> decryptedResults = encryption.decrypt(decryptionRequests);
                        Map<String, String> decryptedMap = decryptedResults.stream()
                                .collect(Collectors.toMap(EncryptionRequestClass::getKey, EncryptionRequestClass::getValue, (v1, v2) -> v1));
                        controlDataComparisonQueryInputTables.forEach(input -> {
                            String sorItemName = input.getSorItemName();
                            // Handle extractedValue
                            if (Objects.equals(input.getIsEncrypted(), "t") && input.getExtractedValue() != null && !input.getExtractedValue().isEmpty()) {
                                if ("multi_value".equals(input.getLineItemType())) {
                                    String[] elements = input.getExtractedValue().split(",");
                                    List<String> decryptedElements = new ArrayList<>();
                                    for (int i = 0; i < elements.length; i++) {
                                        String element = elements[i].trim();
                                        if (!element.isEmpty()) {
                                            String decryptedValue = decryptedMap.get(sorItemName + "_extracted_" + i);
                                            decryptedElements.add(decryptedValue != null ? decryptedValue : "null");
                                        } else {
                                            decryptedElements.add("null");
                                            log.warn(aMarker, "Empty element at index {} for encrypted extractedValue of sorItem: {}", i, sorItemName);
                                        }
                                    }
                                    String decryptedString = String.join(",", decryptedElements);
                                    input.setExtractedValue(decryptedString);
                                    log.info(aMarker, "Batch decryption completed for extractedValue of sorItem: {}", sorItemName);
                                } else {
                                    String decryptedValue = decryptedMap.get(sorItemName + "_extracted");
                                    input.setExtractedValue(decryptedValue != null ? decryptedValue : null);
                                    log.info(aMarker, "Batch decryption completed for extractedValue of sorItem: {}", sorItemName);
                                }
                            } else if (Objects.equals(input.getIsEncrypted(), "t")) {
                                log.warn(aMarker, "Empty extractedValue for encrypted sorItem: {}, setting to null", sorItemName);
                                input.setExtractedValue(null);
                            }
                            // Handle actualValue
                            if (Objects.equals(input.getIsEncrypted(), "t") && input.getActualValue() != null && !input.getActualValue().isEmpty()) {
                                if ("multi_value".equals(input.getLineItemType())) {
                                    String[] elements = input.getActualValue().split(",");
                                    List<String> decryptedElements = new ArrayList<>();
                                    for (int i = 0; i < elements.length; i++) {
                                        String element = elements[i].trim();
                                        if (!element.isEmpty()) {
                                            String decryptedValue = decryptedMap.get(sorItemName + "_actual_" + i);
                                            decryptedElements.add(decryptedValue != null ? decryptedValue : "null");
                                        } else {
                                            decryptedElements.add("null");
                                            log.warn(aMarker, "Empty element at index {} for encrypted actualValue of sorItem: {}", i, sorItemName);
                                        }
                                    }
                                    String decryptedString = String.join(",", decryptedElements);
                                    input.setActualValue(decryptedString);
                                    log.info(aMarker, "Batch decryption completed for actualValue of sorItem: {}", sorItemName);
                                } else {
                                    String decryptedValue = decryptedMap.get(sorItemName + "_actual");
                                    input.setActualValue(decryptedValue != null ? decryptedValue : null);
                                    log.info(aMarker, "Batch decryption completed for actualValue of sorItem: {}", sorItemName);
                                }
                            } else if (Objects.equals(input.getIsEncrypted(), "t")) {
                                log.warn(aMarker, "Empty actualValue for encrypted sorItem: {}, setting to null", sorItemName);
                                input.setActualValue(null);
                            }
                        });
                    } catch (HandymanException e) {
                        log.error(aMarker, "Batch decryption failed", e);
                        HandymanException.insertException("Batch decryption failed", e, action);
                        controlDataComparisonQueryInputTables.forEach(input -> {
                            String sorItemName = input.getSorItemName();
                            if (Objects.equals(input.getIsEncrypted(), "t") && input.getExtractedValue() != null && !input.getExtractedValue().isEmpty()) {
                                input.setExtractedValue(null);
                                log.warn(aMarker, "Set extractedValue to null for sorItem: {} due to decryption failure", sorItemName);
                            }
                            if (Objects.equals(input.getIsEncrypted(), "t") && input.getActualValue() != null && !input.getActualValue().isEmpty()) {
                                input.setActualValue(null);
                                log.warn(aMarker, "Set actualValue to null for sorItem: {} due to decryption failure", sorItemName);
                            }
                        });
                    }
                } else {
                    log.info(aMarker, "No valid encrypted extractedValues or actualValues found for batch decryption");
                    controlDataComparisonQueryInputTables.forEach(input -> {
                        String sorItemName = input.getSorItemName();
                        if (Objects.equals(input.getIsEncrypted(), "t") && (input.getExtractedValue() == null || input.getExtractedValue().isEmpty())) {
                            log.warn(aMarker, "Empty extractedValue for encrypted sorItem: {}, setting to null", sorItemName);
                            input.setExtractedValue(null);
                        }
                        if (Objects.equals(input.getIsEncrypted(), "t") && (input.getActualValue() == null || input.getActualValue().isEmpty())) {
                            log.warn(aMarker, "Empty actualValue for encrypted sorItem: {}, setting to null", sorItemName);
                            input.setActualValue(null);
                        }
                    });
                }
            }

            controlDataComparisonQueryInputTables.forEach(controlDataComparisonQueryInput -> {
                try {
                    doControlDataValidation(controlDataComparisonQueryInput, jdbi, outputTable, kafkaComparison, encryption);
                } catch (JsonProcessingException e) {
                    HandymanException handymanException = new HandymanException(e);
                    HandymanException.insertException("Control data comparison Input table failed: " + controlDataComparisonQueryInput.getOriginId(), handymanException, action);
                }
            });

            log.info(aMarker, "Control Data Comparison Action has been completed {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");
        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    private void doControlDataValidation(ControlDataComparisonQueryInputTable controlDataComparisonQueryInputTable, Jdbi jdbi, String outputTable, String kafkaComparison, InticsIntegrity encryption) throws JsonProcessingException {
        log.info(aMarker, "Processing the Control Data Comparison input data for origin id: {} and paper no: {} and sor item name: {}",
                controlDataComparisonQueryInputTable.getOriginId(),
                controlDataComparisonQueryInputTable.getPaperNo(),
                controlDataComparisonQueryInputTable.getSorItemName());

        Long tenantId = controlDataComparisonQueryInputTable.getTenantId();
        String originId = controlDataComparisonQueryInputTable.getOriginId();
        Long groupId = controlDataComparisonQueryInputTable.getGroupId();
        Long paperNo = controlDataComparisonQueryInputTable.getPaperNo();
        String batchId = controlDataComparisonQueryInputTable.getBatchId();
        String extractedValue = controlDataComparisonQueryInputTable.getExtractedValue();
        String actualValue = controlDataComparisonQueryInputTable.getActualValue();
        String allowedAdapters = controlDataComparisonQueryInputTable.getAllowedAdapter();
        String fileName = controlDataComparisonQueryInputTable.getFileName();
        String sorItemName = controlDataComparisonQueryInputTable.getSorItemName();
        String encryptionPolicy = controlDataComparisonQueryInputTable.getEncryptionPolicy();
        String isEncrypted = controlDataComparisonQueryInputTable.getIsEncrypted();
        Long sorItemId = controlDataComparisonQueryInputTable.getSorItemId();
        Long sorContainerId = controlDataComparisonQueryInputTable.getSorContainerId();
        String lineItemType = controlDataComparisonQueryInputTable.getLineItemType();

        String encryptData = action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false");

        // Store decrypted values for validation
        String decryptedExtractedValue = extractedValue;
        String decryptedActualValue = actualValue;

        // Item-wise decryption for non-Kafka case (unchanged)
        if (!Objects.equals(kafkaComparison, "true") && Objects.equals(encryptData, "true")) {
            // Decrypt extractedValue
            if (Objects.equals(isEncrypted, "t") && extractedValue != null && !extractedValue.isEmpty()) {
                log.info(aMarker, "Decryption started for extractedValue of sorItem {}: for Data comparison.", sorItemName);
                try {
                    if ("multi_value".equals(lineItemType)) {
                        String[] elements = extractedValue.split(",");
                        List<String> decryptedElements = new ArrayList<>();
                        for (int i = 0; i < elements.length; i++) {
                            String element = elements[i].trim();
                            if (!element.isEmpty()) {
                                String decryptedElement = encryption.decrypt(element, encryptionPolicy, sorItemName + "_extracted_" + i);
                                decryptedElements.add(decryptedElement != null ? decryptedElement : "null");
                            } else {
                                decryptedElements.add("null");
                                log.warn(aMarker, "Empty element at index {} for encrypted extractedValue of sorItem: {}", i, sorItemName);
                            }
                        }
                        decryptedExtractedValue = String.join(",", decryptedElements);
                        log.info(aMarker, "Decryption completed for extractedValue of sorItem {}: for Data comparison.", sorItemName);
                    } else {
                        decryptedExtractedValue = encryption.decrypt(extractedValue, encryptionPolicy, sorItemName);
                        log.info(aMarker, "Decryption completed for extractedValue of sorItem {}: for Data comparison.", sorItemName);
                    }
                } catch (HandymanException e) {
                    log.error(aMarker, "Decryption failed for extractedValue of sorItem: {}", sorItemName, e);
                    decryptedExtractedValue = null;
                    HandymanException.insertException("Decryption failed for extractedValue of sorItem: " + sorItemName, e, action);
                }
            } else if (Objects.equals(isEncrypted, "t")) {
                log.warn(aMarker, "Empty extractedValue for encrypted sorItem: {}, setting to null for Data comparison.", sorItemName);
                decryptedExtractedValue = null;
            }

            // Decrypt actualValue
            if (Objects.equals(isEncrypted, "t") && actualValue != null && !actualValue.isEmpty()) {
                log.info(aMarker, "Decryption started for actualValue of sorItem {}: for Data comparison.", sorItemName);
                try {
                    if ("multi_value".equals(lineItemType)) {
                        String[] elements = actualValue.split(",");
                        List<String> decryptedElements = new ArrayList<>();
                        for (int i = 0; i < elements.length; i++) {
                            String element = elements[i].trim();
                            if (!element.isEmpty()) {
                                String decryptedElement = encryption.decrypt(element, encryptionPolicy, sorItemName + "_actual_" + i);
                                decryptedElements.add(decryptedElement != null ? decryptedElement : "null");
                            } else {
                                decryptedElements.add("null");
                                log.warn(aMarker, "Empty element at index {} for encrypted actualValue of sorItem: {}", i, sorItemName);
                            }
                        }
                        decryptedActualValue = String.join(",", decryptedElements);
                        log.info(aMarker, "Decryption completed for actualValue of sorItem {}: for Data comparison.", sorItemName);
                    } else {
                        decryptedActualValue = encryption.decrypt(actualValue, encryptionPolicy, sorItemName);
                        log.info(aMarker, "Decryption completed for actualValue of sorItem {}: for Data comparison.", sorItemName);
                    }
                } catch (HandymanException e) {
                    log.error(aMarker, "Decryption failed for actualValue of sorItem: {}", sorItemName, e);
                    decryptedActualValue = null;
                    HandymanException.insertException("Decryption failed for actualValue of sorItem: " + sorItemName, e, action);
                }
            } else if (Objects.equals(isEncrypted, "t")) {
                log.warn(aMarker, "Empty actualValue for encrypted sorItem: {}, setting to null for Data comparison.", sorItemName);
                decryptedActualValue = null;
            }
        }

        // Perform validation
        Long mismatchCount;
        String matchStatus;
        if (allowedAdapters.equals("date") || allowedAdapters.equals("date_reg")) {
            try {
                String finalDateFormat = action.getContext().get("control.data.date.comparison.format");
                mismatchCount = dateValidation(decryptedExtractedValue, decryptedActualValue, finalDateFormat, originId, paperNo, sorItemName, tenantId);
                matchStatus = calculateValidationScores(mismatchCount);
                log.info(aMarker, "Date type data validation completed for sorItem: {}", sorItemName);
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while validating date type data for origin Id " + originId + " paper No " + paperNo, handymanException, action);
                throw handymanException;
            }
        } else if (allowedAdapters.equals("gender")) {
            try {
                mismatchCount = genderValidation(decryptedExtractedValue, decryptedActualValue, originId, paperNo, sorItemName, tenantId);
                matchStatus = calculateValidationScores(mismatchCount);
                log.info(aMarker, "Gender type data validation completed for sorItem: {}", sorItemName);
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while validating gender type data for origin Id " + originId + " paper No " + paperNo, handymanException, action);
                throw handymanException;
            }
        } else {
            try {
                String finalExtractedValue = getNormalizedExtractedValue(decryptedActualValue, decryptedExtractedValue, lineItemType);
                mismatchCount = dataValidation(finalExtractedValue, decryptedActualValue, originId, paperNo, sorItemName, tenantId);
                matchStatus = calculateValidationScores(mismatchCount);
                log.info(aMarker, "String type data validation completed for sorItem: {}", sorItemName);
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while validating generic type data for origin Id: " + originId + " paper No " + paperNo, handymanException, action);
                throw handymanException;
            }
        }

        // Initialize final values for insertion (use decrypted values by default for non-Kafka case)
        String finalExtractedValue = decryptedExtractedValue;
        String finalActualValue = decryptedActualValue;

        // Re-encrypt for Kafka case only
        if (Objects.equals(kafkaComparison, "true") && Objects.equals(isEncrypted, "t")) {
            try {
                // Re-encrypt extractedValue
                if (decryptedExtractedValue != null && !decryptedExtractedValue.isEmpty()) {
                    log.info(aMarker, "Re-encryption started for extractedValue of sorItem: {}", sorItemName);
                    if ("multi_value".equals(lineItemType)) {
                        String[] elements = decryptedExtractedValue.split(",");
                        List<String> encryptedElements = new ArrayList<>();
                        for (int i = 0; i < elements.length; i++) {
                            String element = elements[i].trim();
                            if (!element.isEmpty() && !element.equals("null")) {
                                String encryptedElement = encryption.encrypt(element, encryptionPolicy, sorItemName + "_extracted_" + i);
                                encryptedElements.add(encryptedElement != null ? encryptedElement : "null");
                            } else {
                                encryptedElements.add("null");
                                log.warn(aMarker, "Empty or null element at index {} for re-encryption of extractedValue of sorItem: {}", i, sorItemName);
                            }
                        }
                        finalExtractedValue = String.join(",", encryptedElements);
                        log.info(aMarker, "Re-encryption completed for extractedValue of sorItem: {}", sorItemName);
                    } else {
                        finalExtractedValue = encryption.encrypt(decryptedExtractedValue, encryptionPolicy, sorItemName);
                        log.info(aMarker, "Re-encryption completed for extractedValue of sorItem: {}", sorItemName);
                    }
                } else {
                    log.warn(aMarker, "Empty or null extractedValue for re-encryption of sorItem: {}, setting to null", sorItemName);
                    finalExtractedValue = null;
                }

                // Re-encrypt actualValue
                if (decryptedActualValue != null && !decryptedActualValue.isEmpty()) {
                    log.info(aMarker, "Re-encryption started for actualValue of sorItem: {}", sorItemName);
                    if ("multi_value".equals(lineItemType)) {
                        String[] elements = decryptedActualValue.split(",");
                        List<String> encryptedElements = new ArrayList<>();
                        for (int i = 0; i < elements.length; i++) {
                            String element = elements[i].trim();
                            if (!element.isEmpty() && !element.equals("null")) {
                                String encryptedElement = encryption.encrypt(element, encryptionPolicy, sorItemName + "_actual_" + i);
                                encryptedElements.add(encryptedElement != null ? encryptedElement : "null");
                            } else {
                                encryptedElements.add("null");
                                log.warn(aMarker, "Empty or null element at index {} for re-encryption of actualValue of sorItem: {}", i, sorItemName);
                            }
                        }
                        finalActualValue = String.join(",", encryptedElements);
                        log.info(aMarker, "Re-encryption completed for actualValue of sorItem: {}", sorItemName);
                    } else {
                        finalActualValue = encryption.encrypt(decryptedActualValue, encryptionPolicy, sorItemName);
                        log.info(aMarker, "Re-encryption completed for actualValue of sorItem: {}", sorItemName);
                    }
                } else {
                    log.warn(aMarker, "Empty or null actualValue for re-encryption of sorItem: {}, setting to null", sorItemName);
                    finalActualValue = null;
                }
            } catch (HandymanException e) {
                log.error(aMarker, "Re-encryption failed for sorItem: {}", sorItemName, e);
                HandymanException.insertException("Re-encryption failed for sorItem: " + sorItemName, e, action);
                finalExtractedValue = null;
                finalActualValue = null;
            }
        }

        // Insert the values into the output table (re-encrypted for Kafka, decrypted for non-Kafka)
        log.info(aMarker, "Inserting data validation result at {}:", outputTable);
        insertExecutionInfo(jdbi, outputTable, controlDataComparisonQueryInputTable.getRootPipelineId(), groupId, tenantId, originId, batchId, paperNo, finalActualValue, finalExtractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, Long rootPipelineId, Long groupId,
                                     Long tenantId, String originId, String batchId, Long paperNo,
                                     String actualValue, String extractedValue, String matchStatus,
                                     Long mismatchCount, String fileName, String sorItemName,
                                     Long sorItemId, Long sorContainerId) {

        String classification = determineClassification(actualValue, extractedValue, matchStatus);
        jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable + " (" + "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " + "paper_no, actual_value, extracted_value, match_status, mismatch_count, " + "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id" + ") VALUES (" + ":rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, " + ":actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId, " + ":classification, :sorContainerId, :sorItemName, :sorItemId" + ");").bind("rootPipelineId", rootPipelineId).bind("createdOn", LocalDate.now()).bind("groupId", groupId).bind("fileName", fileName).bind("originId", originId).bind("batchId", batchId).bind("paperNo", paperNo).bind("actualValue", actualValue).bind("extractedValue", extractedValue).bind("matchStatus", matchStatus).bind("mismatchCount", mismatchCount).bind("tenantId", tenantId).bind("classification", classification).bind("sorContainerId", sorContainerId).bind("sorItemName", sorItemName).bind("sorItemId", sorItemId).execute());
    }
    public String getNormalizedExtractedValue(String actualValue, String extractedValue, String lineItemType) {
        if ("multi_value".equals(lineItemType) && actualValue != null && extractedValue != null) {
            final List<String> actualList = Arrays.stream(actualValue.split(","))
                    .map(String::trim)
                    .collect(Collectors.toList());

            final List<String> extractedList = Arrays.stream(extractedValue.split(","))
                    .map(String::trim)
                    .collect(Collectors.toList());

            final Set<String> extractedSet = new HashSet<>(extractedList);

            List<String> reorderedExtracted = actualList.stream()
                    .filter(extractedSet::contains)
                    .collect(Collectors.toList());

            Set<String> actualSet = new HashSet<>(actualList);
            extractedList.stream()
                    .filter(value -> !actualSet.contains(value))
                    .forEach(reorderedExtracted::add);

            log.info("Reordered Extracted value.");
            return String.join(",", reorderedExtracted);
        }
        return extractedValue;
    }

    private String determineClassification(String actualValue, String extractedValue, String matchStatus) {
        String normalizedActual = actualValue == null ? "" : actualValue.trim();
        String normalizedExtracted = extractedValue == null ? "" : extractedValue.trim();

        boolean actualEmpty = normalizedActual.isEmpty();
        boolean extractedEmpty = normalizedExtracted.isEmpty();

        if ("NO TOUCH".equals(matchStatus) && actualEmpty && extractedEmpty) {
            return "TN";
        }

        if ("NO TOUCH".equals(matchStatus) && !actualEmpty && !extractedEmpty) {
            return "TP";
        }

        if (actualEmpty && !extractedEmpty) {
            return "FN";
        }

        if (!actualEmpty && (extractedEmpty || !"NO TOUCH".equals(matchStatus))) {
            return "FP";
        }

        return "UNKNOWN";
    }

    public String calculateValidationScores(Long mismatchCount) {
        String matchStatus;
        String lowTouch = action.getContext().get("control.data.low.touch.threshold");
        String oneTouch = action.getContext().get("control.data.one.touch.threshold");
        if (mismatchCount == 0) {
            matchStatus = "NO TOUCH";
        } else if (mismatchCount <= Long.parseLong(oneTouch)) {
            matchStatus = "ONE TOUCH";
        } else if (mismatchCount <= Long.parseLong(lowTouch)) {
            matchStatus = "LOW TOUCH";
        } else {
            matchStatus = "HIGH TOUCH";
        }
        return matchStatus;
    }

    public Long dataValidation(String extractedData, String actualData, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedData == null || extractedData.isEmpty()) {
            log.warn("Invalid input encountered for extractedData. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return actualData == null ? 0L : (long) actualData.length();
        }
        if (actualData == null || actualData.isEmpty()) {
            log.warn("Invalid input encountered for actualData. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedData.length();
        }

        String normalizedExtracted = extractedData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
        String normalizedActual = actualData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();

        int distance = LevenshteinDistance.getDefaultInstance().apply(normalizedExtracted, normalizedActual);

        if (distance == 0) {
            return 0L;
        }

        if (normalizedExtracted.contains(normalizedActual)) {
            return 0L;
        }

        Set<String> extractedWords = new HashSet<>(Arrays.asList(extractedData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));
        Set<String> actualWords = new HashSet<>(Arrays.asList(actualData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));

        if (extractedWords.equals(actualWords)) {
            return 0L;
        }

        return (long) distance;
    }

    public Long dateValidation(String extractedDate, String actualDate, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedDate == null || extractedDate.isEmpty()) {
            log.warn("Invalid input encountered for extractedDate. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return actualDate == null ? 0L : (long) actualDate.length();
        }
        if (actualDate == null || actualDate.isEmpty()) {
            log.warn("Invalid input encountered for actualDate. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedDate.length();
        }

        String extractedLocalDate = null;

        try {
            if (extractedDate.matches("\\d{8}")) {
                extractedLocalDate = parseEightDigitDate(extractedDate, inputFormat, originId, paperNo, sorItemName, tenantId);
            }

            if (extractedLocalDate == null) {
                extractedLocalDate = parseDateWithFormat(extractedDate, inputFormat, originId, paperNo, sorItemName, tenantId);
            }
        } catch (DateTimeParseException e) {
            log.warn("Invalid extracted date format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) actualDate.length();
        }

        String actualLocalDate;
        try {
            actualLocalDate = parseDateWithFormat(actualDate, inputFormat, originId, paperNo, sorItemName, tenantId);
        } catch (DateTimeParseException e) {
            log.warn("Invalid actual date format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) actualDate.length();
        }

        return getMismatchCount(extractedLocalDate, actualLocalDate);
    }

    private String parseDateWithFormat(String date, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        String allowedFormats = action.getContext().get("date.input.formats");

        List<DateTimeFormatter> dateInputFormats = Optional.of(allowedFormats).map(s -> Arrays.stream(s.split(";")).map(DateTimeFormatter::ofPattern).collect(Collectors.toList())).orElse(Collections.emptyList());

        for (DateTimeFormatter inputFormatter : dateInputFormats) {
            try {
                LocalDate parsedDate = LocalDate.parse(date, inputFormatter);

                DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
                return parsedDate.format(outputFormatter);
            } catch (DateTimeParseException ignored) {
                log.warn("Error in parsing the date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            }
        }
        return date;
    }

    private String parseEightDigitDate(String date, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        String[] possibleFormats = {"yyyyMMdd", "MMddyyyy", "ddMMyyyy", "MMyyyydd"};

        for (String format : possibleFormats) {
            try {
                String reformattedDate = reformatEightDigitDate(date, format, originId, paperNo, sorItemName, tenantId);
                if (reformattedDate.isEmpty()) continue;

                DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
                LocalDate parsedDate = LocalDate.parse(reformattedDate, inputFormatter);

                DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
                return parsedDate.format(outputFormatter);
            } catch (DateTimeParseException | NullPointerException ignored) {
                log.warn("Error in parsing the Eight digit date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            }
        }
        return null;
    }

    private String reformatEightDigitDate(String date, String format, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (date.length() != 8) return "";
        try {
            switch (format) {
                case "yyyyMMdd":
                    return date.substring(0, 4) + "-" + date.substring(4, 6) + "-" + date.substring(6, 8);
                case "MMddyyyy":
                    return date.substring(4, 8) + "-" + date.substring(0, 2) + "-" + date.substring(2, 4);
                case "ddMMyyyy":
                    return date.substring(4, 8) + "-" + date.substring(2, 4) + "-" + date.substring(0, 2);
            }
        } catch (Exception ignored) {
            log.warn("Error in reformatting the Eight digit date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
        }
        return "";
    }

    public Long genderValidation(String extractedGender, String generatedGender, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedGender == null) {
            log.warn("Invalid input for extractedGender. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return generatedGender == null ? 0L : (long) generatedGender.length();
        }
        if (generatedGender == null) {
            log.warn("Invalid input for generatedGender. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedGender.length();
        }
        String formattedExtractedGender = normalizeGender(extractedGender);
        String formattedGeneratedGender = normalizeGender(generatedGender);

        if (formattedExtractedGender.equals("Invalid") || formattedGeneratedGender.equals("Invalid")) {
            return 1L;
        }

        return formattedExtractedGender.equalsIgnoreCase(formattedGeneratedGender) ? 0L  // No mismatch
                : (long) formattedExtractedGender.length();
    }

    private String normalizeGender(String gender) {
        if (gender == null) return "Invalid";

        gender = gender.trim().toLowerCase();

        switch (gender) {
            case "m":
            case "male":
                return "Male";
            case "f":
            case "female":
                return "Female";
            default:
                return "Invalid";
        }
    }

    private Long getMismatchCount(String str1, String str2) {
        int mismatchCount = 0;
        int length = Math.max(str1.length(), str2.length());

        for (int i = 0; i < length; i++) {
            char c1 = (i < str1.length()) ? str1.charAt(i) : '\0';
            char c2 = (i < str2.length()) ? str2.charAt(i) : '\0';

            if (c1 != c2) {
                mismatchCount++;
            }
        }

        return (long) mismatchCount;
    }

    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}