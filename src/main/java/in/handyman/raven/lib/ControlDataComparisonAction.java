package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequest;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(controlDataComparison.getQuerySet());
                AtomicInteger i = new AtomicInteger(0);
                formattedQuery.forEach(sqlToExecute -> {
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                    Query query = handle.createQuery(sqlToExecute);
                    List<ControlDataComparisonQueryInputTable> results = query
                            .mapToBean(ControlDataComparisonQueryInputTable.class)
                            .list();
                    controlDataComparisonQueryInputTables.addAll(results);
                    log.info(aMarker, "Executed query from index {}", i.get());
                });
            });

            log.info(aMarker, "Total rows returned from the query: {}", controlDataComparisonQueryInputTables.size());

            String kafkaComparison = action.getContext().getOrDefault("kafka.production.activator", "false");
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            Map<String, String> decryptedActualMap = new HashMap<>();
            Map<String, String> decryptedExtractedMap = new HashMap<>();
            boolean itemWiseEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false"));
            boolean actualEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault("actual.encryption.variable", "false"));

            // Decryption logic
            if (itemWiseEncryption) {
                Map<String, List<ControlDataComparisonQueryInputTable>> groupedByOrigin = controlDataComparisonQueryInputTables.stream()
                        .filter(r -> "t".equalsIgnoreCase(r.getIsEncrypted()))
                        .collect(Collectors.groupingBy(ControlDataComparisonQueryInputTable::getOriginId));

                for (Map.Entry<String, List<ControlDataComparisonQueryInputTable>> entry : groupedByOrigin.entrySet()) {
                    String originId = entry.getKey();
                    List<ControlDataComparisonQueryInputTable> encryptedItems = entry.getValue();

                    // Decrypt actual values if actualEncryption is true
                    if (actualEncryption) {
                        List<EncryptionRequest> actualValueFields = encryptedItems.stream()
                                .filter(r -> {
                                    if (r.getActualValue() == null || r.getActualValue().trim().isEmpty()) {
                                        log.info(aMarker, "Skipping decryption for actualValue (null or empty) for originId: {}, sorItemName: {} when isEncrypted is true",
                                                originId, r.getSorItemName());
                                        return false;
                                    }
                                    return true;
                                })
                                .map(r -> new EncryptionRequest(r.getEncryptionPolicy(), r.getActualValue(), r.getSorItemName()))
                                .collect(Collectors.toList());

                        if (!actualValueFields.isEmpty()) {
                            try {
                                log.info(aMarker, "Decrypting ACTUAL values for originId: {}", originId);
                                List<EncryptionRequest> decryptedActuals = encryption.decrypt(actualValueFields);
                                decryptedActuals.forEach(decrypted -> {
                                    String key = originId + "|" + decrypted.getKey();
                                    decryptedActualMap.put(key, decrypted.getValue());
                                });
                                log.info(aMarker, "Actual value decryption successful for originId: {}", originId);
                            } catch (Exception e) {
                                log.error(aMarker, "Actual value decryption failed for originId: {}", originId, e);
                            }
                        }
                    }

                    // Decrypt extracted values
                    List<EncryptionRequest> extractedValueFields = encryptedItems.stream()
                            .filter(r -> {
                                if (r.getExtractedValue() == null || r.getExtractedValue().trim().isEmpty()) {
                                    log.info(aMarker, "Skipping decryption for extractedValue (null or empty) for originId: {}, sorItemName: {} when isEncrypted is true",
                                            originId, r.getSorItemName());
                                    return false;
                                }
                                return true;
                            })
                            .map(r -> new EncryptionRequest(r.getEncryptionPolicy(), r.getExtractedValue(), r.getSorItemName()))
                            .collect(Collectors.toList());

                    if (!extractedValueFields.isEmpty()) {
                        try {
                            log.info(aMarker, "Decrypting EXTRACTED values for originId: {}", originId);
                            List<EncryptionRequest> decryptedExtracted = encryption.decrypt(extractedValueFields);
                            decryptedExtracted.forEach(decrypted -> {
                                String key = originId + "|" + decrypted.getKey();
                                decryptedExtractedMap.put(key, decrypted.getValue());
                            });
                            log.info(aMarker, "Extracted value decryption successful for originId: {}", originId);
                        } catch (Exception e) {
                            log.error(aMarker, "Extracted value decryption failed for originId: {}", originId, e);
                        }
                    }
                }
            } else {
                log.info(aMarker, "Skipping decryption as itemWiseEncryption is false");
            }

            invokeValidationPerRecord(controlDataComparisonQueryInputTables, decryptedActualMap,
                    decryptedExtractedMap, jdbi, outputTable, kafkaComparison, encryption);

            log.info(aMarker, "Control Data Comparison Action has been completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");

        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    public void invokeValidationPerRecord(List<ControlDataComparisonQueryInputTable> originalRecords,
                                          Map<String, String> decryptedActualMap,
                                          Map<String, String> decryptedExtractedMap,
                                          Jdbi jdbi,
                                          String outputTable,
                                          String kafkaComparison,
                                          InticsIntegrity encryption) throws JsonProcessingException {
        List<EncryptionRequest> encryptionRequests = new ArrayList<>();
        Map<String, ControlDataComparisonQueryInputTable> recordMap = new HashMap<>();
        boolean itemWiseEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false"));
        boolean actualEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault("actual.encryption.variable", "false"));

        for (ControlDataComparisonQueryInputTable record : originalRecords) {
            String originId = record.getOriginId();
            String sorItemName = record.getSorItemName();
            String key = originId + "|" + sorItemName;

            // Apply decrypted values if available
            if (decryptedActualMap.containsKey(key)) {
                record.setActualValue(decryptedActualMap.get(key));
            }
            if (decryptedExtractedMap.containsKey(key)) {
                record.setExtractedValue(decryptedExtractedMap.get(key));
            }

            String extractedValue = record.getExtractedValue();
            String actualValue = record.getActualValue();
            String isEncrypted = record.getIsEncrypted();

            // Perform validation with decrypted values
            doControlDataValidation(record, jdbi, outputTable, kafkaComparison, encryption, encryptionRequests, recordMap);

            // Prepare for re-encryption based on conditions
            if (itemWiseEncryption && "t".equalsIgnoreCase(isEncrypted)) {
                if (actualEncryption) {
                    // Re-encrypt both actual and extracted values
                    if (actualValue != null && !actualValue.trim().isEmpty()) {
                        encryptionRequests.add(new EncryptionRequest(record.getEncryptionPolicy(), actualValue, sorItemName + "|actual"));
                        recordMap.put(sorItemName + "|actual", record);
                        log.info(aMarker, "Preparing re-encryption for actualValue for sorItemName: {}, originId: {}", sorItemName, originId);
                    } else {
                        log.info(aMarker, "Skipping re-encryption for actualValue (null or empty) for sorItemName: {}, originId: {} when isEncrypted is true", sorItemName, originId);
                    }
                    if (extractedValue != null && !extractedValue.trim().isEmpty()) {
                        encryptionRequests.add(new EncryptionRequest(record.getEncryptionPolicy(), extractedValue, sorItemName + "|extracted"));
                        recordMap.put(sorItemName + "|extracted", record);
                        log.info(aMarker, "Preparing re-encryption for extractedValue for sorItemName: {}, originId: {}", sorItemName, originId);
                    } else {
                        log.info(aMarker, "Skipping re-encryption for extractedValue (null or empty) for sorItemName: {}, originId: {} when isEncrypted is true", sorItemName, originId);
                    }
                } else {
                    // Re-encrypt only extracted values
                    if (extractedValue != null && !extractedValue.trim().isEmpty()) {
                        encryptionRequests.add(new EncryptionRequest(record.getEncryptionPolicy(), extractedValue, sorItemName + "|extracted"));
                        recordMap.put(sorItemName + "|extracted", record);
                        log.info(aMarker, "Preparing re-encryption for extractedValue for sorItemName: {}, originId: {}", sorItemName, originId);
                    } else {
                        log.info(aMarker, "Skipping re-encryption for extractedValue (null or empty) for sorItemName: {}, originId: {} when isEncrypted is true", sorItemName, originId);
                    }
                }
            }
        }

        // Perform batch encryption/re-encryption
        if (!encryptionRequests.isEmpty()) {
            try {
                log.info(aMarker, "Starting batch encryption/re-encryption for {} items", encryptionRequests.size());
                List<EncryptionRequest> encryptedResults = encryption.encrypt(encryptionRequests);
                encryptedResults.forEach(result -> {
                    String[] keyParts = result.getKey().split("\\|");
                    String sorItemName = keyParts[0];
                    String valueType = keyParts[1]; // "extracted" or "actual"
                    ControlDataComparisonQueryInputTable record = recordMap.get(result.getKey());
                    if (record != null) {
                        String originId = record.getOriginId();
                        String paperNo = String.valueOf(record.getPaperNo());
                        log.info(aMarker, "Re-encryption completed for sorItemName: {}, type: {}, originId: {}",
                                sorItemName, valueType, originId);
                        // Update the database with re-encrypted values
                        String column = "actual".equals(valueType) ? "actual_value" : "extracted_value";
                        jdbi.useHandle(handle -> handle.createUpdate("UPDATE " + outputTable + " SET " + column + " = :value " +
                                        "WHERE origin_id = :originId AND sor_item_name = :sorItemName AND paper_no = :paperNo")
                                .bind("value", result.getValue())
                                .bind("originId", originId)
                                .bind("sorItemName", sorItemName)
                                .bind("paperNo", paperNo)
                                .execute());
                    }
                });
                log.info(aMarker, "Batch encryption/re-encryption successful for {} items", encryptedResults.size());
            } catch (Exception e) {
                log.error(aMarker, "Batch encryption/re-encryption failed", e);
            }
        }
    }

    private String doControlDataValidation(ControlDataComparisonQueryInputTable controlDataComparisonQueryInputTable, Jdbi jdbi, String outputTable, String kafkaComparison, InticsIntegrity encryption, List<EncryptionRequest> encryptionRequests, Map<String, ControlDataComparisonQueryInputTable> recordMap) throws JsonProcessingException {
        log.info("Processing the Control Data Comparison input data ControlDataComparisonQueryInputTable for origin id: {} and paper no: {} and sor item name: {}", controlDataComparisonQueryInputTable.getOriginId(), controlDataComparisonQueryInputTable.getPaperNo(), controlDataComparisonQueryInputTable.getSorItemName());

        Long tenantId = controlDataComparisonQueryInputTable.getTenantId();
        String originId = controlDataComparisonQueryInputTable.getOriginId();
        Long groupId = controlDataComparisonQueryInputTable.getGroupId();
        Long paperNo = controlDataComparisonQueryInputTable.getPaperNo();
        String batchId = controlDataComparisonQueryInputTable.getBatchId();
        Long rootPipelineId = controlDataComparisonQueryInputTable.getRootPipelineId();
        String extractedValue = controlDataComparisonQueryInputTable.getExtractedValue();
        String actualValue = controlDataComparisonQueryInputTable.getActualValue();
        String allowedAdapters = controlDataComparisonQueryInputTable.getAllowedAdapter();
        String fileName = controlDataComparisonQueryInputTable.getFileName();
        String sorItemName = controlDataComparisonQueryInputTable.getSorItemName();
        String encryptionPolicy = controlDataComparisonQueryInputTable.getEncryptionPolicy();
        String isEncrypted = controlDataComparisonQueryInputTable.getIsEncrypted();
        Long sorItemId = controlDataComparisonQueryInputTable.getSorItemId();
        Long sorContainerId = controlDataComparisonQueryInputTable.getSorContainerId();
        String lineItemType = controlDataComparisonQueryInputTable.getLineItemType();

        Long mismatchCount;
        if (allowedAdapters.equals("date") || allowedAdapters.equals("date_reg")) {
            try {
                String finalDateFormat = action.getContext().get("control.data.date.comparison.format");
                mismatchCount = dateValidation(extractedValue, actualValue, finalDateFormat, originId, paperNo, sorItemName, tenantId);
                String matchStatus = calculateValidationScores(mismatchCount);
                log.info("Inserting date type data validation at {}:", outputTable);
                insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
                return extractedValue;
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while inserting date type data validation origin Id" + originId + " paper No " + paperNo, handymanException, action);
                return null;
            }
        } else if (allowedAdapters.equals("gender")) {
            try {
                mismatchCount = genderValidation(extractedValue, actualValue, originId, paperNo, sorItemName, tenantId);
                String matchStatus = calculateValidationScores(mismatchCount);
                log.info("Inserting gender type data validation at {}:", outputTable);
                insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
                return extractedValue;
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while inserting gender type data validation origin Id " + originId + " paper No " + paperNo, handymanException, action);
                return null;
            }
        } else {
            try {
                String finalExtractedValue = getNormalizedExtractedValue(actualValue, extractedValue, lineItemType);
                mismatchCount = dataValidation(finalExtractedValue, actualValue, originId, paperNo, sorItemName, tenantId);
                String matchStatus = calculateValidationScores(mismatchCount);
                log.info("Inserting string type data validation at {}:", outputTable);
                insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
                return extractedValue;
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while inserting generic type data validation origin Id : " + originId + " paper No " + paperNo, handymanException, action);
                return null;
            }
        }
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, Long rootPipelineId, Long groupId,
                                     Long tenantId, String originId, String batchId, Long paperNo,
                                     String actualValue, String extractedValue, String matchStatus,
                                     Long mismatchCount, String fileName, String sorItemName,
                                     Long sorItemId, Long sorContainerId) {
        String classification = determineClassification(actualValue, extractedValue, matchStatus);
        jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable + " (" + "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " + "paper_no, actual_value, extracted_value, match_status, mismatch_count, " + "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id" + ") VALUES (" + ":rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, " + ":actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId, " + ":classification, :sorContainerId, :sorItemName, :sorItemId" + ");").bind("rootPipelineId", rootPipelineId).bind("createdOn", LocalDate.now()).bind("groupId", groupId).bind("fileName", fileName).bind("originId", originId).bind("batchId", batchId).bind("paperNo", paperNo).bind("actualValue", actualValue).bind("extractedValue", extractedValue).bind("matchStatus", matchStatus).bind("mismatchCount", mismatchCount).bind("tenantId", tenantId).bind("classification", classification).bind("sorContainerId", sorContainerId).bind("sorItemName", sorItemName).bind("sorItemId", sorItemId).execute());
    }

    public String getNormalizedExtractedValue(String actualValue, String extractedValue, String lineItemType) {
        if ("multi_value".equals(lineItemType) && actualValue != null && extractedValue != null) {

            List<String> orderedTokens = new ArrayList<>();
            Map<String, String> trimmedToOriginalMap = new LinkedHashMap<>();

            Matcher matcher = Pattern.compile("\\s*[^,]+").matcher(actualValue);
            while (matcher.find()) {
                String fullToken = matcher.group();       // e.g., " H0015TG"
                String trimmed = fullToken.trim();        // e.g., "H0015TG"
                if (!trimmedToOriginalMap.containsKey(trimmed)) {
                    trimmedToOriginalMap.put(trimmed, fullToken);
                    orderedTokens.add(trimmed);
                }
            }

            Set<String> extractedSet = Arrays.stream(extractedValue.split(","))
                    .map(String::trim)
                    .collect(Collectors.toSet());

            StringBuilder result = new StringBuilder();
            boolean first = true;
            for (String token : orderedTokens) {
                if (extractedSet.contains(token)) {
                    if (!first) result.append(",");
                    result.append(trimmedToOriginalMap.get(token));
                    first = false;
                }
            }

            return result.toString();
        }

        return extractedValue;
    }

    private String determineClassification(String actualValue, String extractedValue, String matchStatus) {
        String normalizedActual = actualValue == null ? "" : actualValue.trim();
        String normalizedExtracted = extractedValue == null ? "" : extractedValue.trim();

        boolean actualEmpty = normalizedActual.isEmpty();
        boolean extractedEmpty = normalizedExtracted.isEmpty();

        if ("NO TOUCH".equals(matchStatus) && actualEmpty && extractedEmpty) {
            return "TN";
        }

        if ("NO TOUCH".equals(matchStatus) && !actualEmpty && !extractedEmpty) {
            return "TP";
        }

        if (actualEmpty && !extractedEmpty) {
            return "FN";
        }

        if (!actualEmpty && (extractedEmpty || !"NO TOUCH".equals(matchStatus))) {
            return "FP";
        }

        return "UNKNOWN";
    }

    public String calculateValidationScores(Long mismatchCount) {
        String matchStatus;
        String lowTouch = action.getContext().get("control.data.low.touch.threshold");
        String oneTouch = action.getContext().get("control.data.one.touch.threshold");
        if (mismatchCount == 0) {
            matchStatus = "NO TOUCH";
        } else if (mismatchCount <= Long.parseLong(oneTouch)) {
            matchStatus = "ONE TOUCH";
        } else if (mismatchCount <= Long.parseLong(lowTouch)) {
            matchStatus = "LOW TOUCH";
        } else {
            matchStatus = "HIGH TOUCH";
        }
        return matchStatus;
    }

    public Long dataValidation(String extractedData, String actualData, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedData == null || extractedData.isEmpty()) {
            log.warn("Invalid input encountered for extractedData. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return actualData == null ? 0L : (long) actualData.length();
        }
        if (actualData == null || actualData.isEmpty()) {
            log.warn("Invalid input encountered for actualData. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedData.length();
        }

        String normalizedExtracted = extractedData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
        String normalizedActual = actualData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();


        int distance = LevenshteinDistance.getDefaultInstance().apply(normalizedExtracted, normalizedActual);
        int maxLength = Math.max(normalizedExtracted.length(), normalizedActual.length());

        double similarity = (maxLength == 0 ? 1.0 : (1.0 - (double) distance / maxLength)) * 100;


        if (distance == 0) {
            return 0L;
        }

        else if (similarity > Double.parseDouble(action.getContext().getOrDefault("controldata.comparision.similarity.score","70"))) {
            return 0L;
        }

        Set<String> extractedWords = new HashSet<>(Arrays.asList(extractedData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));
        Set<String> actualWords = new HashSet<>(Arrays.asList(actualData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));

        if (extractedWords.equals(actualWords)) {
            return 0L;
        }

        return (long) distance;
    }

    public Long dateValidation(String extractedDate, String actualDate, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedDate == null || extractedDate.isEmpty()) {
            log.warn("Invalid input encountered for extractedDate. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return actualDate == null ? 0L : (long) actualDate.length();
        }
        if (actualDate == null || actualDate.isEmpty()) {
            log.warn("Invalid input encountered for actualDate. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedDate.length();
        }

        String extractedLocalDate = null;

        try {
            if (extractedDate.matches("\\d{8}")) {
                extractedLocalDate = parseEightDigitDate(extractedDate, inputFormat, originId, paperNo, sorItemName, tenantId);
            }

            if (extractedLocalDate == null) {
                extractedLocalDate = parseDateWithFormat(extractedDate, inputFormat, originId, paperNo, sorItemName, tenantId);
            }
        } catch (DateTimeParseException e) {
            log.warn("Invalid extracted date format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) actualDate.length();
        }

        String actualLocalDate;
        try {
            actualLocalDate = parseDateWithFormat(actualDate, inputFormat, originId, paperNo, sorItemName, tenantId);
        } catch (DateTimeParseException e) {
            log.warn("Invalid actual date format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) actualDate.length();
        }

        return getMismatchCount(extractedLocalDate, actualLocalDate);
    }

    private String parseDateWithFormat(String date, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        String allowedFormats = action.getContext().get("date.input.formats");

        List<DateTimeFormatter> dateInputFormats = Optional.of(allowedFormats).map(s -> Arrays.stream(s.split(";")).map(DateTimeFormatter::ofPattern).collect(Collectors.toList())).orElse(Collections.emptyList());

        for (DateTimeFormatter inputFormatter : dateInputFormats) {
            try {
                LocalDate parsedDate = LocalDate.parse(date, inputFormatter);

                DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
                return parsedDate.format(outputFormatter);
            } catch (DateTimeParseException ignored) {
                log.warn("Error in parsing the date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            }
        }
        return date;
    }

    private String parseEightDigitDate(String date, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        String[] possibleFormats = {"yyyyMMdd", "MMddyyyy", "ddMMyyyy", "MMyyyydd"};

        for (String format : possibleFormats) {
            try {
                String reformattedDate = reformatEightDigitDate(date, format, originId, paperNo, sorItemName, tenantId);
                if (reformattedDate.isEmpty()) continue;

                DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
                LocalDate parsedDate = LocalDate.parse(reformattedDate, inputFormatter);

                DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
                return parsedDate.format(outputFormatter);
            } catch (DateTimeParseException | NullPointerException ignored) {
                log.warn("Error in parsing the Eight digit date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            }
        }
        return null;
    }

    private String reformatEightDigitDate(String date, String format, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (date.length() != 8) return "";
        try {
            switch (format) {
                case "yyyyMMdd":
                    return date.substring(0, 4) + "-" + date.substring(4, 6) + "-" + date.substring(6, 8);
                case "MMddyyyy":
                    return date.substring(4, 8) + "-" + date.substring(0, 2) + "-" + date.substring(2, 4);
                case "ddMMyyyy":
                    return date.substring(4, 8) + "-" + date.substring(2, 4) + "-" + date.substring(0, 2);
            }
        } catch (Exception ignored) {
            log.warn("Error in reformatting the Eight digit date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
        }
        return "";
    }

    public Long genderValidation(String extractedGender, String generatedGender, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedGender == null) {
            log.warn("Invalid input for extractedGender. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return generatedGender == null ? 0L : (long) generatedGender.length();
        }
        if (generatedGender == null) {
            log.warn("Invalid input for generatedGender. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedGender.length();
        }
        String formattedExtractedGender = normalizeGender(extractedGender);
        String formattedGeneratedGender = normalizeGender(generatedGender);

        if (formattedExtractedGender.equals("Invalid") || formattedGeneratedGender.equals("Invalid")) {
            return 1L;
        }

        return formattedExtractedGender.equalsIgnoreCase(formattedGeneratedGender) ? 0L
                : (long) formattedExtractedGender.length();
    }

    private String normalizeGender(String gender) {
        if (gender == null) return "Invalid";

        gender = gender.trim().toLowerCase();

        switch (gender) {
            case "m":
            case "male":
                return "Male";
            case "f":
            case "female":
                return "Female";
            default:
                return "Invalid";
        }
    }

    private Long getMismatchCount(String str1, String str2) {
        int mismatchCount = 0;
        int length = Math.max(str1.length(), str2.length());

        for (int i = 0; i < length; i++) {
            char c1 = (i < str1.length()) ? str1.charAt(i) : '\0';
            char c2 = (i < str2.length()) ? str2.charAt(i) : '\0';

            if (c1 != c2) {
                mismatchCount++;
            }
        }

        return (long) mismatchCount;
    }

    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}