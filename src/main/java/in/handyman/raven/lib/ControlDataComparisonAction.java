package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(controlDataComparison.getQuerySet());
                AtomicInteger i = new AtomicInteger(0);
                formattedQuery.forEach(sqlToExecute -> {
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                    Query query = handle.createQuery(sqlToExecute);
                    List<ControlDataComparisonQueryInputTable> results = query
                            .mapToBean(ControlDataComparisonQueryInputTable.class)
                            .list();
                    controlDataComparisonQueryInputTables.addAll(results);
                    log.info(aMarker, "Executed query from index {}", i.get());
                });
            });

            log.info(aMarker, "Total rows returned from the query: {}", controlDataComparisonQueryInputTables.size());

            String kafkaComparison = action.getContext().getOrDefault("kafka.production.activator", "false");
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            Map<String, String> decryptedActualMap = new HashMap<>();
            Map<String, String> decryptedExtractedMap = new HashMap<>();

            Map<String, List<ControlDataComparisonQueryInputTable>> groupedByOrigin = controlDataComparisonQueryInputTables.stream()
                    .filter(r -> "t".equalsIgnoreCase(r.getIsEncrypted()))
                    .collect(Collectors.groupingBy(ControlDataComparisonQueryInputTable::getOriginId));

            for (Map.Entry<String, List<ControlDataComparisonQueryInputTable>> entry : groupedByOrigin.entrySet()) {
                String originId = entry.getKey();
                List<ControlDataComparisonQueryInputTable> encryptedItems = entry.getValue();

                List<EncryptionRequestClass> actualValueFields = encryptedItems.stream()
                        .filter(r -> r.getActualValue() != null && !r.getActualValue().trim().isEmpty())
                        .map(r -> new EncryptionRequestClass(r.getEncryptionPolicy(), r.getActualValue(), r.getSorItemName()))
                        .collect(Collectors.toList());

                List<EncryptionRequestClass> extractedValueFields = encryptedItems.stream()
                        .filter(r -> r.getExtractedValue() != null && !r.getExtractedValue().trim().isEmpty())
                        .map(r -> new EncryptionRequestClass(r.getEncryptionPolicy(), r.getExtractedValue(), r.getSorItemName()))
                        .collect(Collectors.toList());

                if (!actualValueFields.isEmpty()) {
                    try {
                        log.info("Decrypting ACTUAL values for originId: {}", originId);
                        List<EncryptionRequestClass> decryptedActuals = encryption.decrypt(actualValueFields);
                        decryptedActuals.forEach(decrypted -> {
                            String key = originId + "|" + decrypted.getKey();
                            decryptedActualMap.put(key, decrypted.getValue());
                        });
                        log.info("Actual value decryption successful for originId: {}", originId);
                    } catch (Exception e) {
                        log.error("Actual value decryption failed for originId: {}", originId, e);
                    }
                }

                if (!extractedValueFields.isEmpty()) {
                    try {
                        log.info("Decrypting EXTRACTED values for originId: {}", originId);
                        List<EncryptionRequestClass> decryptedExtracted = encryption.decrypt(extractedValueFields);
                        decryptedExtracted.forEach(decrypted -> {
                            String key = originId + "|" + decrypted.getKey();
                            decryptedExtractedMap.put(key, decrypted.getValue());
                        });
                        log.info("Extracted value decryption successful for originId: {}", originId);
                    } catch (Exception e) {
                        log.error("Extracted value decryption failed for originId: {}", originId, e);
                    }
                }
            }

            invokeValidationPerRecord(controlDataComparisonQueryInputTables, decryptedActualMap,
                    decryptedExtractedMap, jdbi, outputTable, kafkaComparison, encryption);

            log.info(aMarker, "Control Data Comparison Action has been completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");

        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    public void invokeValidationPerRecord(List<ControlDataComparisonQueryInputTable> originalRecords,
                                          Map<String, String> decryptedActualMap,
                                          Map<String, String> decryptedExtractedMap,
                                          Jdbi jdbi,
                                          String outputTable,
                                          String kafkaComparison,
                                          InticsIntegrity encryption) throws JsonProcessingException {
        List<EncryptionRequestClass> encryptionRequests = new ArrayList<>();
        Map<String, ControlDataComparisonQueryInputTable> recordMap = new HashMap<>();

        for (ControlDataComparisonQueryInputTable record : originalRecords) {
            String originId = record.getOriginId();
            String sorItemName = record.getSorItemName();
            String key = originId + "|" + sorItemName;

            if (decryptedActualMap.containsKey(key)) {
                record.setActualValue(decryptedActualMap.get(key));
            }

            if (decryptedExtractedMap.containsKey(key)) {
                record.setExtractedValue(decryptedExtractedMap.get(key));
            }

            String extractedValue = record.getExtractedValue();
            String actualValue = record.getActualValue();

            // Perform validation with decrypted values
            doControlDataValidation(record, jdbi, outputTable, kafkaComparison, encryption, encryptionRequests, recordMap);

            // Prepare for re-encryption if item-wise encryption is enabled and record is marked as encrypted
            if ("true".equalsIgnoreCase(action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false")) && "t".equalsIgnoreCase(record.getIsEncrypted())) {
                if (actualValue != null && !actualValue.trim().isEmpty()) {
                    encryptionRequests.add(new EncryptionRequestClass(record.getEncryptionPolicy(), actualValue, sorItemName + "|actual"));
                    recordMap.put(sorItemName + "|actual", record);
                }
                if (extractedValue != null && !extractedValue.trim().isEmpty()) {
                    encryptionRequests.add(new EncryptionRequestClass(record.getEncryptionPolicy(), extractedValue, sorItemName + "|extracted"));
                    recordMap.put(sorItemName + "|extracted", record);
                }
            }
        }

        // Perform batch encryption
        if (!encryptionRequests.isEmpty()) {
            try {
                log.info("Starting batch encryption for {} items", encryptionRequests.size());
                List<EncryptionRequestClass> encryptedResults = encryption.encrypt(encryptionRequests);
                encryptedResults.forEach(result -> {
                    String[] keyParts = result.getKey().split("\\|");
                    String sorItemName = keyParts[0];
                    String valueType = keyParts[1]; // "extracted" or "actual"
                    ControlDataComparisonQueryInputTable record = recordMap.get(result.getKey());
                    if (record != null) {
                        String originId = record.getOriginId();
                        String paperNo = String.valueOf(record.getPaperNo());
                        log.info("Encryption completed for sorItem: {}, type: {}", sorItemName, valueType);
                        // Update the database with encrypted values
                        String column = "actual".equals(valueType) ? "actual_value" : "extracted_value";
                        jdbi.useHandle(handle -> handle.createUpdate("UPDATE " + outputTable + " SET " + column + " = :value " +
                                        "WHERE origin_id = :originId AND sor_item_name = :sorItemName AND paper_no = :paperNo")
                                .bind("value", result.getValue())
                                .bind("originId", originId)
                                .bind("sorItemName", sorItemName)
                                .bind("paperNo", paperNo)
                                .execute());
                    }
                });
                log.info("Batch encryption successful for {} items", encryptedResults.size());
            } catch (Exception e) {
                log.error("Batch encryption failed", e);
            }
        }
    }

    private String doControlDataValidation(ControlDataComparisonQueryInputTable controlDataComparisonQueryInputTable, Jdbi jdbi, String outputTable, String kafkaComparison, InticsIntegrity encryption, List<EncryptionRequestClass> encryptionRequests, Map<String, ControlDataComparisonQueryInputTable> recordMap) throws JsonProcessingException {
        log.info("Processing the Control Data Comparison input data ControlDataComparisonQueryInputTable for origin id: {} and paper no: {} and sor item name: {}", controlDataComparisonQueryInputTable.getOriginId(), controlDataComparisonQueryInputTable.getPaperNo(), controlDataComparisonQueryInputTable.getSorItemName());

        Long tenantId = controlDataComparisonQueryInputTable.getTenantId();
        String originId = controlDataComparisonQueryInputTable.getOriginId();
        Long groupId = controlDataComparisonQueryInputTable.getGroupId();
        Long paperNo = controlDataComparisonQueryInputTable.getPaperNo();
        String batchId = controlDataComparisonQueryInputTable.getBatchId();
        Long rootPipelineId = controlDataComparisonQueryInputTable.getRootPipelineId();
        String extractedValue = controlDataComparisonQueryInputTable.getExtractedValue();
        String actualValue = controlDataComparisonQueryInputTable.getActualValue();
        String allowedAdapters = controlDataComparisonQueryInputTable.getAllowedAdapter();
        String fileName = controlDataComparisonQueryInputTable.getFileName();
        String sorItemName = controlDataComparisonQueryInputTable.getSorItemName();
        String encryptionPolicy = controlDataComparisonQueryInputTable.getEncryptionPolicy();
        String isEncrypted = controlDataComparisonQueryInputTable.getIsEncrypted();
        Long sorItemId = controlDataComparisonQueryInputTable.getSorItemId();
        Long sorContainerId = controlDataComparisonQueryInputTable.getSorContainerId();
        String lineItemType = controlDataComparisonQueryInputTable.getLineItemType();

        Long mismatchCount;
        if (allowedAdapters.equals("date") || allowedAdapters.equals("date_reg")) {
            try {
                String finalDateFormat = action.getContext().get("control.data.date.comparison.format");
                mismatchCount = dateValidation(extractedValue, actualValue, finalDateFormat, originId, paperNo, sorItemName, tenantId);
                String matchStatus = calculateValidationScores(mismatchCount);
                log.info("Inserting date type data validation at {}:", outputTable);
                insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
                return extractedValue;
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while inserting date type data validation origin Id" + originId + " paper No " + paperNo, handymanException, action);
                return null;
            }
        } else if (allowedAdapters.equals("gender")) {
            try {
                mismatchCount = genderValidation(extractedValue, actualValue, originId, paperNo, sorItemName, tenantId);
                String matchStatus = calculateValidationScores(mismatchCount);
                log.info("Inserting gender type data validation at {}:", outputTable);
                insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
                return extractedValue;
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while inserting gender type data validation origin Id " + originId + " paper No " + paperNo, handymanException, action);
                return null;
            }
        } else {
            try {
                String finalExtractedValue = getNormalizedExtractedValue(actualValue, extractedValue, lineItemType);
                mismatchCount = dataValidation(finalExtractedValue, actualValue, originId, paperNo, sorItemName, tenantId);
                String matchStatus = calculateValidationScores(mismatchCount);
                log.info("Inserting string type data validation at {}:", outputTable);
                insertExecutionInfo(jdbi, outputTable, rootPipelineId, groupId, tenantId, originId, batchId, paperNo, actualValue, extractedValue, matchStatus, mismatchCount, fileName, sorItemName, sorItemId, sorContainerId);
                return extractedValue;
            } catch (HandymanException e) {
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error while inserting generic type data validation origin Id : " + originId + " paper No " + paperNo, handymanException, action);
                return null;
            }
        }
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, Long rootPipelineId, Long groupId,
                                     Long tenantId, String originId, String batchId, Long paperNo,
                                     String actualValue, String extractedValue, String matchStatus,
                                     Long mismatchCount, String fileName, String sorItemName,
                                     Long sorItemId, Long sorContainerId) {
        String classification = determineClassification(actualValue, extractedValue, matchStatus);
        jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable + " (" + "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " + "paper_no, actual_value, extracted_value, match_status, mismatch_count, " + "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id" + ") VALUES (" + ":rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, " + ":actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId, " + ":classification, :sorContainerId, :sorItemName, :sorItemId" + ");").bind("rootPipelineId", rootPipelineId).bind("createdOn", LocalDate.now()).bind("groupId", groupId).bind("fileName", fileName).bind("originId", originId).bind("batchId", batchId).bind("paperNo", paperNo).bind("actualValue", actualValue).bind("extractedValue", extractedValue).bind("matchStatus", matchStatus).bind("mismatchCount", mismatchCount).bind("tenantId", tenantId).bind("classification", classification).bind("sorContainerId", sorContainerId).bind("sorItemName", sorItemName).bind("sorItemId", sorItemId).execute());
    }

    public String getNormalizedExtractedValue(String actualValue, String extractedValue, String lineItemType) {
        if ("multi_value".equals(lineItemType) && actualValue != null && extractedValue != null) {

            // Step 1: Extract and map original tokens from actualValue (preserving formatting)
            List<String> orderedTokens = new ArrayList<>();
            Map<String, String> trimmedToOriginalMap = new LinkedHashMap<>();

            Matcher matcher = Pattern.compile("\\s*[^,]+").matcher(actualValue);
            while (matcher.find()) {
                String fullToken = matcher.group();       // e.g., " H0015TG"
                String trimmed = fullToken.trim();        // e.g., "H0015TG"
                if (!trimmedToOriginalMap.containsKey(trimmed)) {
                    trimmedToOriginalMap.put(trimmed, fullToken);
                    orderedTokens.add(trimmed);
                }
            }

            // Step 2: Convert extractedValue to Set of trimmed strings
            Set<String> extractedSet = Arrays.stream(extractedValue.split(","))
                    .map(String::trim)
                    .collect(Collectors.toSet());

            // Step 3: Reconstruct result preserving order and formatting from actualValue
            StringBuilder result = new StringBuilder();
            boolean first = true;
            for (String token : orderedTokens) {
                if (extractedSet.contains(token)) {
                    if (!first) result.append(",");
                    result.append(trimmedToOriginalMap.get(token));
                    first = false;
                }
            }

            return result.toString();
        }

        return extractedValue;
    }


    private String determineClassification(String actualValue, String extractedValue, String matchStatus) {
        String normalizedActual = actualValue == null ? "" : actualValue.trim();
        String normalizedExtracted = extractedValue == null ? "" : extractedValue.trim();

        boolean actualEmpty = normalizedActual.isEmpty();
        boolean extractedEmpty = normalizedExtracted.isEmpty();

        if ("NO TOUCH".equals(matchStatus) && actualEmpty && extractedEmpty) {
            return "TN";
        }

        if ("NO TOUCH".equals(matchStatus) && !actualEmpty && !extractedEmpty) {
            return "TP";
        }

        if (actualEmpty && !extractedEmpty) {
            return "FN";
        }

        if (!actualEmpty && (extractedEmpty || !"NO TOUCH".equals(matchStatus))) {
            return "FP";
        }

        return "UNKNOWN";
    }

    public String calculateValidationScores(Long mismatchCount) {
        String matchStatus;
        String lowTouch = action.getContext().get("control.data.low.touch.threshold");
        String oneTouch = action.getContext().get("control.data.one.touch.threshold");
        if (mismatchCount == 0) {
            matchStatus = "NO TOUCH";
        } else if (mismatchCount <= Long.parseLong(oneTouch)) {
            matchStatus = "ONE TOUCH";
        } else if (mismatchCount <= Long.parseLong(lowTouch)) {
            matchStatus = "LOW TOUCH";
        } else {
            matchStatus = "HIGH TOUCH";
        }
        return matchStatus;
    }

    public Long dataValidation(String extractedData, String actualData, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedData == null || extractedData.isEmpty()) {
            log.warn("Invalid input encountered for extractedData. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return actualData == null ? 0L : (long) actualData.length();
        }
        if (actualData == null || actualData.isEmpty()) {
            log.warn("Invalid input encountered for actualData. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedData.length();
        }

        String normalizedExtracted = extractedData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
        String normalizedActual = actualData.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();

        int distance = LevenshteinDistance.getDefaultInstance().apply(normalizedExtracted, normalizedActual);

        if (distance == 0) {
            return 0L;
        }

        if (normalizedExtracted.contains(normalizedActual)) {
            return 0L;
        }

        Set<String> extractedWords = new HashSet<>(Arrays.asList(extractedData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));
        Set<String> actualWords = new HashSet<>(Arrays.asList(actualData.replaceAll("[^a-zA-Z0-9 ]", "").toLowerCase().split("\\s+")));

        if (extractedWords.equals(actualWords)) {
            return 0L;
        }

        return (long) distance;
    }

    public Long dateValidation(String extractedDate, String actualDate, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedDate == null || extractedDate.isEmpty()) {
            log.warn("Invalid input encountered for extractedDate. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return actualDate == null ? 0L : (long) actualDate.length();
        }
        if (actualDate == null || actualDate.isEmpty()) {
            log.warn("Invalid input encountered for actualDate. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedDate.length();
        }

        String extractedLocalDate = null;

        try {
            if (extractedDate.matches("\\d{8}")) {
                extractedLocalDate = parseEightDigitDate(extractedDate, inputFormat, originId, paperNo, sorItemName, tenantId);
            }

            if (extractedLocalDate == null) {
                extractedLocalDate = parseDateWithFormat(extractedDate, inputFormat, originId, paperNo, sorItemName, tenantId);
            }
        } catch (DateTimeParseException e) {
            log.warn("Invalid extracted date format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) actualDate.length();
        }

        String actualLocalDate;
        try {
            actualLocalDate = parseDateWithFormat(actualDate, inputFormat, originId, paperNo, sorItemName, tenantId);
        } catch (DateTimeParseException e) {
            log.warn("Invalid actual date format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) actualDate.length();
        }

        return getMismatchCount(extractedLocalDate, actualLocalDate);
    }

    private String parseDateWithFormat(String date, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        String allowedFormats = action.getContext().get("date.input.formats");

        List<DateTimeFormatter> dateInputFormats = Optional.of(allowedFormats).map(s -> Arrays.stream(s.split(";")).map(DateTimeFormatter::ofPattern).collect(Collectors.toList())).orElse(Collections.emptyList());

        for (DateTimeFormatter inputFormatter : dateInputFormats) {
            try {
                LocalDate parsedDate = LocalDate.parse(date, inputFormatter);

                DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
                return parsedDate.format(outputFormatter);
            } catch (DateTimeParseException ignored) {
                log.warn("Error in parsing the date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            }
        }
        return date;
    }

    private String parseEightDigitDate(String date, String inputFormat, String originId, Long paperNo, String sorItemName, Long tenantId) {
        String[] possibleFormats = {"yyyyMMdd", "MMddyyyy", "ddMMyyyy", "MMyyyydd"};

        for (String format : possibleFormats) {
            try {
                String reformattedDate = reformatEightDigitDate(date, format, originId, paperNo, sorItemName, tenantId);
                if (reformattedDate.isEmpty()) continue;

                DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
                LocalDate parsedDate = LocalDate.parse(reformattedDate, inputFormatter);

                DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(inputFormat);
                return parsedDate.format(outputFormatter);
            } catch (DateTimeParseException | NullPointerException ignored) {
                log.warn("Error in parsing the Eight digit date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            }
        }
        return null;
    }

    private String reformatEightDigitDate(String date, String format, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (date.length() != 8) return "";
        try {
            switch (format) {
                case "yyyyMMdd":
                    return date.substring(0, 4) + "-" + date.substring(4, 6) + "-" + date.substring(6, 8);
                case "MMddyyyy":
                    return date.substring(4, 8) + "-" + date.substring(0, 2) + "-" + date.substring(2, 4);
                case "ddMMyyyy":
                    return date.substring(4, 8) + "-" + date.substring(2, 4) + "-" + date.substring(0, 2);
            }
        } catch (Exception ignored) {
            log.warn("Error in reformatting the Eight digit date format from given input format to specified output format. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
        }
        return "";
    }

    public Long genderValidation(String extractedGender, String generatedGender, String originId, Long paperNo, String sorItemName, Long tenantId) {
        if (extractedGender == null) {
            log.warn("Invalid input for extractedGender. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return generatedGender == null ? 0L : (long) generatedGender.length();
        }
        if (generatedGender == null) {
            log.warn("Invalid input for generatedGender. Details - Origin ID: {}, Sor Item Name: {}, Paper No: {}, Tenant ID: {}", originId, sorItemName, paperNo, tenantId);
            return (long) extractedGender.length();
        }
        String formattedExtractedGender = normalizeGender(extractedGender);
        String formattedGeneratedGender = normalizeGender(generatedGender);

        if (formattedExtractedGender.equals("Invalid") || formattedGeneratedGender.equals("Invalid")) {
            return 1L;
        }

        return formattedExtractedGender.equalsIgnoreCase(formattedGeneratedGender) ? 0L  // No mismatch
                : (long) formattedExtractedGender.length();
    }

    private String normalizeGender(String gender) {
        if (gender == null) return "Invalid";

        gender = gender.trim().toLowerCase();

        switch (gender) {
            case "m":
            case "male":
                return "Male";
            case "f":
            case "female":
                return "Female";
            default:
                return "Invalid";
        }
    }

    private Long getMismatchCount(String str1, String str2) {
        int mismatchCount = 0;
        int length = Math.max(str1.length(), str2.length());

        for (int i = 0; i < length; i++) {
            char c1 = (i < str1.length()) ? str1.charAt(i) : '\0';
            char c2 = (i < str2.length()) ? str2.charAt(i) : '\0';

            if (c1 != c2) {
                mismatchCount++;
            }
        }

        return (long) mismatchCount;
    }

    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}