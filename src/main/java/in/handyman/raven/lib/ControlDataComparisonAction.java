package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapter;
import in.handyman.raven.lib.adapters.comparison.ComparisonAdapterFactory;
import in.handyman.raven.lib.model.ControlDataComparison;
import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "ControlDataComparison")
public class ControlDataComparisonAction implements IActionExecution {
    private final ActionExecutionAudit action;
    private final ControlDataComparison controlDataComparison;
    private final Logger log;
    private final Marker aMarker;
    ActionExecutionAudit actionExecutionAudit = new ActionExecutionAudit();

    public ControlDataComparisonAction(final ActionExecutionAudit action, final Logger log, final Object controlDataComparison) {
        this.controlDataComparison = (ControlDataComparison) controlDataComparison;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("ControlDataComparison:" + this.controlDataComparison.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            action.getContext().put("DEFAULT_ENCRYPTION_ALGORITHM", "PROTEGRITY_API_ENC");
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(controlDataComparison.getResourceConn());
            log.info(aMarker, "Control Data Comparison Action for {} has been started", controlDataComparison.getName());

            String outputTable = controlDataComparison.getOutputTable();
            String querySet = controlDataComparison.getQuerySet();
            final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables =
                    getControlDataComparisonQueryInputTables(jdbi, querySet);

            log.info(aMarker, "Total rows returned from the query: {}", controlDataComparisonQueryInputTables.size());

            String kafkaComparison = action.getContext().getOrDefault("kafka.production.activator", "false");
            InticsIntegrity encryptionHandler = SecurityEngine.getInticsIntegrityMethod(action, log);

            Map<String, String> decryptedActualMap = new HashMap<>();
            Map<String, String> decryptedExtractedMap = new HashMap<>();
            performDecryption(controlDataComparisonQueryInputTables, decryptedActualMap, decryptedExtractedMap, encryptionHandler);

            invokeValidationPerRecord(
                    controlDataComparisonQueryInputTables,
                    decryptedActualMap,
                    decryptedExtractedMap,
                    jdbi,
                    outputTable,
                    kafkaComparison,
                    encryptionHandler
            );

            log.info(aMarker, "Control Data Comparison Action has been completed: {}", controlDataComparison.getName());
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "true");

        } catch (Exception e) {
            action.getContext().put(controlDataComparison.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for Control Data Comparison", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Control data comparison failed", handymanException, action);
            throw handymanException;
        }
    }

    private void performDecryption(
            List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables,
            Map<String, String> decryptedActualMap,
            Map<String, String> decryptedExtractedMap,
            InticsIntegrity encryptionHandler
    ) {
        boolean itemWiseEncryption = "true".equalsIgnoreCase(
                action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false")
        );
        boolean actualEncryption = "true".equalsIgnoreCase(
                action.getContext().getOrDefault("actual.encryption.variable", "false")
        );

        if (!itemWiseEncryption) {
            log.info(aMarker, "Skipping decryption as itemWiseEncryption is false");
            return;
        }

        Map<String, List<ControlDataComparisonQueryInputTable>> groupedByOrigin =
                controlDataComparisonQueryInputTables.stream()
                        .filter(r -> "t".equalsIgnoreCase(r.getIsEncrypted()))
                        .collect(Collectors.groupingBy(ControlDataComparisonQueryInputTable::getOriginId));

        for (Map.Entry<String, List<ControlDataComparisonQueryInputTable>> entry : groupedByOrigin.entrySet()) {
            String originId = entry.getKey();
            List<ControlDataComparisonQueryInputTable> encryptedItems = entry.getValue();

            // ðŸ”¹ Decrypt Actual Values
            if (actualEncryption) {
                List<EncryptionRequestClass> actualValueFields = encryptedItems.stream()
                        .filter(r -> r.getActualValue() != null && !r.getActualValue().trim().isEmpty())
                        .map(r -> new EncryptionRequestClass(r.getEncryptionPolicy(), r.getActualValue(), String.valueOf(r.getId())))
                        .collect(Collectors.toList());

                if (!actualValueFields.isEmpty()) {
                    try {
                        log.info(aMarker, "Calling Protegrity API to decrypt ACTUAL values for originId: {}", originId);
                        List<EncryptionRequestClass> decryptedActuals = encryptionHandler.decrypt(actualValueFields);
                        decryptedActuals.forEach(decrypted -> {
                            String key = originId + "|" + decrypted.getKey();
                            decryptedActualMap.put(key, decrypted.getValue());
                        });
                        log.info(aMarker, "Actual value decryption successful for originId: {}", originId);
                    } catch (Exception e) {
                        log.error(aMarker, "Actual value decryption failed for originId: {}", originId, e);
                    }
                }
            }

            // ðŸ”¹ Decrypt Extracted Values
            List<EncryptionRequestClass> extractedValueFields = encryptedItems.stream()
                    .filter(r -> r.getExtractedValue() != null && !r.getExtractedValue().trim().isEmpty())
                    .map(r -> new EncryptionRequestClass(r.getEncryptionPolicy(), r.getExtractedValue(), String.valueOf(r.getId())))
                    .collect(Collectors.toList());

            if (!extractedValueFields.isEmpty()) {
                try {
                    log.info(aMarker, "Calling Protegrity API to decrypt EXTRACTED values for originId: {}", originId);
                    List<EncryptionRequestClass> decryptedExtracted = encryptionHandler.decrypt(extractedValueFields);
                    decryptedExtracted.forEach(decrypted -> {
                        String key = originId + "|" + decrypted.getKey();
                        decryptedExtractedMap.put(key, decrypted.getValue());
                    });
                    log.info(aMarker, "Extracted value decryption successful for originId: {}", originId);
                } catch (Exception e) {
                    log.error(aMarker, "Extracted value decryption failed for originId: {}", originId, e);
                }
            }
        }
    }

    @NotNull
    public List<ControlDataComparisonQueryInputTable> getControlDataComparisonQueryInputTables(Jdbi jdbi,String querySet) {
        final List<ControlDataComparisonQueryInputTable> controlDataComparisonQueryInputTables = new ArrayList<>();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                List<ControlDataComparisonQueryInputTable> results = query
                        .mapToBean(ControlDataComparisonQueryInputTable.class)
                        .list();
                controlDataComparisonQueryInputTables.addAll(results);
                log.info(aMarker, "Executed query from index {}", i.get());
            });
        });
        return controlDataComparisonQueryInputTables;
    }

    public void invokeValidationPerRecord(List<ControlDataComparisonQueryInputTable> originalRecords,
                                          Map<String, String> decryptedActualMap,
                                          Map<String, String> decryptedExtractedMap,
                                          Jdbi jdbi,
                                          String outputTable,
                                          String kafkaComparison,
                                          InticsIntegrity inticsIntegrity) throws JsonProcessingException {

        List<EncryptionRequestClass> encryptionRequests = new ArrayList<>();
        Map<String, ControlDataComparisonQueryInputTable> recordMap = new HashMap<>();
        boolean itemWiseEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault(ENCRYPT_ITEM_WISE_ENCRYPTION, "false"));
        boolean actualEncryption = "true".equalsIgnoreCase(action.getContext().getOrDefault("actual.encryption.variable", "false"));

        for (ControlDataComparisonQueryInputTable record : originalRecords) {
            String originId = record.getOriginId();
            String uniqueKey = String.valueOf(record.getId()); // use id as unique identifier
            String mapKey = originId + "|" + uniqueKey;

            // Apply decrypted values if available
            if (decryptedActualMap.containsKey(mapKey)) {
                record.setActualValue(decryptedActualMap.get(mapKey));
            }
            if (decryptedExtractedMap.containsKey(mapKey)) {
                record.setExtractedValue(decryptedExtractedMap.get(mapKey));
            }

            String extractedValue = record.getExtractedValue();
            String actualValue = record.getActualValue();
            String isEncrypted = record.getIsEncrypted();

            // Perform validation with decrypted values
            doControlDataValidationByAdapters(record, jdbi, outputTable);

            // Prepare for re-encryption based on conditions
            if (itemWiseEncryption && "t".equalsIgnoreCase(isEncrypted)) {
                if (actualEncryption) {
                    // Re-encrypt both actual and extracted values
                    if (actualValue != null && !actualValue.trim().isEmpty()) {
                        encryptionRequests.add(new EncryptionRequestClass(record.getEncryptionPolicy(), actualValue, uniqueKey + "|actual"));
                        recordMap.put(uniqueKey + "|actual", record);
                        log.info(aMarker, "Preparing re-encryption for actualValue for id: {}, originId: {}", record.getId(), originId);
                    } else {
                        log.info(aMarker, "Skipping re-encryption for actualValue (null or empty) for id: {}, originId: {}", record.getId(), originId);
                    }
                    if (extractedValue != null && !extractedValue.trim().isEmpty()) {
                        encryptionRequests.add(new EncryptionRequestClass(record.getEncryptionPolicy(), extractedValue, uniqueKey + "|extracted"));
                        recordMap.put(uniqueKey + "|extracted", record);
                        log.info(aMarker, "Preparing re-encryption for extractedValue for id: {}, originId: {}", record.getId(), originId);
                    } else {
                        log.info(aMarker, "Skipping re-encryption for extractedValue (null or empty) for id: {}, originId: {}", record.getId(), originId);
                    }
                } else {
                    // Re-encrypt only extracted values
                    if (extractedValue != null && !extractedValue.trim().isEmpty()) {
                        encryptionRequests.add(new EncryptionRequestClass(record.getEncryptionPolicy(), extractedValue, uniqueKey + "|extracted"));
                        recordMap.put(uniqueKey + "|extracted", record);
                        log.info(aMarker, "Preparing re-encryption for extractedValue for id: {}, originId: {}", record.getId(), originId);
                    } else {
                        log.info(aMarker, "Skipping re-encryption for extractedValue (null or empty) for id: {}, originId: {}", record.getId(), originId);
                    }
                }
            }
        }

        // Perform batch encryption/re-encryption
        if (!encryptionRequests.isEmpty()) {
            try {
                log.info(aMarker, "Starting batch encryption/re-encryption for {} items", encryptionRequests.size());
                List<EncryptionRequestClass> encryptedResults = inticsIntegrity.encrypt(encryptionRequests); // âœ… use InticsIntegrity wrapper
                encryptedResults.forEach(result -> {
                    String[] keyParts = result.getKey().split("\\|");
                    String id = keyParts[0];
                    String valueType = keyParts[1]; // "extracted" or "actual"
                    ControlDataComparisonQueryInputTable record = recordMap.get(result.getKey());
                    if (record != null) {
                        String originId = record.getOriginId();
                        String paperNo = String.valueOf(record.getPaperNo());
                        log.info(aMarker, "Re-encryption completed for id: {}, type: {}, originId: {}",
                                id, valueType, originId);
                        // Update the database with re-encrypted values
                        String column = "actual".equals(valueType) ? "actual_value" : "extracted_value";
                        jdbi.useHandle(handle -> handle.createUpdate("UPDATE " + outputTable + " SET " + column + " = :value " +
                                        "WHERE origin_id = :originId AND id = :id AND paper_no = :paperNo")
                                .bind("value", result.getValue())
                                .bind("originId", originId)
                                .bind("id", id)
                                .bind("paperNo", paperNo)
                                .execute());
                    }
                });
                log.info(aMarker, "Batch encryption/re-encryption successful for {} items", encryptedResults.size());
            } catch (Exception e) {
                log.error(aMarker, "Batch encryption/re-encryption failed", e);
            }
        }
    }

    private String doControlDataValidationByAdapters(
            ControlDataComparisonQueryInputTable comparisonInputLineItem,
            Jdbi jdbi,
            String outputTable) {
        String lowTouch = action.getContext().get("control.data.low.touch.threshold");
        String oneTouch = action.getContext().get("control.data.one.touch.threshold");

        String adapterKey = comparisonInputLineItem.getAllowedAdapter() != null ? comparisonInputLineItem.getAllowedAdapter() : "string";
        ComparisonAdapter adapter = ComparisonAdapterFactory.getAdapter(adapterKey);

        Long mismatchCount = adapter.validate(comparisonInputLineItem, action, log);

        String matchStatus = calculateValidationScores(mismatchCount,oneTouch,lowTouch);

        log.info("Inserting {} type data validation at {}:", adapterKey, outputTable);
        insertExecutionInfo(
                jdbi,
                outputTable,
                matchStatus,
                mismatchCount,
                comparisonInputLineItem
        );
        return comparisonInputLineItem.getExtractedValue();
    }

//    private String doControlDataValidation(ControlDataComparisonQueryInputTable controlDataComparisonQueryInputTable, Jdbi jdbi, String outputTable, String kafkaComparison, InticsIntegrity encryption, List<EncryptionRequestClass> encryptionRequests, Map<String, ControlDataComparisonQueryInputTable> recordMap) throws JsonProcessingException {
//        log.info("Processing the Control Data Comparison input data ControlDataComparisonQueryInputTable for origin id: {} and paper no: {} and sor item name: {}", controlDataComparisonQueryInputTable.getOriginId(), controlDataComparisonQueryInputTable.getPaperNo(), controlDataComparisonQueryInputTable.getSorItemName());
//
//        Long tenantId = controlDataComparisonQueryInputTable.getTenantId();
//        String originId = controlDataComparisonQueryInputTable.getOriginId();
//        Long paperNo = controlDataComparisonQueryInputTable.getPaperNo();
//        String extractedValue = controlDataComparisonQueryInputTable.getExtractedValue();
//        String actualValue = controlDataComparisonQueryInputTable.getActualValue();
//        String allowedAdapters = controlDataComparisonQueryInputTable.getAllowedAdapter();
//        String sorItemName = controlDataComparisonQueryInputTable.getSorItemName();
//        String lineItemType = controlDataComparisonQueryInputTable.getLineItemType();
//
//        Long mismatchCount;
//        if (allowedAdapters.equals("date") || allowedAdapters.equals("date_reg")) {
//            try {
//                String finalDateFormat = action.getContext().get("control.data.date.comparison.format");
//                mismatchCount = dateValidation(extractedValue, actualValue, finalDateFormat, originId, paperNo, sorItemName, tenantId);
//                String matchStatus = calculateValidationScores(mismatchCount);
//                log.info("Inserting date type data validation at {}:", outputTable);
//                insertExecutionInfo(jdbi, outputTable, matchStatus, mismatchCount, controlDataComparisonQueryInputTable);
//                return extractedValue;
//            } catch (HandymanException e) {
//                HandymanException handymanException = new HandymanException(e);
//                HandymanException.insertException("Error while inserting date type data validation origin Id" + originId + " paper No " + paperNo, handymanException, action);
//                return null;
//            }
//        } else if (allowedAdapters.equals("gender")) {
//            try {
//                mismatchCount = genderValidation(extractedValue, actualValue, originId, paperNo, sorItemName, tenantId);
//                String matchStatus = calculateValidationScores(mismatchCount);
//                log.info("Inserting gender type data validation at {}:", outputTable);
//                insertExecutionInfo(jdbi, outputTable, matchStatus, mismatchCount, controlDataComparisonQueryInputTable);
//                return extractedValue;
//            } catch (HandymanException e) {
//                HandymanException handymanException = new HandymanException(e);
//                HandymanException.insertException("Error while inserting gender type data validation origin Id " + originId + " paper No " + paperNo, handymanException, action);
//                return null;
//            }
//        } else {
//            try {
//                String finalExtractedValue = getNormalizedExtractedValue(actualValue, extractedValue, lineItemType);
//                mismatchCount = dataValidation(finalExtractedValue, actualValue, originId, paperNo, sorItemName, tenantId);
//                String matchStatus = calculateValidationScores(mismatchCount);
//                log.info("Inserting string type data validation at {}:", outputTable);
//                insertExecutionInfo(jdbi, outputTable, matchStatus, mismatchCount, controlDataComparisonQueryInputTable);
//                return extractedValue;
//            } catch (HandymanException e) {
//                HandymanException handymanException = new HandymanException(e);
//                HandymanException.insertException("Error while inserting generic type data validation origin Id : " + originId + " paper No " + paperNo, handymanException, action);
//                return null;
//            }
//        }
//    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, String matchStatus,
                                     Long mismatchCount,ControlDataComparisonQueryInputTable controlDataInputLineItem) {
        String classification = determineClassification(controlDataInputLineItem.getActualValue(), controlDataInputLineItem.getExtractedValue(), matchStatus);
        jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable + " (" + "root_pipeline_id, created_on, group_id, file_name, origin_id, batch_id, " + "paper_no, actual_value, extracted_value, match_status, mismatch_count, " + "tenant_id, classification, sor_container_id, sor_item_name, sor_item_id" + ") VALUES (" + ":rootPipelineId, :createdOn, :groupId, :fileName, :originId, :batchId, :paperNo, " + ":actualValue, :extractedValue, :matchStatus, :mismatchCount, :tenantId, " + ":classification, :sorContainerId, :sorItemName, :sorItemId" + ");").bind("rootPipelineId", controlDataInputLineItem.getRootPipelineId()).bind("createdOn", LocalDate.now()).bind("groupId", controlDataInputLineItem.getGroupId()).bind("fileName", controlDataInputLineItem.getFileName()).bind("originId", controlDataInputLineItem.getOriginId()).bind("batchId", controlDataInputLineItem.getBatchId()).bind("paperNo", controlDataInputLineItem.getPaperNo()).bind("actualValue", controlDataInputLineItem.getActualValue()).bind("extractedValue", controlDataInputLineItem.getExtractedValue()).bind("matchStatus", matchStatus).bind("mismatchCount", mismatchCount).bind("tenantId", controlDataInputLineItem.getTenantId()).bind("classification", classification).bind("sorContainerId", controlDataInputLineItem.getSorContainerId()).bind("sorItemName", controlDataInputLineItem.getSorItemName()).bind("sorItemId", controlDataInputLineItem.getSorItemId()).execute());
    }


    private String determineClassification(String actualValue, String extractedValue, String matchStatus) {
        String normalizedActual = actualValue == null ? "" : actualValue.trim();
        String normalizedExtracted = extractedValue == null ? "" : extractedValue.trim();

        boolean actualEmpty = normalizedActual.isEmpty();
        boolean extractedEmpty = normalizedExtracted.isEmpty();

        if ("NO TOUCH".equals(matchStatus) && actualEmpty && extractedEmpty) {
            return "TN";
        }

        if ("NO TOUCH".equals(matchStatus) && !actualEmpty && !extractedEmpty) {
            return "TP";
        }

        if (actualEmpty && !extractedEmpty) {
            return "FN";
        }

        if (!actualEmpty && (extractedEmpty || !"NO TOUCH".equals(matchStatus))) {
            return "FP";
        }

        return "UNKNOWN";
    }

    public static String calculateValidationScores(Long mismatchCount,String oneTouch,String lowTouch) {
        String matchStatus;

        if (mismatchCount == 0) {
            matchStatus = "NO TOUCH";
        } else if (mismatchCount <= Long.parseLong(oneTouch)) {
            matchStatus = "ONE TOUCH";
        } else if (mismatchCount <= Long.parseLong(lowTouch)) {
            matchStatus = "LOW TOUCH";
        } else {
            matchStatus = "HIGH TOUCH";
        }
        return matchStatus;
    }


    @Override
    public boolean executeIf() throws Exception {
        return controlDataComparison.getCondition();
    }
}