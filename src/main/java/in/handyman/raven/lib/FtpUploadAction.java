package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.FtpUpload;
import in.handyman.raven.lib.model.ftpUpload.FtpUploadInputTable;
import in.handyman.raven.lib.model.ftpUpload.FtpUploadOutputTable;
import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Types;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "FtpUpload"
)
public class FtpUploadAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final FtpUpload ftpUpload;

  private final Marker aMarker;

  public FtpUploadAction(final ActionExecutionAudit action, final Logger log,
                         final Object ftpUpload) {
    this.ftpUpload = (FtpUpload) ftpUpload;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" FtpUpload:" + this.ftpUpload.getName());
  }

  @Override
  public void execute() throws Exception {
    log.info(aMarker, "ftp download Action for {} has started", ftpUpload.getName());
    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ftpUpload.getResourceConn());
    jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
    List<String> uploadedFilePaths = new ArrayList<>();

    FtpUploadInputTable ftpUploadInputTable = getInputTableFromQuerySet(ftpUpload.getQuerySet(), jdbi);
    String userName = ftpUploadInputTable.getUsername();
    String password = ftpUploadInputTable.getPassword();
    String remoteHost = ftpUploadInputTable.getServerAddress();
    String sourceDir = ftpUploadInputTable.getFolderPath();

    final long tenantId = Long.parseLong(action.getContext().get("tenant_id"));
    final Long rootPipelineId = action.getRootPipelineId();

    final String remotePort = action.getContext().get("ftpPort");
    final String localDir = action.getContext().get("localDir");
    final String uploadTime = action.getContext().get("uploadTime");
    FTPClient ftpClient = new FTPClient();

    final String ftp = "FTP";
    final String active = "ACTIVE";
    try {
      int reply;
      ftpClient.connect(remoteHost, Integer.parseInt(remotePort));
      log.info(aMarker, "FTP URL HOST {} and port {} ", remoteHost, ftpClient.getDefaultPort());
      reply = ftpClient.getReplyCode();
      if (!FTPReply.isPositiveCompletion(reply)) {
        ftpClient.disconnect();
        log.error("Exception in connecting to FTP Server");
        throw new RuntimeException();
      }
      ftpClient.login(userName, password);
      ftpClient.enterLocalPassiveMode();
      ftpClient.setUseEPSVwithIPv4(true);
      System.setProperty("https.protocols", "TLSv1,TLSv1.1,TLSv1.2");

      ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
      ftpClient.changeWorkingDirectory(localDir);
      FTPFile[] subFiles = ftpClient.listFiles();

      String dirToCreate =  sourceDir + File.separator +"Upload";
      directoryCreation(ftpClient, dirToCreate);

      if (uploadTime.equals("null")) {
        File localDirectory = new File(localDir);

        if (localDirectory.isDirectory()) {
          File[] localFiles = localDirectory.listFiles();
          if (localFiles != null) {
            for (File localFile : localFiles) {
              if (localFile.isFile()) {
                String localFilePath = localFile.getAbsolutePath();
                String remoteFilePath = sourceDir + "/" + localFile.getName();
                uploadSingleFile(ftpClient, localFilePath, sourceDir);
                uploadedFilePaths.add(remoteFilePath);
              }
            }

            if (!uploadedFilePaths.isEmpty()) {

              ObjectMapper mapper = new ObjectMapper();
              String filePaths = mapper.writeValueAsString(uploadedFilePaths);

              FtpUploadOutputTable outputTable = FtpUploadOutputTable.builder()
                      .tenantId(tenantId)
                      .rootPipelineId(rootPipelineId) // Adjust as needed
                      .createdOn(LocalDateTime.now())
                      .createdUserId(tenantId) // Set as needed
                      .lastUpdatedUserId(tenantId) // Set as needed
                      .lastUpdatedOn(LocalDateTime.now())
                      .status(active) // Set the status as needed
                      .message("FTP upload completed")
                      .type(ftp) // Set as needed
                      .lastProcessedOn(LocalDateTime.now())
                      .ftpFolderPath(sourceDir) // Set the FTP folder path
                      .destinationPath(localDir) // Set the destination path
                      .filePath(filePaths)
                      .version(1)
                      .executionStatus("COMPLETED")
                      .build();
              insertIntoOutputTable(jdbi, outputTable);
            }
          }

        }
        } else {
        File localDirectory = new File(localDir);
        if (localDirectory.isDirectory()) {
                  File[] localFiles = localDirectory.listFiles();
                  if (localFiles != null) {
                    for (File localFile : localFiles) {
                      LocalDateTime lastModifiedTime = convertTimestampToLocalDateTime(localFile.lastModified());
                      LocalDateTime uploadTimeDate = LocalDateTime.parse(uploadTime);
                      if (lastModifiedTime.isAfter(uploadTimeDate)) {
                      if (localFile.isFile()) {
                        String localFilePath = localFile.getAbsolutePath();
                        String remoteFilePath = sourceDir + "/" + localFile.getName();
                        uploadSingleFile(ftpClient, localFilePath, sourceDir);
                        uploadedFilePaths.add(remoteFilePath);
                      }
                    }
                  }
                }
                if (!uploadedFilePaths.isEmpty()) {
                  ObjectMapper mapper = new ObjectMapper();
                  String filePaths = mapper.writeValueAsString(uploadedFilePaths);
                  FtpUploadOutputTable outputTable = FtpUploadOutputTable.builder()
                          .tenantId(tenantId)
                          .rootPipelineId(rootPipelineId)
                          .createdUserId(tenantId)
                          .lastUpdatedUserId(tenantId)
                          .lastUpdatedOn(LocalDateTime.now())
                          .status(active)
                          .message("FTP upload completed")
                          .type(ftp)
                          .lastProcessedOn(LocalDateTime.now())
                          .ftpFolderPath(sourceDir)
                          .destinationPath(localDir)
                          .filePath(filePaths)
                          .createdOn(LocalDateTime.now())
                          .createdUserId(tenantId)
                          .lastUpdatedOn(LocalDateTime.now())
                          .lastUpdatedUserId(tenantId)
                          .version(1)
                          .build();
                  insertIntoOutputTable(jdbi, outputTable);
                }
              }
            }


    } catch (Exception e) {
      String executionStatus = "FAILED";
      FtpUploadOutputTable outputTable = FtpUploadOutputTable.builder()
              .tenantId(tenantId)
              .rootPipelineId(rootPipelineId)
              .createdUserId(tenantId)
              .lastUpdatedUserId(tenantId)
              .lastUpdatedOn(LocalDateTime.now())
              .status(active)
              .message(e.getMessage())
              .type(ftp)
              .lastProcessedOn(LocalDateTime.now())
              .ftpFolderPath(sourceDir)
              .destinationPath(localDir)
              .createdOn(LocalDateTime.now())
              .createdUserId(tenantId)
              .lastUpdatedOn(LocalDateTime.now())
              .lastUpdatedUserId(tenantId)
              .version(1)
              .executionStatus(executionStatus)
              .build();
      insertIntoOutputTable(jdbi, outputTable);
      log.error("Error during FTP download: {}", e.getMessage(), e);

    } finally {
      if (ftpClient.isConnected()) {
        ftpClient.logout();
        ftpClient.disconnect();
        log.info("FTP Client is disconnected");
      } else {
        log.info("Nothing to disconnect in ftp Client ");
      }
    }
  }

  private void insertIntoOutputTable(Jdbi jdbi, FtpUploadOutputTable ftpUploadOutputTable) {
    jdbi.useTransaction(handle -> {
      handle.createUpdate("INSERT INTO onboard_wizard_info.ftp_upload_info\n" +
                      "                (created_on, created_user_id, last_updated_on, last_updated_user_id, status, version, destination_path, execution_status, file_path, ftp_folder_path, info, last_processed_on, message, root_pipeline_id, tenant_id, type) " +
                      "VALUES( :createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :status, :version, :destinationPath, :executionStatus, :filePath::jsonb, :ftpFolderPath, :info, :lastProcessedOn, :message, :rootPipelineId, :tenantId, :type);")
              .bindBean(ftpUploadOutputTable).execute();
      log.debug(aMarker, "inserted {} into ftp download info details", ftpUploadOutputTable);
    });
  }

  private LocalDateTime convertTimestampToLocalDateTime(long timestamp) {
    Instant instant = Instant.ofEpochMilli(timestamp);
    return LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
  }


  private FtpUploadInputTable getInputTableFromQuerySet(String querySet, Jdbi jdbi) {
    try (Handle handle = jdbi.open()) {
      return handle.createQuery(querySet)
              .mapToBean(FtpUploadInputTable.class)
              .one();
    }
  }

  public void uploadSingleFile(FTPClient ftpClient, String localFilePath, String remoteFilePath) throws IOException {
    System.out.println("Working Directory" + ftpClient.printWorkingDirectory());

    File localFile = new File(localFilePath);
    boolean isCompleted;
    try (InputStream inputStream = new FileInputStream(localFile)) {
      ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
      isCompleted = ftpClient.storeFile(localFile.getName(), inputStream);
    }
    if (isCompleted) {
        log.info(aMarker, "Uploaded the file {} to remote path: {}", localFilePath, remoteFilePath);
    }
    else {
               log.error(aMarker, "Couldn't complete the file upload: {} to remote path: {}", localFilePath, remoteFilePath);
    }

  }

  private void directoryCreation(FTPClient ftpClient, String dirToCreate) throws IOException {
    boolean directoryCreated = ftpClient.makeDirectory(dirToCreate);
    if (directoryCreated) {

      System.out.println("Directory created successfully: " + dirToCreate);
    } else {
      System.out.println("Failed to create directory: " + dirToCreate);
    }
    boolean isDirectoryChanged = ftpClient.changeWorkingDirectory(dirToCreate);
    log.info("Is Directory switched {}", isDirectoryChanged);
  }

  @Override
  public boolean executeIf() throws Exception {
    return ftpUpload.getCondition();
  }

}