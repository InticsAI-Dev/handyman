package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.HttpsDownload;
import in.handyman.raven.lib.model.https.HttpsDownloadOutputTable;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import javax.net.ssl.HttpsURLConnection;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.URL;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;


/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "HttpsDownload"
)
public class HttpsDownloadAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final HttpsDownload httpsDownload;

  private final Marker aMarker;


  public HttpsDownloadAction(final ActionExecutionAudit action, final Logger log,
      final Object httpsDownload) {
    this.httpsDownload = (HttpsDownload) httpsDownload;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" HttpsDownload:"+this.httpsDownload.getName());
  }

  @Override
  public void execute() throws Exception {


    log.info(aMarker, "https Action for {} has started", httpsDownload.getName());
    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(httpsDownload.getResourceConn());
    jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));




    final String tenantId = action.getContext().get("tenant_id");
    final String url =action.getContext().get("url");
    final Long rootPipelineId = action.getRootPipelineId();
  //  final String userName = action.getContext().get("userName");
   // final String password = action.getContext().get("password");
    final String savePath = action.getContext().get("savePath");
    final String localDestination =action.getContext().get("localDestination");
    final String https = "HTTPS";
    final String active = "ACTIVE";


    try {
      URL endpoint = new URL(url);
      // Open an HTTP(S) connection
      HttpsURLConnection connection = (HttpsURLConnection) endpoint.openConnection();
      connection.setRequestMethod("GET");
      int responseCode = connection.getResponseCode();
      if (responseCode == HttpsURLConnection.HTTP_OK) {
        try (InputStream in = connection.getInputStream();
             FileOutputStream out = new FileOutputStream(savePath)) {
          byte[] buffer = new byte[4096];
          int bytesRead;
          while ((bytesRead = in.read(buffer)) != -1) {
            out.write(buffer, 0, bytesRead);
          }
        }
        log.info("ZIP file downloaded successfully.");
        // Extract files from the ZIP
        try (ZipArchiveInputStream zipInput = new ZipArchiveInputStream(new FileInputStream(savePath))) {
          List<String> extractedFilePaths = new ArrayList<>();
          ArchiveEntry entry;
          while ((entry = zipInput.getNextEntry()) != null) {
            if (!zipInput.canReadEntryData(entry)) {
              continue;
            }
            File file = new File(localDestination, entry.getName());
            if (entry.isDirectory()) {
              file.mkdirs();
            } else {
              try (FileOutputStream output = new FileOutputStream(file)) {
                IOUtils.copy(zipInput, output);
              }
              extractedFilePaths.add(file.getPath());
              String completed = "COMPLETED";
              ObjectMapper mapper = new ObjectMapper();
              String filePaths = mapper.writeValueAsString(extractedFilePaths);

              HttpsDownloadOutputTable httpsDownloadOutputTable = HttpsDownloadOutputTable.builder()
                      .tenantId(Long.valueOf(tenantId))
                      .rootPipelineId(rootPipelineId) // Adjust as needed
                      .createdOn(LocalDateTime.now())
                      .createdUserId(Long.valueOf(tenantId)) // Set as needed
                      .lastUpdatedUserId(Long.valueOf(tenantId)) // Set as needed
                      .lastUpdatedOn(LocalDateTime.now())
                      .status(active) // Set the status as needed
                      .message("https download completed")
                      .type(https)
                      .info("")// Set as needed
                      .lastProcessedOn(LocalDateTime.now())
                      .savePath(savePath) // Set the https folder path
                      .localDestination(localDestination) // Set the destination path
                      .filePaths(filePaths)
                      .version(1)
                      .executionStatus(completed)
                      .build();
              insertIntoOutputTable(jdbi, httpsDownloadOutputTable);
            }
          }
        } catch (Exception e) {
          String completed = "FAILED";
          HttpsDownloadOutputTable httpsDownloadOutputTable = HttpsDownloadOutputTable.builder()
                  .tenantId(Long.valueOf(tenantId))
                  .rootPipelineId(rootPipelineId) // Adjust as needed
                  .createdOn(LocalDateTime.now())
                  .createdUserId(Long.valueOf(tenantId)) // Set as needed
                  .lastUpdatedUserId(Long.valueOf(tenantId)) // Set as needed
                  .lastUpdatedOn(LocalDateTime.now())
                  .status(active) // Set the status as needed
                  .message("https download completed")
                  .type(https)
                  .lastProcessedOn(LocalDateTime.now())
                  .savePath(savePath) // Set the https folder path
                  .localDestination(localDestination) // Set the destination path
                  .version(1)
                  .executionStatus(completed)
                  .build();
          insertIntoOutputTable(jdbi, httpsDownloadOutputTable);

        }
      } else {
        log.error("HTTP Error: " + responseCode);
      }
    } catch (Exception e) {
      log.error("An error occurred during HTTPS download", e);
    }
  }




private void insertIntoOutputTable(Jdbi jdbi, HttpsDownloadOutputTable httpsDownloadOutputTable) {
    jdbi.useTransaction(handle -> {
      handle.createUpdate("INSERT INTO onboard_wizard_info.https_download_info\n" +
                      "                (created_on, created_user_id, last_updated_on, last_updated_user_id, status, version, local_destination, execution_status, file_paths, save_path, info, last_processed_on, message, root_pipeline_id, tenant_id, type) " +
                      "VALUES( :createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :status, :version, :localDestination, :executionStatus, :filePaths::jsonb, :savePath, :info, :lastProcessedOn, :message, :rootPipelineId, :tenantId, :type);")
              .bindBean(httpsDownloadOutputTable).execute();
      log.debug(aMarker, "inserted {} into https download info details", httpsDownloadOutputTable);
    });
  }

  @Override
  public boolean executeIf() throws Exception {
    return httpsDownload.getCondition();
  }
}
