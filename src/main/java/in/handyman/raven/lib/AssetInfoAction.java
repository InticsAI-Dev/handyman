
package in.handyman.raven.lib;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.AssetInfo;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.OkHttpClient;
import org.apache.commons.io.FilenameUtils;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import static java.lang.Math.random;
/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "AssetInfo"
)
public class AssetInfoAction implements IActionExecution {
  private final ActionExecutionAudit action;
  private final Logger log;
  private final AssetInfo assetInfo;
  private final Marker aMarker;
  public AssetInfoAction(final ActionExecutionAudit action, final Logger log,
                         final Object assetInfo) {
    this.assetInfo = (AssetInfo) assetInfo;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" AssetInfo:" + this.assetInfo.getName());
  }
  @Override
  public void execute() throws Exception {
    try {
      log.info(aMarker, "<-------Asset Info Action for {} has been started------->" + assetInfo.getName());
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(assetInfo.getResourceConn());
      final List<Map<String, Object>> tableInfos = new ArrayList<>();
      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(assetInfo.getValues());
        formattedQuery.forEach(sqlToExecute -> {
          tableInfos.addAll(handle.createQuery(sqlToExecute).mapToMap().stream().collect(Collectors.toList()));
        });
      });
      List<Path> pathList = new ArrayList<>();
      tableInfos.forEach(tableInfo -> {
        final String filePathString = Optional.ofNullable(tableInfo.get("file_path")).map(String::valueOf).orElse("[]");
        File file = new File(filePathString);
        if(file.isDirectory()){
          try (var files = Files.walk(Path.of(filePathString)).filter(Files::isRegularFile)){
            files.forEach(pathList::add);
          } catch (IOException e) {
            throw new RuntimeException(e);
          }
          pathList.forEach(path -> {
            insertQuery(jdbi, path.toFile());
          });
        } else if (file.isFile()) {
          insertQuery(jdbi, file);
        }
      });
    } catch (Exception e) {
      action.getContext().put(assetInfo.getName().concat(".error"), "true");
      log.info(aMarker, "The Exception occurred ", e);
      throw new HandymanException("Failed to execute", e);
    }
    log.info(aMarker, "<-------Asset Info Action for {} has been completed------->" + assetInfo.getName());
  }
  public void insertQuery(Jdbi jdbi,File file){
    String sha1Hex;
    try (InputStream is = Files.newInputStream(Path.of(file.getPath()))) {
      sha1Hex = org.apache.commons.codec.digest.DigestUtils.sha1Hex(is);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    var fileSize = file.length() / 1024;
    FileInfo fileInfo = FileInfo.builder()
            .file_id(FilenameUtils.removeExtension(file.getName())+"_"+((int)(900000* random() + 100000)))
            .file_checksum(sha1Hex)
            .file_extension(FilenameUtils.getExtension(file.getName()))
            .file_name(FilenameUtils.removeExtension(file.getName()))
            .file_path(file.getPath())
            .file_size(String.valueOf(fileSize))
            .root_pipeline_id(action.getContext().get("pipeline-id"))
            .process_id(action.getContext().get("process-id"))
            .build();
    jdbi.useTransaction(handle -> {
      handle.execute("CREATE TABLE IF NOT EXISTS macro."+assetInfo.getAssetTable()+"(file_id varchar not null,process_id varchar NOT NULL,root_pipeline_id varchar NOT NULL,file_checksum varchar NOT NULL,file_extension varchar NOT NULL,file_name varchar NOT NULL,file_path varchar NOT NULL,file_size varchar NOT NULL)");
      handle.createUpdate("INSERT INTO macro."+assetInfo.getAssetTable()+"(file_id,process_id,root_pipeline_id, file_checksum, file_extension, file_name, file_path, file_size)" +
                      "VALUES(:file_id,:process_id, :root_pipeline_id, :file_checksum, :file_extension, :file_name, :file_path, :file_size);")
              .bindBean(fileInfo).execute();
      log.debug(aMarker, "inserted {} into source of origin", fileInfo);
    });
  }
  @Override
  public boolean executeIf() throws Exception {
    return assetInfo.getCondition();
  }
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public static class FileInfo {
    private String file_id;
    private String process_id;
    private String root_pipeline_id;
    private String file_checksum;
    private String file_extension;
    private String file_name;
    private String file_path;
    private String file_size;
  }
}