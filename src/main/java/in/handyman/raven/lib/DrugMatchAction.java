package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.DrugMatch;

import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.InstanceUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "DrugMatch"
)
public class DrugMatchAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;
  final String URI;


  private final DrugMatch drugMatch;

  private final Marker aMarker;
  final ObjectMapper MAPPER;
  final OkHttpClient httpclient;
  private String appId;
  private String appKeyId;
  private static final MediaType MediaTypeJSON = MediaType.parse("application/json; charset=utf-8");
  private final Integer writeBatchSize = 1000;


  public DrugMatchAction(final ActionExecutionAudit action, final Logger log,
                         final Object drugMatch) {
    this.drugMatch = (DrugMatch) drugMatch;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" DrugMatch:" + this.drugMatch.getName());
    this.URI = action.getContext().get("drugname.api.url");
    this.appId = action.getContext().get("agadia.appId");
    this.appKeyId = action.getContext().get("agadia.appKeyId");
    this.MAPPER = new ObjectMapper();
    this.httpclient = InstanceUtil.createOkHttpClient();
  }

  @Override
  public void execute() throws Exception {
    log.info(aMarker, "<-------drug match process for {} has been started------->" + drugMatch.getName());
    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(drugMatch.getResourceConn());


    final List<DrugMatchInput> inputResult = new ArrayList<>();
    jdbi.useTransaction(handle -> {
      final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(drugMatch.getInputSet());
      AtomicInteger i = new AtomicInteger(0);
      formattedQuery.forEach(sqlToExecute -> {
        log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
        Query query = handle.createQuery(sqlToExecute);
        ResultIterable<DrugMatchInput> resultIterable = query.mapToBean(DrugMatchInput.class);
        List<DrugMatchInput> detailList = resultIterable.stream().collect(Collectors.toList());
        inputResult.addAll(detailList);
        log.info(aMarker, "executed query from index {}", i.get());
      });
    });

    List<DrugMatchOutput> resultQueue = new ArrayList<>();
    inputResult.forEach(result -> {
      final String requestString;
      if (result.getDrugName() != null) {
        DrugNameRequest drugNameRequest = DrugNameRequest.builder()
                .drugName(result.drugName)
                .jCode(result.jCode)
                .build();
        try {
          requestString = MAPPER.writeValueAsString(drugNameRequest);
        } catch (JsonProcessingException e) {
          throw new RuntimeException(e);
        }

        final Request request = new Request.Builder().url(URI).header("appId",appId).header("appKeyId",appKeyId)
                .post(RequestBody.create(requestString, MediaTypeJSON)).build();
        try (Response response = httpclient.newCall(request).execute()) {
          String responseBody = Objects.requireNonNull(response.body()).string();
          if (response.isSuccessful()) {
            List<drugNameResponse> output = MAPPER.readValue(responseBody, new TypeReference<>() {
            });
            AtomicInteger atomicInteger = new AtomicInteger();

            output.forEach(drugNameResponse -> {
              resultQueue.add(
                      DrugMatchOutput.builder()
                              .originId(result.getOriginId())
                              .eocIdentifier(result.eocIdentifier).paperNo(result.paperNo)
                              .documentId(result.documentId)
                              .jCode(result.getJCode())
                              .drugName(result.getDrugName())
                              .masterValue(drugNameResponse.getDrugName()).build());
            });
            consumerBatch(jdbi, resultQueue);

          } else {

            throw new HandymanException(responseBody);
          }
        } catch (Throwable t) {
          log.error(aMarker, "error inserting row {}");
        }
      }


    });


  }

  void consumerBatch(final Jdbi jdbi, List<DrugMatchOutput> resultQueue) {
    try {
      resultQueue.forEach(insert -> {
                jdbi.useTransaction(handle -> {
                  try {
                    Update update = handle.createUpdate(" INSERT INTO " + drugMatch.getDrugCompare() +
                            " (origin_id ,eoc_identifier,paper_no,created_on,document_id,drug_name,drug_jcode,actual_value)" +
                            "VALUES(:originId,:eocIdentifier,:paperNo,NOW(),:documentId,:drugName,null,:masterValue)");
                    Update bindBean = update.bindBean(insert);
                    bindBean.execute();
                  } catch (Throwable t) {
                    log.error(aMarker, "error inserting result {}", resultQueue, t);
                  }
                });
              }
      );
    } catch (Throwable t) {
      log.error(aMarker, "error inserting result {}", resultQueue, t);
    }
  }



  @Override
  public boolean executeIf() throws Exception {
    return drugMatch.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static  class DrugMatchInput {

    private String originId;
    private String eocIdentifier;
    private Integer paperNo;
    private String documentId;
    private String drugName;
    private String jCode;

  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static  class DrugMatchOutput {

    private String originId;
    private String eocIdentifier;
    private Integer paperNo;
    private String documentId;
    private String drugName;
    private String jCode;
    private String masterValue;

  }


  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class DrugNameRequest {

    private String drugName;
    private String jCode;

  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class drugNameResponse {

    private String drugName;
    private String ndc;
    private String jCode;


  }
}


