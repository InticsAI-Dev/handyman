package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.KafkaProductionResponse;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;


/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "KafkaProductionResponse"
)
public class KafkaProductionResponseAction implements IActionExecution {
  private final ActionExecutionAudit action;
  private final Logger log;
  private final KafkaProductionResponse kafkaProductionResponse;
  private final Marker aMarker;
  private static final String SIT_EP_URL = "kafka.production.response.url";
  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  private final List<KafkaProductionInput> kafkaProductionInputs = new ArrayList<>();

  public KafkaProductionResponseAction(final ActionExecutionAudit action, final Logger log,
                                       final Object kafkaProductionResponse) {
    this.kafkaProductionResponse = (KafkaProductionResponse) kafkaProductionResponse;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker("KafkaProductionResponse:" + this.kafkaProductionResponse.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(kafkaProductionResponse.getResourceConn());

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(kafkaProductionResponse.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        for (String sqlToExecute : formattedQuery) {
          log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<KafkaProductionInput> resultIterable = query.mapToBean(KafkaProductionInput.class);
          List<KafkaProductionInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
          kafkaProductionInputs.addAll(processingExecutorInputs);
          log.info(aMarker, "Executed query from index {}", i.get());
        }
      });

      log.info(aMarker, "KafkaProductionResponse action total rows returned from the query {}", kafkaProductionInputs.size());

      // Process each input
      for (KafkaProductionInput input : kafkaProductionInputs) {
        try {
          String requestTxnId = input.getRequestTxnId();
          log.info(aMarker, "Processing KafkaProductionResponse for requestTxnId: {}", requestTxnId);

          // Prepare request body
          Map<String, String> requestBody = new HashMap<>();
          requestBody.put("requestTxnId", requestTxnId);
          String requestJson = OBJECT_MAPPER.writeValueAsString(requestBody);


          HttpClient client = HttpClient.newHttpClient();
          HttpRequest request = HttpRequest.newBuilder()
                  .uri(URI.create(SIT_EP_URL))
                  .header("Content-Type", "application/json")
                  .POST(HttpRequest.BodyPublishers.ofString(requestJson))
                  .build();

          HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
          int statusCode = response.statusCode();
          String responseBody = response.body();


          String status;
          String message;
          switch (statusCode) {
            case 200:
              Map<String, Object> responseMap = OBJECT_MAPPER.readValue(responseBody, Map.class);
              String detail = (String) responseMap.get("detail");

              switch (detail) {
                case "SUCCESS":
                  log.info(aMarker, "Successfully retrieved payload for requestTxnId: {}", requestTxnId);
                  status = "SUCCESS";
                  message = "Successfully retrieved payload";
                  action.getContext().put(kafkaProductionResponse.getName() + ".isSuccessful", "true");
                  action.getContext().put(kafkaProductionResponse.getName() + ".response", responseBody);
                  break;
                case "Error in AWS Payload":
                  log.error(aMarker, "AWS Payload error for requestTxnId: {}", requestTxnId);
                  message = "AWS Payload error";
                  throw new HandymanException("Error in AWS Payload for requestTxnId: " + requestTxnId);
                case "No data found":
                  log.warn(aMarker, "No data found for requestTxnId: {}", requestTxnId);
                  message = "No data found";
                  throw new HandymanException("No data found for requestTxnId: " + requestTxnId);
                default:
                  log.error(aMarker, "Unexpected detail value in response: {}", detail);
                  message = "Unexpected response detail: " + detail;
                  throw new HandymanException("Unexpected response detail: " + detail);
              }
              break;
            case 403:
              log.error(aMarker, "Invalid request for requestTxnId: {}", requestTxnId);
              message = "Invalid request";
              throw new HandymanException("Invalid request for requestTxnId: " + requestTxnId);
            case 500:
              log.error(aMarker, "Application error for requestTxnId: {}", requestTxnId);
              message = "Application error";
              throw new HandymanException("Application error for requestTxnId: " + requestTxnId);
            default:
              log.error(aMarker, "Unexpected status code {} for requestTxnId: {}", statusCode, requestTxnId);
              message = "Unexpected status code: " + statusCode;
              throw new HandymanException("Unexpected status code: " + statusCode);
          }

          insertResponseDetails(jdbi, input, responseBody, status, message);

        } catch (Exception e) {
          action.getContext().put(kafkaProductionResponse.getName() + ".isSuccessful", "false");
          log.error(aMarker, "Error processing requestTxnId: {}", input.getRequestTxnId(), e);
          HandymanException handymanException = new HandymanException(e);
          HandymanException.insertException("KafkaProductionResponse failed for requestTxnId: " + input.getRequestTxnId(), handymanException, action);
        }
      }

      log.info(aMarker, "KafkaProductionResponse action completed");

    } catch (Exception e) {
      action.getContext().put(kafkaProductionResponse.getName() + ".isSuccessful", "false");
      log.error(aMarker, "Error in KafkaProductionResponse action", e);
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("KafkaProductionResponse failed", handymanException, action);
      throw handymanException;
    }
  }

  private void insertResponseDetails(Jdbi jdbi, KafkaProductionInput input, String responseBody, String status, String message) {
    jdbi.useHandle(handle -> handle.createUpdate(
                    "INSERT INTO " + kafkaProductionResponse.getOutputTable() + " (" +
                            "created_on, created_user_id, last_updated_on, last_updated_user_id, status, version, " +
                            "production_response, document_id, extension, origin_id, tenant_id, transaction_id, " +
                            "requestTxnId, fileName, batch_id, message) VALUES (" +
                            ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :status, :version, " +
                            ":productionResponse, :documentId, :extension, :originId, :tenantId, :transactionId, " +
                            ":requestTxnId, :fileName, :batchId, :message)")
            .bind("createdOn", LocalDateTime.now())
            .bind("createdUserId", input.getTenantId())
            .bind("lastUpdatedOn", LocalDateTime.now())
            .bind("lastUpdatedUserId", input.getTenantId())
            .bind("status", status)
            .bind("version", 1)
            .bind("productionResponse", responseBody)
            .bind("documentId", input.getDocumentId())
            .bind("extension", input.getExtension())
            .bind("originId", input.getOriginId())
            .bind("tenantId", input.getTenantId())
            .bind("transactionId", input.getTransactionId())
            .bind("requestTxnId", input.getRequestTxnId())
            .bind("fileName", input.getFileName())
            .bind("batchId", input.getBatchId())
            .bind("message", message)
            .execute());
    log.info(aMarker, "Inserted response details for requestTxnId: {} with status: {} and message: {}",
            input.getRequestTxnId(), status, message);
  }

  @Override
  public boolean executeIf() throws Exception {
    return kafkaProductionResponse.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  public static class KafkaProductionInput {
    private String requestTxnId;
    private String documentId;
    private String extension;
    private String originId;
    private Long tenantId;
    private String transactionId;
    private String fileName;
    private String batchId;
    private Long rootPipelineId;
  }
}