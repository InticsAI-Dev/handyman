package in.handyman.raven.lib;

import in.handyman.raven.actor.HandymanActorSystemAccess;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lambda.doa.audit.StatementExecutionAudit;
import in.handyman.raven.lib.encryption.SecurityEngine;
import in.handyman.raven.lib.model.Transform;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.ExceptionUtil;
import in.handyman.raven.util.UniqueID;
import org.jdbi.v3.core.Jdbi;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLSyntaxErrorException;
import java.sql.Statement;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = TransformAction.TRANSFORM
)
public class TransformAction implements IActionExecution {

    protected static final String TRANSFORM = "Transform";

    private final ActionExecutionAudit actionExecutionAudit;
    private final Logger log;
    private final Transform transform;

    private final Marker aMarker;

    public TransformAction(final ActionExecutionAudit actionExecutionAudit, final Logger log, final Object transform) {
        this.transform = (Transform) transform;
        this.actionExecutionAudit = actionExecutionAudit;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(TRANSFORM);
    }

    @Override
    public void execute() {
        List<StatementExecutionAudit> statementExecutionAudits = new ArrayList<>();

        log.info(aMarker, "Transform Action for {} has been started", transform.getName());
        final String dbSrc = transform.getOn();
        log.info(aMarker, "Transform action input variables id: {}, name: {}, source-database: {} ", actionExecutionAudit.getActionId(), transform.getName(), dbSrc);

        boolean transfromSQLEncrypter = Boolean.parseBoolean(actionExecutionAudit.getContext().get("tranform.sql.encrypt.activator"));
        List<String> transformValue = transform.getValue();
        if (transfromSQLEncrypter) {
            String transformValueEncrypted = SecurityEngine.getInticsIntegrityMethod(actionExecutionAudit).encrypt(transformValue.toString(), "AES256", "SQL_DATA");
            log.debug(aMarker, "Sql input post parameter ingestion \n {}", transformValueEncrypted);
        } else {
            log.debug(aMarker, "Sql input post parameter ingestion \n {}", transformValue);
        }

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(dbSrc);
        jdbi.useTransaction(handle -> {
            try {
                final Connection connection = handle.getConnection();
                connection.setAutoCommit(false);
                for (String givenQuery : transformValue) {

                    var sqlList = Boolean.TRUE.equals(transform.getFormat()) ? CommonQueryUtil.getFormattedQuery(givenQuery) : Collections.singletonList(givenQuery);
                    for (var sqlToExecute : sqlList) {
                        String encryptedSqlToExecute;
                        if (transfromSQLEncrypter) {
                            encryptedSqlToExecute = SecurityEngine.getInticsIntegrityMethod(actionExecutionAudit).encrypt(sqlToExecute, "AES256", "SQL_DATA");
                        } else {
                            encryptedSqlToExecute = sqlToExecute;
                        }

                        LocalDateTime startTime = LocalDateTime.now();
                        StatementExecutionAudit statementAudit = getStatementExecutionAudit(sqlToExecute, startTime);

                        if (sqlToExecute.startsWith("--")) {
                            log.error(aMarker, "Transform with id:{}, Skipping comment {}", actionExecutionAudit.getActionId(), encryptedSqlToExecute);
                        }
                        log.info(aMarker, "Transform with id:{}, executing script {}", actionExecutionAudit.getActionId(), encryptedSqlToExecute);
                        final Long statementId = UniqueID.getId();
                        try (final Statement stmt = connection.createStatement()) {
                            var rowCount = stmt.executeUpdate(sqlToExecute);
                            var warnings = ExceptionUtil.completeSQLWarning(stmt.getWarnings());
                            addExecutionAudit(sqlToExecute, statementAudit, rowCount, startTime);
                            log.debug(aMarker, "{}.count-{}", encryptedSqlToExecute, rowCount);
                            log.debug(aMarker, "{}.stmtCount - {}", encryptedSqlToExecute, stmt.getUpdateCount());
                            log.debug(aMarker, "{}.warnings - {}", encryptedSqlToExecute, warnings);
                            log.info(aMarker, "Transform id# {}, executed script {} rows returned {}", statementId, encryptedSqlToExecute, rowCount);
                            stmt.clearWarnings();
                        } catch (SQLSyntaxErrorException ex) {
                            log.error(aMarker, "Stopping execution, General Error executing sql for {} with for {}", encryptedSqlToExecute, ExceptionUtil.toString(ex));
                            throw new HandymanException("Transform failed for statement " + statementId, ex, actionExecutionAudit);
                        } catch (SQLException ex) {
                            log.error(aMarker, "Continuing to execute, even though SQL Error executing sql for {} ", encryptedSqlToExecute, ex);
                            throw new HandymanException("Transform failed for statement " + statementId, ex, actionExecutionAudit);
                        } catch (Exception ex) {
                            log.error(aMarker, "Stopping execution, General Error executing sql for {} with for {}", encryptedSqlToExecute, ExceptionUtil.toString(ex));
                            throw new HandymanException("Transform failed for statement " + statementId, ex, actionExecutionAudit);
                        }
                        statementExecutionAudits.add(statementAudit);
                    }
                    connection.commit();

                    log.debug(aMarker, "Completed Transform id#{}, name#{}, dbSrc#{}, sqlList#{}", actionExecutionAudit.getActionId(), transform.getName()
                            , dbSrc, sqlList);
                }

                log.info(aMarker, "Transform Action for {} has been completed", transform.getName());
            } catch (SQLException ex) {
                log.error(aMarker, "Stopping execution, Fetching connection failed", ex);
                throw new HandymanException("Transform failed for action " + actionExecutionAudit.getActionId(), ex, actionExecutionAudit);
            }
        });
        insertCompletionIntoStatementAudit(statementExecutionAudits);


    }

    private static void addExecutionAudit(String sqlToExecute, StatementExecutionAudit statementAudit, int rowCount, LocalDateTime startTime) {
        statementAudit.setRowsProcessed(rowCount);
        statementAudit.setStatementContent(sqlToExecute);
        statementAudit.setLastModifiedDate(LocalDateTime.now());
        statementAudit.setTimeTaken(Duration.between(startTime, LocalDateTime.now()).toMillis() / 1000.0);

    }

    @NotNull
    private StatementExecutionAudit getStatementExecutionAudit(String sqlToExecute, LocalDateTime startTime) {
        StatementExecutionAudit statementAudit = new StatementExecutionAudit();
        statementAudit.setRootPipelineId(actionExecutionAudit.getRootPipelineId());
        statementAudit.setActionId(actionExecutionAudit.getActionId());
        statementAudit.setStatementContent(sqlToExecute);
        statementAudit.setCreatedBy(actionExecutionAudit.getCreatedBy());
        statementAudit.setLastModifiedBy(actionExecutionAudit.getLastModifiedBy());
        statementAudit.setCreatedDate(startTime);
        return statementAudit;
    }

    private void insertCompletionIntoStatementAudit(List<StatementExecutionAudit> statementExecutionAudits) {
        statementExecutionAudits.forEach(HandymanActorSystemAccess::insert);
    }


    @Override
    public boolean executeIf() {
        return transform.getCondition();
    }
}
