package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.node.ObjectNode;
import com.zaxxer.hikari.HikariDataSource;
import in.handyman.raven.core.audit.AuditService;
import in.handyman.raven.core.connection.ResourceAccess;
import in.handyman.raven.core.context.ActionContext;
import in.handyman.raven.core.util.ExceptionUtil;
import in.handyman.raven.core.util.UniqueID;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.LambdaAutowire;
import in.handyman.raven.lambda.LambdaExecution;
import in.handyman.raven.lib.model.Transform;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.MarkerManager;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLSyntaxErrorException;
import java.sql.Statement;

/**
 * Auto Generated By Raven
 */
@LambdaAutowire(
        lambdaName = "Transform"
)
@Log4j2
public class TransformAction implements LambdaExecution {

    private final ActionContext actionContext;
    private final Transform context;
    private final MarkerManager.Log4jMarker aMarker;

    public TransformAction(final ActionContext actionContext, final Object context) {
        this.context = (Transform) context;
        this.actionContext = actionContext;
        this.aMarker = new MarkerManager.Log4jMarker("Transform");
        this.actionContext.getDetailMap().putPOJO("context", context);
    }

    @Override
    public void execute() throws Exception {
        final String dbSrc = context.getOn();
        log.info("Transform action input variables id: {}, name: {}, source-database: {} ", actionContext.getLambdaId(), context.getName(), dbSrc);
        log.info("Sql input post parameter ingestion \n {}", context.getValue());
        final ObjectNode detailMap = actionContext.getDetailMap();
        final HikariDataSource hikariDataSource = ResourceAccess.rdbmsConn(dbSrc);
        try (final Connection connection = hikariDataSource.getConnection()) {
            connection.setAutoCommit(false);
            for (String givenQuery : context.getValue()) {
                var sqlWithoutQuotes = givenQuery.replaceAll("\"", "");
                var sqlList = sqlWithoutQuotes.split(";");
                for (var sql : sqlList) {
                    final String sqlToExecute = sql.trim();
                    if (!sqlToExecute.isEmpty()) {
                        log.info("Transform with id:{}, executing script {}", actionContext.getProcessId(), givenQuery);
                        final Long statementId = UniqueID.getId();
                        AuditService.insertStatementAudit(statementId, actionContext.getLambdaId(),
                                actionContext.getName(), actionContext.getProcessName());
                        try (final Statement stmt = connection.createStatement()) {
                            var rowCount = stmt.executeUpdate(sqlToExecute);
                            var warnings = ExceptionUtil.completeSQLWarning(stmt.getWarnings());
                            detailMap.put(sqlToExecute + ".count", rowCount);
                            detailMap.put(sqlToExecute + ".stmtCount", stmt.getUpdateCount());
                            detailMap.put(sqlToExecute + ".warnings", warnings);
                            AuditService.updateStatementAudit(statementId, rowCount, 0, sql, 1);
                            log.info(aMarker, "Transform id# {}, executed script {} rows returned {}", statementId.toString(), sqlToExecute, rowCount);
                            stmt.clearWarnings();
                        } catch (SQLSyntaxErrorException ex) {
                            log.error(aMarker, "Stopping execution, General Error executing sql for {} with for campaign {}", sql, ex);
                            detailMap.put(sqlToExecute + ".exception", ExceptionUtil.toString(ex));
                            throw new HandymanException("Process failed", ex);
                        } catch (SQLException ex) {
                            log.error(aMarker, "Continuing to execute, even though SQL Error executing sql for {} ", sql, ex);
                            detailMap.put(sqlToExecute + ".exception", ExceptionUtil.toString(ex));
                        } catch (Throwable ex) {
                            log.error(aMarker, "Stopping execution, General Error executing sql for {} with for campaign {}", sql, ex);
                            detailMap.put(sqlToExecute + ".exception", ExceptionUtil.toString(ex));
                            throw new HandymanException("Process failed", ex);
                        }
                    }
                }
                connection.commit();
                log.info(aMarker, "Completed Transform id#{}, name#{}, dbSrc#{}, sqlList#{}", actionContext.getProcessId(), actionContext.getName()
                        , dbSrc, sqlList);
            }
        } catch (SQLException ex) {
            log.error(aMarker, "Stopping execution, Fetching connection failed", ex);
            detailMap.put("connection.exception", ExceptionUtil.toString(ex));
            throw new HandymanException("Process failed", ex);
        }
    }


    @Override
    public boolean executeIf() {
        return context.getCondition();
    }
}
