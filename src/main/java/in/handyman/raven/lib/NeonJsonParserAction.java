package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.NeonJsonParser;
import in.handyman.raven.lib.model.kvp.neon.jsonparser.NeonJsonParsedResponse;
import in.handyman.raven.lib.model.kvp.neon.jsonparser.NeonJsonQueryInputTable;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "NeonJsonParser"
)
public class NeonJsonParserAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final NeonJsonParser neonJsonParser;
  public static final String READ_BATCH_SIZE = "read.batch.size";
  public static final String WRITE_BATCH_SIZE = "write.batch.size";
  private final Marker aMarker;


  public NeonJsonParserAction(final ActionExecutionAudit action, final Logger log,
                                 final Object neonJsonParser) {
    this.neonJsonParser = (NeonJsonParser) neonJsonParser;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" NeonJsonParser:" + this.neonJsonParser.getName());

  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(neonJsonParser.getResourceConn());
      jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
      log.info(aMarker, "Neon json parser action {} has been started ", neonJsonParser.getName());

      final String insertQuery = "INSERT INTO " + neonJsonParser.getOutputTable() +
              "(created_on,created_user_id, last_updated_on, last_updated_user_id,sor_container_name,sor_item_name, answer, paper_no, " +
              "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
              "extracted_image_unit, image_dpi, image_height, image_width) "
              + " VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?  ,?,?,?,?)";
      log.info(aMarker, "Neon json parser insert query {}", insertQuery);

      final String selectQuery = neonJsonParser.getQuerySet();
      List<NeonJsonQueryInputTable> inputTableList = jdbi.withHandle(handle -> handle.createQuery(selectQuery)
              .mapToBean(NeonJsonQueryInputTable.class)
              .list());

      ObjectMapper objectMapper = new ObjectMapper();

      jdbi.useTransaction(handle -> {
        for (NeonJsonQueryInputTable inputTable : inputTableList) {
          String jsonResponse = inputTable.getResponse();
          JsonNode rootNode = objectMapper.readTree(jsonResponse);
          List<NeonJsonParsedResponse> innerParsedResponses = new ArrayList<>();
          parseJsonNode(rootNode, "", "", innerParsedResponses);
          for (NeonJsonParsedResponse parsedResponse : innerParsedResponses) {
            handle.createUpdate(insertQuery)
                    .bind(0, Timestamp.valueOf(LocalDateTime.now()))
                    .bind(1, inputTable.getTenantId())
                    .bind(2, Timestamp.valueOf(LocalDateTime.now()))
                    .bind(3, inputTable.getTenantId())
                    .bind(4, parsedResponse.getSorContainerName())
                    .bind(5, parsedResponse.getSorItemName())
                    .bind(6, parsedResponse.getAnswer())
                    .bind(7, inputTable.getPaperNo())
                    .bind(8, inputTable.getOriginId())
                    .bind(9, inputTable.getGroupId())
                    .bind(10, inputTable.getTenantId())
                    .bind(11, inputTable.getRootPipelineId())
                    .bind(12, inputTable.getBatchId())
                    .bind(13, inputTable.getModelRegistry())
                    .bind(14, inputTable.getExtractedImageUnit())
                    .bind(15, inputTable.getImageDpi())
                    .bind(16, inputTable.getImageHeight())
                    .bind(17, inputTable.getImageWidth())
                    .execute();

          }
        }

      });


      log.info(aMarker, " Neon json parser actionhas been completed {}  ", neonJsonParser.getName());
    } catch (Exception e) {
      action.getContext().put(neonJsonParser.getName() + ".isSuccessful", "false");
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("error in execute method for Neon json parser action", handymanException, action);

    }
  }

  private void parseJsonNode(JsonNode rootNode, String currentKey, String parentPath, List<NeonJsonParsedResponse> parsedResponses) {
    if (rootNode.isObject()) {
      Iterator<Map.Entry<String, JsonNode>> fields = rootNode.fields();
      while (fields.hasNext()) {
        Map.Entry<String, JsonNode> field = fields.next();
        String key = field.getKey();
        String newCurrentKey = key;
        String newParentPath = parentPath.isEmpty() ? currentKey : parentPath + ", " + currentKey;
        parseJsonNode(field.getValue(), newCurrentKey, newParentPath, parsedResponses);
      }
    } else if (rootNode.isArray()) {
      for (JsonNode arrayElement : rootNode) {
        parseJsonNode(arrayElement, currentKey, parentPath, parsedResponses);
      }
    } else {
      NeonJsonParsedResponse parsedResponse = NeonJsonParsedResponse.builder()
              .sorContainerName(parentPath)
              .sorItemName(currentKey)
              .answer(rootNode.asText())
              .build();
      parsedResponses.add(parsedResponse);
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return neonJsonParser.getCondition();
  }
}
