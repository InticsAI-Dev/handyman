package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.lib.model.PostProcessingExecutor;
import in.handyman.raven.lib.model.scalar.ValidatorByBeanShellExecutor;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "PostProcessingExecutor"
)
public class PostProcessingExecutorAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final PostProcessingExecutor postProcessingExecutor;

    private final Marker aMarker;

    private List<PostProcessingExecutorInput> postProcessingExecutorInputs = new ArrayList<>();
    private static final String POST_PROCESSING_THREAD_COUNT = "post.processing.thread.count";

    public PostProcessingExecutorAction(final ActionExecutionAudit action, final Logger log,
                                        final Object postProcessingExecutor) {
        this.postProcessingExecutor = (PostProcessingExecutor) postProcessingExecutor;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" PostProcessingExecutor:" + this.postProcessingExecutor.getName());
    }

    @Override
    public void execute() throws Exception {
        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(postProcessingExecutor.getResourceConn());
        InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action,log);
        int postProcessingThreadCount = Integer.parseInt(action.getContext().getOrDefault(POST_PROCESSING_THREAD_COUNT, "10"));

        String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
        boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

        Long groupId = Long.valueOf(postProcessingExecutor.getGroupId());
        String batchId = postProcessingExecutor.getBatchId();

        String outputTableName = postProcessingExecutor.getOutputTable();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(postProcessingExecutor.getQuerySet());
            AtomicInteger i = new AtomicInteger(0);
            for (String sqlToExecute : formattedQuery) {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<PostProcessingExecutorInput> resultIterable = query.mapToBean(PostProcessingExecutorInput.class);
                List<PostProcessingExecutorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                postProcessingExecutorInputs.addAll(processingExecutorInputs);
                log.info(aMarker, "executed query from index {}", i.get());
            }
        });

        log.info("Post processing Executor action total rows returned from the query {}", postProcessingExecutorInputs.size());

        // Batch decryption
        decryptPostProcessingInputs(postProcessingExecutorInputs, encryption, pipelineEndToEndEncryptionActivator);

        ValidatorByBeanShellExecutor validatorByBeanShellExecutor = new ValidatorByBeanShellExecutor(postProcessingExecutorInputs, action, log, postProcessingThreadCount);
        log.info("Starting the post processing for row wise details");
        postProcessingExecutorInputs = validatorByBeanShellExecutor.doRowWiseValidator();
        log.info("Completed the post processing for row wise details");
        log.info("Updated validator configuration details of size {}", postProcessingExecutorInputs.size());

        // Batch re-encryption
        reEncryptPostProcessingInputs(postProcessingExecutorInputs, encryption, pipelineEndToEndEncryptionActivator, log);

        consumerBatch(jdbi, postProcessingExecutorInputs, outputTableName, batchId, groupId);
    }

    private void decryptPostProcessingInputs(List<PostProcessingExecutorInput> inputs, InticsIntegrity encryption, boolean encryptionEnabled) {
        List<EncryptionRequestClass> decryptRequests = new ArrayList<>();
        List<Integer> indexes = new ArrayList<>();

        for (int i = 0; i < inputs.size(); i++) {
            PostProcessingExecutorInput input = inputs.get(i);
            if (encryptionEnabled && "t".equalsIgnoreCase(input.getIsEncrypted())) {
                decryptRequests.add(new EncryptionRequestClass(
                        input.getEncryptionPolicy(),
                        input.getExtractedValue(),
                        input.getSorItemName()
                ));
                indexes.add(i);
            }
        }

        List<EncryptionRequestClass> decryptedValues = batchDecryptValues(decryptRequests,encryption);

        for (int i = 0; i < indexes.size(); i++) {
            inputs.get(indexes.get(i)).setExtractedValue(decryptedValues.get(i).getValue());
        }
    }

    private void reEncryptPostProcessingInputs(List<PostProcessingExecutorInput> inputs, InticsIntegrity encryption, boolean encryptionEnabled, Logger log) {
        List<EncryptionRequestClass> encryptRequests = new ArrayList<>();
        List<Integer> indexes = new ArrayList<>();

        // For multi_value items, we need to remember which input and index within multi-value
        List<MultiValueEncryptionMetadata> multiValueMetaList = new ArrayList<>();

        for (int i = 0; i < inputs.size(); i++) {
            PostProcessingExecutorInput input = inputs.get(i);
            String value = input.getExtractedValue();

            if ("multi_value".equalsIgnoreCase(input.getLineItemType())) {
                if (encryptionEnabled && "t".equalsIgnoreCase(input.getIsEncrypted())) {
                    try {
                        String[] multivalue = value.split(",");
                        for (int j = 0; j < multivalue.length; j++) {
                            String val = multivalue[j].trim();
                            EncryptionRequestClass request = new EncryptionRequestClass( input.getEncryptionPolicy() ,val,input.getSorItemName());
                            encryptRequests.add(request);
                            multiValueMetaList.add(new MultiValueEncryptionMetadata(i, j));
                        }
                    } catch (Exception e) {
                        log.error("Error preparing multi_value encryption for {}: {}", input.getSorItemName(), e.getMessage(), e);
                        throw e;
                    }
                } else {
                    log.info("Encryption not required for multi_value item: {}. Setting original extracted value.", input.getSorItemName());
                    input.setExtractedValue(value);
                }
            } else {
                if (encryptionEnabled && "t".equalsIgnoreCase(input.getIsEncrypted())) {
                    encryptRequests.add(new EncryptionRequestClass(input.getEncryptionPolicy() ,value, input.getSorItemName()));
                    indexes.add(i);
                }
            }
        }

        // One-time batch encrypt
        List<EncryptionRequestClass> encryptedValues = batchEncryptValues(encryptRequests, encryption);

        // Reconstruct encrypted values
        int encryptedIndex = 0;
        for (MultiValueEncryptionMetadata meta : multiValueMetaList) {
            PostProcessingExecutorInput input = inputs.get(meta.getInputIndex());
            String[] currentValues = input.getExtractedValue().split(",");
            currentValues[meta.getValueIndex()] = encryptedValues.get(encryptedIndex++).getValue();
            input.setExtractedValue(String.join(",", currentValues));
        }

        for (int i = 0; i < indexes.size(); i++) {
            inputs.get(indexes.get(i)).setExtractedValue(encryptedValues.get(encryptedIndex++).getValue());
        }
    }


    public static List<EncryptionRequestClass> batchDecryptValues(List<EncryptionRequestClass> requests, InticsIntegrity encryption) {
        return encryption.decrypt(requests);
    }

    public static List<EncryptionRequestClass> batchEncryptValues(List<EncryptionRequestClass> requests, InticsIntegrity encryption) {
        return encryption.encrypt(requests);
    }


    void consumerBatch(final Jdbi jdbi, List<PostProcessingExecutorInput> resultQueue, final String outputTableName, String batchId, Long groupId) {
        String createdUserId = action.getContext().get("created_user_id");
        try {
            resultQueue.forEach(insert -> jdbi.useTransaction(handle -> {
                try {
                    String columnList = "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, aggregated_score, masked_score, group_id, origin_id, paper_no, predicted_value, vqa_score," +
                            "rank, sor_item_attribution_id, sor_item_name, document_id, acc_transaction_id, b_box, root_pipeline_id, frequency, question_id, synonym_id, model_registry, batch_id";

                    String columnBindedList = "now(), :createdUserId, now(), :createdUserId, :tenantId, :aggregatedScore, :maskedScore, :groupId, :originId, :paperNo, :predictedValue, :vqaScore," +
                            ":rank, :sorItemAttributionId, :sorItemName, :documentId , :accTransactionId, :bbox, :rootPipelineId, :frequency, :questionId, :synonymId, :modelRegistry, :batchId";

                    Update update = handle.createUpdate("INSERT INTO " + outputTableName +
                            " (" + columnList + ") " +
                            " VALUES(" + columnBindedList + ")");

                    update.bind("createdUserId", createdUserId);
                    update.bind("tenantId", insert.getTenantId());
                    update.bind("aggregatedScore", insert.getAggregatedScore());
                    update.bind("maskedScore", insert.getMaskedScore());
                    update.bind("originId", insert.getOriginId());
                    update.bind("paperNo", insert.getPaperNo());
                    update.bind("predictedValue", insert.getExtractedValue());
                    update.bind("vqaScore", insert.getVqaScore());
                    update.bind("rank", insert.getRank());
                    update.bind("sorItemAttributionId", insert.getSorItemAttributionId());
                    update.bind("sorItemName", insert.getSorItemName());
                    update.bind("documentId", insert.getDocumentId());
                    update.bind("accTransactionId", insert.getAccTransactionId());
                    update.bind("bbox", insert.getBbox());
                    update.bind("rootPipelineId", insert.getRootPipelineId());
                    update.bind("frequency", insert.getFrequency());
                    update.bind("questionId", insert.getQuestionId());
                    update.bind("synonymId", insert.getSynonymId());
                    update.bind("modelRegistry", insert.getModelRegistry());
                    update.bind("batchId", batchId);
                    update.bind("groupId", groupId);

                    update.execute();
                } catch (Exception t) {
                    log.error(aMarker, "Error inserting result {} and {}", insert.getOriginId(), insert.getSorItemName(), t);
                    HandymanException handymanException = new HandymanException(t);
                    HandymanException.insertException("Exception occurred in Post Processing consumer batch insert into adapter result for groupId " + groupId + " origin Id " + insert.getOriginId() + " paper No " + insert.getPaperNo(), handymanException, action);
                }
            }));
        } catch (Exception t) {
            log.error(aMarker, "Error inserting result {}", resultQueue, t);
            HandymanException handymanException = new HandymanException(t);
            HandymanException.insertException("Exception occurred in Post Processing consumer batch insert into adapter result", handymanException, action);
        }
    }


    @Override
    public boolean executeIf() throws Exception {
        return postProcessingExecutor.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class PostProcessingExecutorInput {
        private Long tenantId;
        private double aggregatedScore;
        private double maskedScore;
        private String originId;
        private Integer paperNo;
        private String extractedValue;
        private double vqaScore;
        private Integer rank;
        private Integer sorItemAttributionId;
        private String sorItemName;
        private String documentId;
        private Long accTransactionId;
        private String bbox;
        private Long rootPipelineId;
        private Long frequency;
        private Long questionId;
        private Long synonymId;
        private String modelRegistry;
        private String encryptionPolicy;
        private String isEncrypted;
        private String lineItemType;
    }


    @AllArgsConstructor
    @Data
    private static class MultiValueEncryptionMetadata {
        private int inputIndex;
        private int valueIndex;
    }
}
