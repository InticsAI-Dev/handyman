package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.lib.model.PostProcessingExecutor;
import in.handyman.raven.lib.model.scalar.ValidatorByBeanShellExecutor;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "PostProcessingExecutor"
)
public class PostProcessingExecutorAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final PostProcessingExecutor postProcessingExecutor;

    private final Marker aMarker;

    private List<PostProcessingExecutorInput> postProcessingExecutorInputs = new ArrayList<>();


    public PostProcessingExecutorAction(final ActionExecutionAudit action, final Logger log,
                                        final Object postProcessingExecutor) {
        this.postProcessingExecutor = (PostProcessingExecutor) postProcessingExecutor;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" PostProcessingExecutor:" + this.postProcessingExecutor.getName());
    }

    @Override
    public void execute() throws Exception {
        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(postProcessingExecutor.getResourceConn());
        InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action,log);

        String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
        boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

        Long groupId = Long.valueOf(postProcessingExecutor.getGroupId());
        String batchId = postProcessingExecutor.getBatchId();

        String outputTableName = postProcessingExecutor.getOutputTable();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(postProcessingExecutor.getQuerySet());
            AtomicInteger i = new AtomicInteger(0);
            for (String sqlToExecute : formattedQuery) {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<PostProcessingExecutorInput> resultIterable = query.mapToBean(PostProcessingExecutorInput.class);
                List<PostProcessingExecutorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                postProcessingExecutorInputs.addAll(processingExecutorInputs);
                log.info(aMarker, "executed query from index {}", i.get());
            }
        });
        log.info("Post processing Executor action total rows returned from the query {}",postProcessingExecutorInputs.size());
        List<EncryptionRequestClass> decryptRequestList = new ArrayList<>();
       // Map<String, PostProcessingExecutorInput> decryptMapping = new HashMap<>();

        for (PostProcessingExecutorInput input : postProcessingExecutorInputs) {
            if (pipelineEndToEndEncryptionActivator && Objects.equals(input.getIsEncrypted(), "t")) {
                decryptRequestList.add(new EncryptionRequestClass(
                        input.getEncryptionPolicy(),
                        input.getExtractedValue(),
                        input.getSorItemName()
                ));
            }
        }

// Step 2: Decrypt once
        List<EncryptionRequestClass> decryptedResults = encryption.decrypt(decryptRequestList);

        // Step 3: Map decrypted results back
        int decryptedIndex=0;
        for (PostProcessingExecutorInput input : postProcessingExecutorInputs) {
            if (decryptedIndex < decryptedResults.size()) {
                EncryptionRequestClass decryptedItem = decryptedResults.get(decryptedIndex++);
                input.setExtractedValue(decryptedItem.getValue());
            }
        }

        ValidatorByBeanShellExecutor validatorByBeanShellExecutor = new ValidatorByBeanShellExecutor(postProcessingExecutorInputs, action, log);
        log.info("Starting the post processing for row wise details");
        postProcessingExecutorInputs = validatorByBeanShellExecutor.doRowWiseValidator();
        log.info("Completed the post processing for row wise details");
        log.info("Updated validator configuration details of size {}", postProcessingExecutorInputs.size());

//        postProcessingExecutorInputs.forEach(postProcessingExecutorInput -> {
//            String extractedValue = postProcessingExecutorInput.getExtractedValue();
//            String encryptionPolicy = postProcessingExecutorInput.getEncryptionPolicy();
//            if (Objects.equals(postProcessingExecutorInput.getLineItemType(), "multi_value")) {
//                log.debug("Processing multi_value lineItemType for SOR item: {}", postProcessingExecutorInput.getSorItemName());
//                if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(postProcessingExecutorInput.getIsEncrypted())) {
//                    log.info("Decryption and re-encryption enabled for multi_value item: {}", postProcessingExecutorInput.getSorItemName());
//                    try {
//                        String[] multivalue = extractedValue.split(",");
//                        List<String> encryptMultiValue = new ArrayList<>();
//                        for (int i = 0; i < multivalue.length; i++) {
//                            String trimmedValue = multivalue[i].trim();
//                            String encryptedValue = encryption.encrypt(trimmedValue, encryptionPolicy, postProcessingExecutorInput.getSorItemName());
//                            encryptMultiValue.add(encryptedValue);
//                        }
//                        String finalOutput = String.join(",", encryptMultiValue);
//                        log.debug("Final re-encrypted multi_value string for {}: ", postProcessingExecutorInput.getSorItemName());
//                        postProcessingExecutorInput.setExtractedValue(finalOutput);
//                    } catch (Exception e) {
//                        log.error("Error processing multi_value encryption for {}: {}", postProcessingExecutorInput.getSorItemName(), e.getMessage(), e);
//                        throw e;
//                    }
//                } else {
//                    log.info("Encryption not required for multi_value item: {}. Setting original extracted value.", postProcessingExecutorInput.getSorItemName());
//                    postProcessingExecutorInput.setExtractedValue(extractedValue);
//                }
//            }
//            else {
//                if (pipelineEndToEndEncryptionActivator && Objects.equals(postProcessingExecutorInput.getIsEncrypted(), "t")) {
//                    postProcessingExecutorInput.setExtractedValue(encryption.encrypt(extractedValue, encryptionPolicy, postProcessingExecutorInput.getSorItemName()));
//                }
//            }
//        });


        List<EncryptionRequestClass> encryptRequestList = new ArrayList<>();
        Map<String, PostProcessingExecutorInput> singleValueMap = new HashMap<>();
        Map<String, List<String>> multiValueTempStore = new HashMap<>();
        Map<String, Integer> multiValueSizeMap = new HashMap<>();

// Step 1: Build encryption request list
        for (PostProcessingExecutorInput input : postProcessingExecutorInputs) {
            String extractedValue = input.getExtractedValue();
            String encryptionPolicy = input.getEncryptionPolicy();
            String sorItemName = input.getSorItemName();

            if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(input.getIsEncrypted())) {
                if ("multi_value".equals(input.getLineItemType())) {
                    log.debug("Processing multi_value lineItemType for SOR item: {}", sorItemName);
                    String[] values = extractedValue.split(",");
                    multiValueSizeMap.put(sorItemName, values.length); // keep count for reconstruction
                    for (int i = 0; i < values.length; i++) {
                        String trimmed = values[i].trim();
                        String key = sorItemName + ":" + i;
                        encryptRequestList.add(new EncryptionRequestClass(encryptionPolicy,trimmed, key));

                        // associate back for reconstruction
                        multiValueTempStore.computeIfAbsent(sorItemName, k -> new ArrayList<>());
                    }
                } else {
                    encryptRequestList.add(new EncryptionRequestClass(encryptionPolicy,extractedValue, sorItemName));
                    singleValueMap.put(sorItemName, input);
                }
            }
        }

// Step 2: Encrypt in batch
        List<EncryptionRequestClass> encryptedResults = encryption.encrypt(encryptRequestList);

// Step 3: Map encrypted results back
        for (EncryptionRequestClass encrypted : encryptedResults) {
            String policy = encrypted.getPolicy(); // this will be either `sorItemName` or `sorItemName:index`
            String encryptedValue = encrypted.getValue();

            if (policy.contains(":")) {
                // handle multi_value
                String sorItemName = policy.split(":")[0];
                multiValueTempStore.get(sorItemName).add(encryptedValue);
            } else {
                // single value
                PostProcessingExecutorInput input = singleValueMap.get(policy);
                if (input != null) {
                    input.setExtractedValue(encryptedValue);
                }
            }
        }

// Step 4: Set final re-joined encrypted value for multi_value items
        for (PostProcessingExecutorInput input : postProcessingExecutorInputs) {
            if ("multi_value".equals(input.getLineItemType())
                    && pipelineEndToEndEncryptionActivator
                    && "t".equalsIgnoreCase(input.getIsEncrypted())) {

                List<String> encryptedList = multiValueTempStore.get(input.getSorItemName());
                if (encryptedList != null && !encryptedList.isEmpty()) {
                    String finalOutput = String.join(",", encryptedList);
                    input.setExtractedValue(finalOutput);
                } else {
                    // fallback: keep original value
                    input.setExtractedValue(input.getExtractedValue());
                }
            }
        }


        consumerBatch(jdbi, postProcessingExecutorInputs, outputTableName, batchId, groupId);
    }


    void consumerBatch(final Jdbi jdbi, List<PostProcessingExecutorInput> resultQueue, final String outputTableName, String batchId, Long groupId) {
        String createdUserId = action.getContext().get("created_user_id");
        try {
            resultQueue.forEach(insert -> jdbi.useTransaction(handle -> {
                try {
                    String columnList = "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, aggregated_score, masked_score, group_id, origin_id, paper_no, predicted_value, vqa_score," +
                            "rank, sor_item_attribution_id, sor_item_name, document_id, acc_transaction_id, b_box, root_pipeline_id, frequency, question_id, synonym_id, model_registry, batch_id";

                    String columnBindedList = "now(), :createdUserId, now(), :createdUserId, :tenantId, :aggregatedScore, :maskedScore, :groupId, :originId, :paperNo, :predictedValue, :vqaScore," +
                            ":rank, :sorItemAttributionId, :sorItemName, :documentId , :accTransactionId, :bbox, :rootPipelineId, :frequency, :questionId, :synonymId, :modelRegistry, :batchId";

                    Update update = handle.createUpdate("INSERT INTO " + outputTableName +
                            " (" + columnList + ") " +
                            " VALUES(" + columnBindedList + ")");

                    update.bind("createdUserId", createdUserId);
                    update.bind("tenantId", insert.getTenantId());
                    update.bind("aggregatedScore", insert.getAggregatedScore());
                    update.bind("maskedScore", insert.getMaskedScore());
                    update.bind("originId", insert.getOriginId());
                    update.bind("paperNo", insert.getPaperNo());
                    update.bind("predictedValue", insert.getExtractedValue());
                    update.bind("vqaScore", insert.getVqaScore());
                    update.bind("rank", insert.getRank());
                    update.bind("sorItemAttributionId", insert.getSorItemAttributionId());
                    update.bind("sorItemName", insert.getSorItemName());
                    update.bind("documentId", insert.getDocumentId());
                    update.bind("accTransactionId", insert.getAccTransactionId());
                    update.bind("bbox", insert.getBbox());
                    update.bind("rootPipelineId", insert.getRootPipelineId());
                    update.bind("frequency", insert.getFrequency());
                    update.bind("questionId", insert.getQuestionId());
                    update.bind("synonymId", insert.getSynonymId());
                    update.bind("modelRegistry", insert.getModelRegistry());
                    update.bind("batchId", batchId);
                    update.bind("groupId", groupId);

                    update.execute();
                } catch (Exception t) {
                    log.error(aMarker, "Error inserting result {} and {}", insert.getOriginId(), insert.getSorItemName(), t);
                    HandymanException handymanException = new HandymanException(t);
                    HandymanException.insertException("Exception occurred in Post Processing consumer batch insert into adapter result for groupId " + groupId + " origin Id " + insert.getOriginId() + " paper No " + insert.getPaperNo(), handymanException, action);
                }
            }));
        } catch (Exception t) {
            log.error(aMarker, "Error inserting result {}", resultQueue, t);
            HandymanException handymanException = new HandymanException(t);
            HandymanException.insertException("Exception occurred in Post Processing consumer batch insert into adapter result", handymanException, action);
        }
    }


    @Override
    public boolean executeIf() throws Exception {
        return postProcessingExecutor.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class PostProcessingExecutorInput {
        private Long tenantId;
        private double aggregatedScore;
        private double maskedScore;
        private String originId;
        private Integer paperNo;
        private String extractedValue;
        private double vqaScore;
        private Integer rank;
        private Integer sorItemAttributionId;
        private String sorItemName;
        private String documentId;
        private Long accTransactionId;
        private String bbox;
        private Long rootPipelineId;
        private Long frequency;
        private Long questionId;
        private Long synonymId;
        private String modelRegistry;
        private String encryptionPolicy;
        private String isEncrypted;
        private String lineItemType;
    }
}
