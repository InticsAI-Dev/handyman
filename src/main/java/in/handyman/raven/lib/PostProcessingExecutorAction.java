package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.PostProcessingExecutor;
import in.handyman.raven.lib.model.scalar.ValidatorByBeanShellExecutor;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "PostProcessingExecutor"
)
public class PostProcessingExecutorAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final PostProcessingExecutor postProcessingExecutor;

    private final Marker aMarker;

    private List<PostProcessingExecutorInput> postProcessingExecutorInputs = new ArrayList<>();


    public PostProcessingExecutorAction(final ActionExecutionAudit action, final Logger log,
                                        final Object postProcessingExecutor) {
        this.postProcessingExecutor = (PostProcessingExecutor) postProcessingExecutor;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" PostProcessingExecutor:" + this.postProcessingExecutor.getName());
    }

    @Override
    public void execute() throws Exception {
        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(postProcessingExecutor.getResourceConn());

        Long groupId = Long.valueOf(postProcessingExecutor.getGroupId());
        String batchId = postProcessingExecutor.getBatchId();

        String outputTableName = postProcessingExecutor.getOutputTable();

        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(postProcessingExecutor.getQuerySet());
            AtomicInteger i = new AtomicInteger(0);
            for (String sqlToExecute : formattedQuery) {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<PostProcessingExecutorInput> resultIterable = query.mapToBean(PostProcessingExecutorInput.class);
                List<PostProcessingExecutorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                postProcessingExecutorInputs.addAll(processingExecutorInputs);
                log.info(aMarker, "executed query from index {}", i.get());
            }
        });

        ValidatorByBeanShellExecutor validatorByBeanShellExecutor = new ValidatorByBeanShellExecutor(postProcessingExecutorInputs, action, jdbi, log);
        log.info("Starting the post processing for row wise details");
        postProcessingExecutorInputs = validatorByBeanShellExecutor.doRowWiseValidator();
        log.info("Completed the post processing for row wise details");
        log.info("Updated validator configuration details of size {}", postProcessingExecutorInputs.size());

        consumerBatch(jdbi, postProcessingExecutorInputs, outputTableName, batchId, groupId);
    }


    void consumerBatch(final Jdbi jdbi, List<PostProcessingExecutorInput> resultQueue, final String outputTableName, String batchId, Long groupId) {
        String createdUserId = action.getContext().get("created_user_id");
        try {
            resultQueue.forEach(insert -> jdbi.useTransaction(handle -> {
                try {
                    String columnList = "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, aggregated_score, masked_score, group_id, origin_id, paper_no, predicted_value, vqa_score," +
                            "rank, sor_item_attribution_id, sor_item_name, document_id, acc_transaction_id, b_box, root_pipeline_id, frequency, question_id, synonym_id, model_registry, batch_id";

                    String columnBindedList = "now(), :createdUserId, now(), :createdUserId, :tenantId, :aggregatedScore, :maskedScore, :groupId, :originId, :paperNo, :predictedValue, :vqaScore," +
                            ":rank, :sorItemAttributionId, :sorItemName, :documentId , :accTransactionId, :bbox, :rootPipelineId, :frequency, :questionId, :synonymId, :modelRegistry, :batchId";

                    Update update = handle.createUpdate("INSERT INTO " + outputTableName +
                            " (" + columnList + ") " +
                            " VALUES(" + columnBindedList + ")");

                    update.bind("createdUserId", createdUserId);
                    update.bind("tenantId", insert.getTenantId());
                    update.bind("aggregatedScore", insert.getAggregatedScore());
                    update.bind("maskedScore", insert.getMaskedScore());
                    update.bind("originId", insert.getOriginId());
                    update.bind("paperNo", insert.getPaperNo());
                    update.bind("predictedValue", insert.getExtractedValue());
                    update.bind("vqaScore", insert.getVqaScore());
                    update.bind("rank", insert.getRank());
                    update.bind("sorItemAttributionId", insert.getSorItemAttributionId());
                    update.bind("sorItemName", insert.getSorItemName());
                    update.bind("documentId", insert.getDocumentId());
                    update.bind("accTransactionId", insert.getAccTransactionId());
                    update.bind("bbox", insert.getBbox());
                    update.bind("rootPipelineId", insert.getRootPipelineId());
                    update.bind("frequency", insert.getFrequency());
                    update.bind("questionId", insert.getQuestionId());
                    update.bind("synonymId", insert.getSynonymId());
                    update.bind("modelRegistry", insert.getModelRegistry());
                    update.bind("batchId", batchId);
                    update.bind("groupId", groupId);

                    update.execute();
                } catch (Exception t) {
                    log.error(aMarker, "Error inserting result {} and {}", insert.getOriginId(), insert.getSorItemName(), t);
                    HandymanException handymanException = new HandymanException(t);
                    HandymanException.insertException("Exception occurred in Post Processing consumer batch insert into adapter result for groupId " + groupId, handymanException, action);
                }
            }));
        } catch (Exception t) {
            log.error(aMarker, "Error inserting result {}", resultQueue, t);
            HandymanException handymanException = new HandymanException(t);
            HandymanException.insertException("Exception occurred in Post Processing consumer batch insert into adapter result", handymanException, action);
        }
    }

    @Override
    public boolean executeIf() throws Exception {
        return postProcessingExecutor.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class PostProcessingExecutorInput {
        private Long tenantId;
        private double aggregatedScore;
        private double maskedScore;
        private String originId;
        private Integer paperNo;
        private String extractedValue;
        private double vqaScore;
        private Integer rank;
        private Integer sorItemAttributionId;
        private String sorItemName;
        private String documentId;
        private Long accTransactionId;
        private String bbox;
        private Long rootPipelineId;
        private Long frequency;
        private Long questionId;
        private Long synonymId;
        private String modelRegistry;
    }
}
