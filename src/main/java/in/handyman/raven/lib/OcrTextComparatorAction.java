package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.OcrTextComparator;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.text.similarity.FuzzyScore;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "OcrTextComparator"
)
public class OcrTextComparatorAction implements IActionExecution {
    private static final String AES_256 = "AES256";
    private final ActionExecutionAudit action;
    private final Logger log;
    private final OcrTextComparator ocrTextComparator;
    private final Marker aMarker;
    private final List<OcrTextComparatorInput> ocrTextComparatorInputs = new ArrayList<>();
    private static final Pattern COMMON_PATTERN = Pattern.compile(
            "(" +
                    "\\b[A-Z][a-zA-Z]+\\s+[A-Z][a-zA-Z]+\\b" +                       // NAME_PATTERN
                    "|" +
                    "\\d+\\s+[A-Za-z0-9\\s]+(?:Street|St|Avenue|Ave|Road|Rd|Lane|Ln|Drive|Dr|Blvd)\\b" + // ADDRESS_PATTERN
                    "|" +
                    "\\b[A-Z0-9]{5,15}\\b" +                                         // MEMBER_ID_PATTERN
                    ")",
            Pattern.CASE_INSENSITIVE
    );

    public OcrTextComparatorAction(final ActionExecutionAudit action, final Logger log,
                                   final Object ocrTextComparator) {
        this.ocrTextComparator = (OcrTextComparator) ocrTextComparator;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("OcrTextComparator:" + this.ocrTextComparator.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ocrTextComparator.getResourceConn());
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
            boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

            String batchId = ocrTextComparator.getBatchId();
            String outputTableName = ocrTextComparator.getOutputTable();
            int fuzzyMatchThreshold = Integer.parseInt(action.getContext().getOrDefault("fuzzy.match.threshold", "70"));

            // Execute queries and collect input data
            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(ocrTextComparator.getQuerySet());
                for (int i = 0; i < formattedQuery.size(); i++) {
                    String sqlToExecute = formattedQuery.get(i);
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i);
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<OcrTextComparatorInput> resultIterable = query.mapToBean(OcrTextComparatorInput.class);
                    List<OcrTextComparatorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                    ocrTextComparatorInputs.addAll(processingExecutorInputs);
                    log.info(aMarker, "Executed query from index {}", i);
                }
            });

            log.info(aMarker, "OCR text comparator action total rows returned from the query {}", ocrTextComparatorInputs.size());

            // Process the inputs to compare answer with OCR text
            try {
                doOcrTextComparison(ocrTextComparatorInputs, jdbi, outputTableName, pipelineEndToEndEncryptionActivator,
                        batchId, encryption, fuzzyMatchThreshold);
            } catch (Exception e) {
                log.error(aMarker, "OCR text comparison failed for batchId: {}", batchId, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("OCR text comparison failed", handymanException, action);
            }

            log.info(aMarker, "OCR text comparator action has been completed {}", ocrTextComparator.getName());

        } catch (Exception e) {
            action.getContext().put(ocrTextComparator.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for OCR text comparator", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("OCR text comparator failed", handymanException, action);
        }
    }

    private void doOcrTextComparison(List<OcrTextComparatorInput> inputs, Jdbi jdbi, String outputTable,
                                     boolean pipelineEndToEndEncryptionActivator, String batchId,
                                     InticsIntegrity encryption, int fuzzyMatchThreshold) throws Exception {
        log.info(aMarker, "Starting OCR text comparison process for batchId: {}, totalInputs: {}", batchId, inputs.size());

        // Track processed inputs
        List<String> processedKeys = new ArrayList<>();
        FuzzyScore fuzzyScore = new FuzzyScore(Locale.ENGLISH);

        // Process each input individually
        inputs.forEach(input -> {
            String key = input.getOriginId() + "|" + input.getSorItemName();
            synchronized (processedKeys) {
                processedKeys.add(key);
            }

            log.debug(aMarker, "Processing input: originId={}, sorItemName={}",
                    input.getOriginId(), input.getSorItemName());

            Integer selectedPageNo = input.getPaperNo();
            boolean isOcrFieldComparable = false;
            String answer = input.getAnswer(); // Use the input's answer
            String extractedText = input.getExtractedText();
            int bestScore = -1; // Track best fuzzy score
            String regexPattern = "COMMON_PATTERN"; // Track regex pattern used
            String candidatesList = ""; // Track candidates extracted

            Boolean isOcrFieldComparableValue = input.getIsOcrFieldComparable();
            if ("t".equalsIgnoreCase(String.valueOf(isOcrFieldComparableValue))) {
                log.debug(aMarker, "Performing OCR comparison for sorItemName={} (is_ocr_field_comparable='t')",
                        input.getSorItemName());

                // Decrypt extracted_text (AES256) and answer (policy-based) if needed
                if (pipelineEndToEndEncryptionActivator) {
                    try {
                        log.info(aMarker, "Decrypting extracted_text with AES256 and answer with policy for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                        extractedText = encryption.decrypt(extractedText, AES_256, input.getSorItemName());
                        answer = encryption.decrypt(answer, input.getEncryptionPolicy(), input.getSorItemName());
                        log.debug(aMarker, "Decrypted answer and extracted_text for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                    } catch (Exception e) {
                        log.error(aMarker, "Decryption failed for originId={}, sorItemName={}: {}",
                                input.getOriginId(), input.getSorItemName(), e.getMessage(), e);
                        return;
                    }
                }

                // Clean the answer and extracted_text
                answer = (answer == null) ? "" : answer.trim().replaceAll("(^,+|,+$)", "").replaceAll(",{2,}", ",");
                extractedText = (extractedText == null) ? "" : extractedText;

                // Use COMMON_PATTERN for all fields
                Pattern pattern = COMMON_PATTERN;

                // Extract candidates from extracted_text
                List<String> candidates = new ArrayList<>();
                Matcher matcher = pattern.matcher(extractedText);
                while (matcher.find()) {
                    candidates.add(matcher.group());
                }
                candidatesList = String.join(",", candidates); // Store candidates as comma-separated string

                if (!candidates.isEmpty() && !answer.isEmpty()) {
                    // Find the best match to check if answer is present in extracted_text
                    class MatchResult {
                        final String bestMatch;
                        final int bestScore;

                        MatchResult(String bestMatch, int bestScore) {
                            this.bestMatch = bestMatch;
                            this.bestScore = bestScore;
                        }
                    }

                    String finalAnswer = answer;
                    MatchResult matchResult = candidates.stream()
                            .map(candidate -> {
                                int score = fuzzyScore.fuzzyScore(finalAnswer, candidate); // Approximate ratio
                                return new MatchResult(candidate, score);
                            })
                            .reduce((a, b) -> a.bestScore > b.bestScore ? a : b)
                            .orElse(new MatchResult(null, -1));

                    bestScore = matchResult.bestScore;
                    String bestMatch = matchResult.bestMatch;

                    // Check if the best score meets the threshold (> 70 as per Python code)
                    if (bestScore > fuzzyMatchThreshold) {
                        isOcrFieldComparable = true;
                        // Use the OCR candidate if answer is present (score > 70)
                        answer = bestMatch;
                        log.debug(aMarker, "Answer present in extracted_text with score {} for originId={}, sorItemName={}",
                                bestScore, input.getOriginId(), input.getSorItemName());
                    } else {
                        isOcrFieldComparable = false;
                        // Use the original answer if not present or score <= 70
                        answer = input.getAnswer();
                        log.debug(aMarker, "Answer not present in extracted_text with sufficient score for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                    }
                } else {
                    isOcrFieldComparable = false;
                    // Use the original answer if no candidates or answer is empty
                    answer = input.getAnswer();
                    log.debug(aMarker, "No candidates or empty answer for originId={}, sorItemName={}",
                            input.getOriginId(), input.getSorItemName());
                }

                // Encrypt extracted_text (AES256) and answer (policy-based) if needed
                if (pipelineEndToEndEncryptionActivator) {
                    try {
                        log.info(aMarker, "Encrypting extracted_text with AES256 and answer with policy for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                        extractedText = encryption.encrypt(extractedText, AES_256, input.getSorItemName());
                        answer = encryption.encrypt(answer, input.getEncryptionPolicy(), input.getSorItemName());
                        candidatesList = candidatesList.isEmpty() ? candidatesList : encryption.encrypt(candidatesList, AES_256, input.getSorItemName());
                        log.info(aMarker, "Encrypted answer and extracted_text for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                    } catch (Exception e) {
                        log.error(aMarker, "Encryption failed for originId={}, sorItemName={}: {}",
                                input.getOriginId(), input.getSorItemName(), e.getMessage(), e);
                        return;
                    }
                }
            } else {
                log.debug(aMarker, "Skipping OCR comparison for originId={}, sorItemName={} as is_ocr_field_comparable is not 't'",
                        input.getOriginId(), input.getSorItemName());
                // Use original answer if comparison is skipped
                answer = input.getAnswer();
                isOcrFieldComparable = false;
                bestScore = -1;
                regexPattern = "NONE";
                candidatesList = "";
            }

            // Insert the result into the output table
            try {
                insertExecutionInfo(
                        jdbi, outputTable,
                        input.getOriginId(), input.getSorItemName(), input.getTenantId(), batchId,
                        input.getSorQuestion(), answer, isOcrFieldComparableValue, input.getGroupId(), selectedPageNo,
                        input.getVqaScore(), input.getScore(), input.getWeight(),
                        input.getSorItemAttributionId(), input.getDocumentId(), input.getBBox(),
                        input.getRootPipelineId(), input.getQuestionId(), input.getSynonymId(),
                        input.getModelRegistry(), input.getCategory(), extractedText,
                        fuzzyMatchThreshold, bestScore, regexPattern, candidatesList
                );

                log.info(aMarker, "Inserted result for originId={}, sorItemName={}, paperNo={}, isOcrFieldComparable={}, threshold={}, bestScore={}, regexPattern={}, candidates={}",
                        input.getOriginId(), input.getSorItemName(), selectedPageNo, isOcrFieldComparable,
                        fuzzyMatchThreshold, bestScore, regexPattern, candidatesList);
            } catch (HandymanException e) {
                log.error(aMarker, "Insert failed for originId={}, sorItemName={}, paperNo={}: {}",
                        input.getOriginId(), input.getSorItemName(), selectedPageNo, e.getMessage(), e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error inserting for originId " +
                        input.getOriginId() + ", sorItemName " + input.getSorItemName(), handymanException, null);
            }
        });

        // Log unprocessed inputs
        ocrTextComparatorInputs.stream()
                .filter(input -> !processedKeys.contains(input.getOriginId() + "|" + input.getSorItemName()))
                .forEach(input -> {
                    log.warn(aMarker, "Input not processed for originId={}, sorItemName={}",
                            input.getOriginId(), input.getSorItemName());
                });

        log.info(aMarker, "Completed OCR text comparison for batchId: {}", batchId);
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, String sorItemName, Long tenantId,
                                     String batchId, String sorQuestion, String answer, boolean isOcrFieldComparable,
                                     Integer groupId, Integer paperNo, Double vqaScore, Double score, Integer weight,
                                     Integer sorItemAttributionId, String documentId, String bBox, Long rootPipelineId,
                                     Long questionId, Long synonymId, String modelRegistry, String category,
                                     String extractedText, int threshold, int bestScore, String regexPattern,
                                     String candidatesList) {
        if (tenantId == null) {
            log.warn(aMarker, "tenantId is null for originId={}, sorItemName={}, setting to default 1", originId, sorItemName);
            tenantId = 1L;
        }
        Long finalTenantId = tenantId;
        jdbi.useHandle(handle -> handle.createUpdate(
                        "INSERT INTO " + outputTable + " (" +
                                "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                "origin_id, group_id, paper_no, sor_question, answer, vqa_score, score, weight, " +
                                "sor_item_attribution_id, sor_item_name, document_id, b_box, root_pipeline_id, " +
                                "question_id, synonym_id, model_registry, category, batch_id, is_ocr_field_comparable, " +
                                "extracted_text, threshold, best_score, regex_pattern, candidates" +
                                ") VALUES (" +
                                ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                ":originId, :groupId, :paperNo, :sorQuestion, :answer, :vqaScore, :score, :weight, " +
                                ":sorItemAttributionId, :sorItemName, :documentId, :bBox, :rootPipelineId, " +
                                ":questionId, :synonymId, :modelRegistry, :category, :batchId, :isOcrFieldComparable, " +
                                ":extractedText, :threshold, :bestScore, :regexPattern, :candidates" +
                                ");")
                .bind("createdOn", LocalDateTime.now())
                .bind("createdUserId", finalTenantId)
                .bind("lastUpdatedOn", LocalDateTime.now())
                .bind("lastUpdatedUserId", finalTenantId)
                .bind("tenantId", finalTenantId)
                .bind("originId", originId)
                .bind("groupId", groupId)
                .bind("paperNo", paperNo)
                .bind("sorQuestion", sorQuestion)
                .bind("answer", answer)
                .bind("vqaScore", vqaScore)
                .bind("score", score)
                .bind("weight", weight)
                .bind("sorItemAttributionId", sorItemAttributionId)
                .bind("sorItemName", sorItemName)
                .bind("documentId", documentId)
                .bind("bBox", bBox)
                .bind("rootPipelineId", rootPipelineId)
                .bind("questionId", questionId)
                .bind("synonymId", synonymId)
                .bind("modelRegistry", modelRegistry)
                .bind("category", category)
                .bind("batchId", batchId)
                .bind("isOcrFieldComparable", isOcrFieldComparable)
                .bind("extractedText", extractedText)
                .bind("threshold", threshold)
                .bind("bestScore", bestScore)
                .bind("regexPattern", regexPattern)
                .bind("candidates", candidatesList)
                .execute());
        log.info(aMarker, "Inserted comparison result for originId={}, sorItemName={}", originId, sorItemName);
    }

    @Override
    public boolean executeIf() throws Exception {
        return ocrTextComparator.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    public static class OcrTextComparatorInput {
        private String originId;
        private String sorItemName;
        private String sorQuestion;
        private String answer;
        private Long tenantId;
        private String batchId;
        private Integer groupId;
        private Integer paperNo;
        private Double vqaScore;
        private Double score;
        private Integer weight;
        private Integer sorItemAttributionId;
        private String documentId;
        private String bBox;
        private Long rootPipelineId;
        private Long questionId;
        private Long synonymId;
        private String modelRegistry;
        private String category;
        private Boolean isOcrFieldComparable;
        private String extractedText;
        private String encryptionPolicy;
    }
}