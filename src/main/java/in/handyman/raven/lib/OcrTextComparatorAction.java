package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.OcrTextComparator;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.text.similarity.FuzzyScore;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "OcrTextComparator"
)
public class OcrTextComparatorAction implements IActionExecution {
    private static final String AES_256 = "AES256";
    private final ActionExecutionAudit action;
    private final Logger log;
    private final OcrTextComparator ocrTextComparator;
    private final Marker aMarker;
    private final List<OcrTextComparatorInput> ocrTextComparatorInputs = new ArrayList<>();
    private static final Pattern NAME_PATTERN = Pattern.compile("\\b[A-Z][a-zA-Z]+\\s+[A-Z][a-zA-Z]+\\b");
    private static final Pattern ADDRESS_PATTERN = Pattern.compile(
            "\\d+\\s+[A-Za-z0-9\\s]+(?:Street|St|Avenue|Ave|Road|Rd|Lane|Ln|Drive|Dr|Blvd)\\b",
            Pattern.CASE_INSENSITIVE
    );
    private static final Pattern MEMBER_ID_PATTERN = Pattern.compile("\\b[A-Z0-9]{5,15}\\b");

    public OcrTextComparatorAction(final ActionExecutionAudit action, final Logger log,
                                   final Object ocrTextComparator) {
        this.ocrTextComparator = (OcrTextComparator) ocrTextComparator;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("OcrTextComparator:" + this.ocrTextComparator.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ocrTextComparator.getResourceConn());
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
            boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

            String batchId = ocrTextComparator.getBatchId();
            String outputTableName = ocrTextComparator.getOutputTable();
            int fuzzyMatchThreshold = Integer.parseInt(action.getContext().getOrDefault("fuzzy.match.threshold", "70"));

            // Execute queries and collect input data
            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(ocrTextComparator.getQuerySet());
                for (int i = 0; i < formattedQuery.size(); i++) {
                    String sqlToExecute = formattedQuery.get(i);
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i);
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<OcrTextComparatorInput> resultIterable = query.mapToBean(OcrTextComparatorInput.class);
                    List<OcrTextComparatorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                    ocrTextComparatorInputs.addAll(processingExecutorInputs);
                    log.info(aMarker, "Executed query from index {}", i);
                }
            });

            log.info(aMarker, "OCR text comparator action total rows returned from the query {}", ocrTextComparatorInputs.size());

            // Process the inputs to compare answer with OCR text
            try {
                doOcrTextComparison(ocrTextComparatorInputs, jdbi, outputTableName, pipelineEndToEndEncryptionActivator,
                        batchId, encryption, fuzzyMatchThreshold);
            } catch (Exception e) {
                log.error(aMarker, "OCR text comparison failed for batchId: {}", batchId, e);
                auditSkippedEntry(jdbi, null, null, batchId, "Processing failed: " + e.getMessage());
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("OCR text comparison failed", handymanException, action);
            }

            log.info(aMarker, "OCR text comparator action has been completed {}", ocrTextComparator.getName());

        } catch (Exception e) {
            action.getContext().put(ocrTextComparator.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for OCR text comparator", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("OCR text comparator failed", handymanException, action);
        }
    }

    private void doOcrTextComparison(List<OcrTextComparatorInput> inputs, Jdbi jdbi, String outputTable,
                                     boolean pipelineEndToEndEncryptionActivator, String batchId,
                                     InticsIntegrity encryption, int fuzzyMatchThreshold) throws Exception {
        log.info(aMarker, "Starting OCR text comparison process for batchId: {}, totalInputs: {}", batchId, inputs.size());

        // Group inputs by originId and sorItemName
        Map<String, List<OcrTextComparatorInput>> groupedInputs = inputs.stream()
                .collect(Collectors.groupingBy(input -> input.getOriginId() + "|" + input.getSorItemName()));

        // Audit entries that are not in groupedInputs
        List<String> processedKeys = new ArrayList<>();
        FuzzyScore fuzzyScore = new FuzzyScore(Locale.ENGLISH);

        for (Map.Entry<String, List<OcrTextComparatorInput>> entry : groupedInputs.entrySet()) {
            List<OcrTextComparatorInput> groupList = entry.getValue();
            String key = entry.getKey();
            processedKeys.add(key);

            if (groupList.isEmpty()) {
                String[] parts = key.split("\\|");
                String originId = parts[0];
                String sorItemName = parts.length > 1 ? parts[1] : "";
                log.warn(aMarker, "Empty group for originId={}, sorItemName={}", originId, sorItemName);
                auditSkippedEntry(jdbi, originId, sorItemName, batchId, "Empty group after grouping");
                continue;
            }

            OcrTextComparatorInput firstInput = groupList.get(0);
            log.debug(aMarker, "Processing group: originId={}, sorItemName={}, inputCount={}",
                    firstInput.getOriginId(), firstInput.getSorItemName(), groupList.size());

            Integer selectedPageNo = firstInput.getPaperNo();
            boolean isOcrFieldComparable = false;
            String answer = firstInput.getAnswer(); // Default to first answer
            String extractedText = firstInput.getExtractedText();
            int bestScore = -1; // Track best fuzzy score
            String regexPattern = "NONE"; // Track regex pattern used
            String candidatesList = ""; // Track candidates extracted

            String scalarAdapterActivator = action.getContext().getOrDefault("scalar.adapter.activator", "false");

            // Check if comparison is needed (is_ocr_field_comparable = "t")
            if ("t".equalsIgnoreCase(firstInput.getIsOcrFieldComparable())) {
                log.debug(aMarker, "Performing OCR comparison for sorItemName={} (is_ocr_field_comparable='t')",
                        firstInput.getSorItemName());

                // Decrypt extracted_text and answer if needed
                if (pipelineEndToEndEncryptionActivator) {
                    try {
                        if ("false".equalsIgnoreCase(scalarAdapterActivator)) {
                            log.info(aMarker, "Scalar activator is disabled, running decryption in AES256 mode");
                            extractedText = encryption.decrypt(extractedText, AES_256, firstInput.getSorItemName());
                            answer = encryption.decrypt(answer, AES_256, firstInput.getSorItemName());
                        } else {
                            log.info(aMarker, "Scalar activator is enabled, running decryption in policy mode");
                            extractedText = encryption.decrypt(extractedText, firstInput.getEncryptionPolicy(), firstInput.getSorItemName());
                            answer = encryption.decrypt(answer, firstInput.getEncryptionPolicy(), firstInput.getSorItemName());
                        }
                        log.debug(aMarker, "Decrypted answer and extracted_text for originId={}, sorItemName={}",
                                firstInput.getOriginId(), firstInput.getSorItemName());
                    } catch (Exception e) {
                        log.error(aMarker, "Decryption failed for originId={}, sorItemName={}: {}",
                                firstInput.getOriginId(), firstInput.getSorItemName(), e.getMessage(), e);
                        auditSkippedEntry(jdbi, firstInput.getOriginId(), firstInput.getSorItemName(), batchId,
                                "Decryption failed: " + e.getMessage());
                        throw e;
                    }
                }

                // Clean the answer and extracted_text
                answer = (answer == null) ? "" : answer.trim().replaceAll("(^,+|,+$)", "").replaceAll(",{2,}", ",");
                extractedText = (extractedText == null) ? "" : extractedText;

                // Select regex pattern based on sor_item_name
                Pattern pattern;
                boolean usePartialRatio = false;
                String sorItemName = firstInput.getSorItemName().toLowerCase();
                if (sorItemName.equals("member_full_name") || sorItemName.equals("member_last_name") || sorItemName.equals("member_first_name")) {
                    pattern = NAME_PATTERN;
                    regexPattern = "NAME_PATTERN";
                } else if (sorItemName.equals("member_address_line1")) {
                    pattern = ADDRESS_PATTERN;
                    regexPattern = "ADDRESS_PATTERN";
                } else if (sorItemName.equals("member_id")) {
                    pattern = MEMBER_ID_PATTERN;
                    regexPattern = "MEMBER_ID_PATTERN";
                    usePartialRatio = true;
                } else {
                    pattern = NAME_PATTERN; // Default to name pattern
                    regexPattern = "NAME_PATTERN";
                }

                log.debug(aMarker, "Selected pattern {} for originId={}, sorItemName={}",
                        regexPattern, firstInput.getOriginId(), firstInput.getSorItemName());

                // Extract candidates from extracted_text
                List<String> candidates = new ArrayList<>();
                Matcher matcher = pattern.matcher(extractedText);
                while (matcher.find()) {
                    candidates.add(matcher.group());
                }
                candidatesList = String.join(",", candidates); // Store candidates as comma-separated string

                if (!candidates.isEmpty() && !answer.isEmpty()) {
                    // Find the best match to check if answer is present in extracted_text
                    String bestMatch = null;
                    bestScore = -1;

                    for (String candidate : candidates) {
                        // Approximate partial_ratio
                        int score = fuzzyScore.fuzzyScore(answer, candidate); // Approximate ratio
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = candidate;
                        }
                    }

                    // Check if the best score meets the threshold (> 70 as per Python code)
                    if (bestScore > fuzzyMatchThreshold) {
                        isOcrFieldComparable = true;
                        // Use the OCR candidate if answer is present (score > 70)
                        answer = bestMatch;
                        log.debug(aMarker, "Answer present in extracted_text with score {} for originId={}, sorItemName={}",
                                bestScore, firstInput.getOriginId(), firstInput.getSorItemName());
                    } else {
                        isOcrFieldComparable = false;
                        // Use the original answer if not present or score <= 70
                        answer = firstInput.getAnswer();
                        log.debug(aMarker, "Answer not present in extracted_text with sufficient score for originId={}, sorItemName={}",
                                firstInput.getOriginId(), firstInput.getSorItemName());
                    }
                } else {
                    isOcrFieldComparable = false;
                    // Use the original answer if no candidates or answer is empty
                    answer = firstInput.getAnswer();
                    log.debug(aMarker, "No candidates or empty answer for originId={}, sorItemName={}",
                            firstInput.getOriginId(), firstInput.getSorItemName());
                }

                // Encrypt answer and extracted_text if needed
                if (pipelineEndToEndEncryptionActivator) {
                    try {
                        if ("false".equalsIgnoreCase(scalarAdapterActivator)) {
                            log.info(aMarker, "Scalar activator is disabled, running encryption in AES256 mode");
                            answer = encryption.encrypt(answer, AES_256, firstInput.getSorItemName());
                            extractedText = encryption.encrypt(extractedText, AES_256, firstInput.getSorItemName());
                        } else {
                            log.info(aMarker, "Scalar activator is enabled, running encryption in policy mode");
                            answer = encryption.encrypt(answer, firstInput.getEncryptionPolicy(), firstInput.getSorItemName());
                            extractedText = encryption.encrypt(extractedText, firstInput.getEncryptionPolicy(), firstInput.getSorItemName());
                        }
                        log.info(aMarker, "Encrypted answer and extracted_text for originId={}, sorItemName={}",
                                firstInput.getOriginId(), firstInput.getSorItemName());
                    } catch (Exception e) {
                        log.error(aMarker, "Encryption failed for originId={}, sorItemName={}: {}",
                                firstInput.getOriginId(), firstInput.getSorItemName(), e.getMessage(), e);
                        auditSkippedEntry(jdbi, firstInput.getOriginId(), firstInput.getSorItemName(), batchId,
                                "Encryption failed: " + e.getMessage());
                        throw e;
                    }
                }
            } else {
                log.debug(aMarker, "Skipping OCR comparison for originId={}, sorItemName={} as is_ocr_field_comparable is not 't'",
                        firstInput.getOriginId(), firstInput.getSorItemName());
                // Use original answer if comparison is skipped
                answer = firstInput.getAnswer();
                isOcrFieldComparable = false;
                bestScore = -1;
                regexPattern = "NONE";
                candidatesList = "";
            }

            // Insert the result into the output table
            try {
                insertExecutionInfo(
                        jdbi, outputTable,
                        firstInput.getOriginId(), firstInput.getSorItemName(), firstInput.getTenantId(), batchId,
                        firstInput.getSorQuestion(), answer, isOcrFieldComparable, firstInput.getGroupId(), selectedPageNo,
                        firstInput.getVqaScore(), firstInput.getScore(), firstInput.getWeight(),
                        firstInput.getSorItemAttributionId(), firstInput.getDocumentId(), firstInput.getBBox(),
                        firstInput.getRootPipelineId(), firstInput.getQuestionId(), firstInput.getSynonymId(),
                        firstInput.getModelRegistry(), firstInput.getCategory(), extractedText,
                        fuzzyMatchThreshold, bestScore, regexPattern, candidatesList
                );

                log.info(aMarker, "Inserted result for originId={}, sorItemName={}, paperNo={}, isOcrFieldComparable={}, threshold={}, bestScore={}, regexPattern={}, candidates={}",
                        firstInput.getOriginId(), firstInput.getSorItemName(), selectedPageNo, isOcrFieldComparable,
                        fuzzyMatchThreshold, bestScore, regexPattern, candidatesList);
            } catch (HandymanException e) {
                log.error(aMarker, "Insert failed for originId={}, sorItemName={}, paperNo={}: {}",
                        firstInput.getOriginId(), firstInput.getSorItemName(), selectedPageNo, e.getMessage(), e);
                auditSkippedEntry(jdbi, firstInput.getOriginId(), firstInput.getSorItemName(), batchId,
                        "Insert failed: " + e.getMessage());
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error inserting for originId " +
                        firstInput.getOriginId() + ", sorItemName " + firstInput.getSorItemName(), handymanException, null);
            }
        }

        // Audit inputs that were not processed (not in groupedInputs)
        for (OcrTextComparatorInput input : ocrTextComparatorInputs) {
            String key = input.getOriginId() + "|" + input.getSorItemName();
            if (!processedKeys.contains(key)) {
                log.warn(aMarker, "Input not processed for originId={}, sorItemName={}",
                        input.getOriginId(), input.getSorItemName());
                auditSkippedEntry(jdbi, input.getOriginId(), input.getSorItemName(), batchId,
                        "Not included in grouped inputs");
            }
        }

        log.info(aMarker, "Completed OCR text comparison for batchId: {}", batchId);
    }

    private void auditSkippedEntry(Jdbi jdbi, String originId, String sorItemName, String batchId, String reason) {
        try {
            jdbi.useHandle(handle -> handle.createUpdate(
                            "INSERT INTO macro.ocr_text_comparator_audit (" +
                                    "created_on, origin_id, sor_item_name, batch_id, reason" +
                                    ") VALUES (" +
                                    ":createdOn, :originId, :sorItemName, :batchId, :reason" +
                                    ");")
                    .bind("createdOn", LocalDateTime.now())
                    .bind("originId", originId)
                    .bind("sorItemName", sorItemName)
                    .bind("batchId", batchId)
                    .bind("reason", reason)
                    .execute());
            log.info(aMarker, "Audited skipped entry for originId={}, sorItemName={}, reason={}",
                    originId, sorItemName, reason);
        } catch (Exception e) {
            log.error(aMarker, "Failed to audit skipped entry for originId={}, sorItemName={}: {}",
                    originId, sorItemName, e.getMessage(), e);
        }
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, String sorItemName, Long tenantId,
                                     String batchId, String sorQuestion, String answer, boolean isOcrFieldComparable,
                                     Integer groupId, Integer paperNo, Double vqaScore, Double score, Integer weight,
                                     Integer sorItemAttributionId, String documentId, String bBox, Long rootPipelineId,
                                     Long questionId, Long synonymId, String modelRegistry, String category,
                                     String extractedText, int threshold, int bestScore, String regexPattern,
                                     String candidatesList) {
        if (tenantId == null) {
            log.warn(aMarker, "tenantId is null for originId={}, sorItemName={}, setting to default 1", originId, sorItemName);
            tenantId = 1L;
        }
        Long finalTenantId = tenantId;
        jdbi.useHandle(handle -> handle.createUpdate(
                        "INSERT INTO " + outputTable + " (" +
                                "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                "origin_id, group_id, paper_no, sor_question, answer, vqa_score, score, weight, " +
                                "sor_item_attribution_id, sor_item_name, document_id, b_box, root_pipeline_id, " +
                                "question_id, synonym_id, model_registry, category, batch_id, is_ocr_field_comparable, " +
                                "extracted_text, threshold, best_score, regex_pattern, candidates" +
                                ") VALUES (" +
                                ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                ":originId, :groupId, :paperNo, :sorQuestion, :answer, :vqaScore, :score, :weight, " +
                                ":sorItemAttributionId, :sorItemName, :documentId, :bBox, :rootPipelineId, " +
                                ":questionId, :synonymId, :modelRegistry, :category, :batchId, :isOcrFieldComparable, " +
                                ":extractedText, :threshold, :bestScore, :regexPattern, :candidates" +
                                ");")
                .bind("createdOn", LocalDateTime.now())
                .bind("createdUserId", finalTenantId)
                .bind("lastUpdatedOn", LocalDateTime.now())
                .bind("lastUpdatedUserId", finalTenantId)
                .bind("tenantId", finalTenantId)
                .bind("originId", originId)
                .bind("groupId", groupId)
                .bind("paperNo", paperNo)
                .bind("sorQuestion", sorQuestion)
                .bind("answer", answer)
                .bind("vqaScore", vqaScore)
                .bind("score", score)
                .bind("weight", weight)
                .bind("sorItemAttributionId", sorItemAttributionId)
                .bind("sorItemName", sorItemName)
                .bind("documentId", documentId)
                .bind("bBox", bBox)
                .bind("rootPipelineId", rootPipelineId)
                .bind("questionId", questionId)
                .bind("synonymId", synonymId)
                .bind("modelRegistry", modelRegistry)
                .bind("category", category)
                .bind("batchId", batchId)
                .bind("isOcrFieldComparable", isOcrFieldComparable)
                .bind("extractedText", extractedText)
                .bind("threshold", threshold)
                .bind("bestScore", bestScore)
                .bind("regexPattern", regexPattern)
                .bind("candidates", candidatesList)
                .execute());
        log.info(aMarker, "Inserted comparison result for originId={}, sorItemName={}", originId, sorItemName);
    }

    @Override
    public boolean executeIf() throws Exception {
        return ocrTextComparator.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    public static class OcrTextComparatorInput {
        private String originId;
        private String sorItemName;
        private String sorQuestion;
        private String answer;
        private Long tenantId;
        private String batchId;
        private Integer groupId;
        private Integer paperNo;
        private Double vqaScore;
        private Double score;
        private Integer weight;
        private Integer sorItemAttributionId;
        private String documentId;
        private String bBox;
        private Long rootPipelineId;
        private Long questionId;
        private Long synonymId;
        private String modelRegistry;
        private String category;
        private String isOcrFieldComparable;
        private String extractedText;
        private String encryptionPolicy;
    }
}