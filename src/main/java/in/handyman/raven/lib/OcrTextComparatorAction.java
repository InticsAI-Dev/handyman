package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.OcrTextComparator;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "OcrTextComparator"
)
public class OcrTextComparatorAction implements IActionExecution {
    private static final String AES_256 = "AES256";
    private final ActionExecutionAudit action;
    private final Logger log;
    private final OcrTextComparator ocrTextComparator;
    private final Marker aMarker;
    private final List<OcrTextComparatorInput> ocrTextComparatorInputs = new ArrayList<>();
    private static final Pattern COMMON_PATTERN = Pattern.compile(
            "(" +
                    "\\b[A-Z][a-zA-Z]+\\s+[A-Z][a-zA-Z]+\\b" +                       // NAME_PATTERN
                    "|" +
                    "\\d+\\s+[A-Za-z0-9\\s]+(?:Street|St|Avenue|Ave|Road|Rd|Lane|Ln|Drive|Dr|Blvd)\\b" + // ADDRESS_PATTERN
                    "|" +
                    "\\b[A-Z0-9]{5,15}\\b" +                                         // MEMBER_ID_PATTERN
                    ")",
            Pattern.CASE_INSENSITIVE
    );

    public OcrTextComparatorAction(final ActionExecutionAudit action, final Logger log,
                                   final Object ocrTextComparator) {
        this.ocrTextComparator = (OcrTextComparator) ocrTextComparator;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("OcrTextComparator:" + this.ocrTextComparator.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ocrTextComparator.getResourceConn());
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
            boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

            String batchId = ocrTextComparator.getBatchId();
            String outputTableName = ocrTextComparator.getOutputTable();
            int fuzzyMatchThreshold = Integer.parseInt(action.getContext().getOrDefault("fuzzy.match.threshold", "0"));

            // Execute queries and collect input data
            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(ocrTextComparator.getQuerySet());
                for (int i = 0; i < formattedQuery.size(); i++) {
                    String sqlToExecute = formattedQuery.get(i);
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i);
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<OcrTextComparatorInput> resultIterable = query.mapToBean(OcrTextComparatorInput.class);
                    List<OcrTextComparatorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                    ocrTextComparatorInputs.addAll(processingExecutorInputs);
                    log.info(aMarker, "Executed query from index {}", i);
                }
            });

            log.info(aMarker, "OCR text comparator action total rows returned from the query {}", ocrTextComparatorInputs.size());

            // Process the inputs to compare answer with OCR text
            try {
                doOcrTextComparison(ocrTextComparatorInputs, jdbi, outputTableName, pipelineEndToEndEncryptionActivator,
                        batchId, encryption, fuzzyMatchThreshold);
            } catch (Exception e) {
                log.error(aMarker, "OCR text comparison failed for batchId: {}", batchId, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("OCR text comparison failed", handymanException, action);
            }

            log.info(aMarker, "OCR text comparator action has been completed {}", ocrTextComparator.getName());

        } catch (Exception e) {
            action.getContext().put(ocrTextComparator.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for OCR text comparator", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("OCR text comparator failed", handymanException, action);
        }
    }
// Replace your fuzzy matching logic with this corrected version

    private void doOcrTextComparison(List<OcrTextComparatorInput> inputs, Jdbi jdbi, String outputTable,
                                     boolean pipelineEndToEndEncryptionActivator, String batchId,
                                     InticsIntegrity encryption, int fuzzyMatchThreshold) throws Exception {
        log.info(aMarker, "Starting OCR text comparison process for batchId: {}, totalInputs: {}", batchId, inputs.size());

        List<String> processedKeys = new ArrayList<>();

        inputs.forEach(input -> {
            String key = input.getOriginId() + "|" + input.getSorItemName();
            synchronized (processedKeys) {
                processedKeys.add(key);
            }

            log.debug(aMarker, "Processing input: originId={}, sorItemName={}",
                    input.getOriginId(), input.getSorItemName());

            Integer selectedPageNo = input.getPaperNo();
            boolean isOcrFieldComparable = false;
            String originalAnswer = input.getAnswer();
            String finalAnswer = originalAnswer;
            String extractedText = input.getExtractedText();

            // Initialize with default values
            int bestScore = -1;
            String regexPattern = "NONE";
            String candidatesList = "";

            Boolean isOcrFieldComparableValue = input.getIsOcrFieldComparable();

            // Only process if is_ocr_field_comparable is true
            if (Boolean.TRUE.equals(isOcrFieldComparableValue) || "t".equalsIgnoreCase(String.valueOf(isOcrFieldComparableValue))) {
                log.debug(aMarker, "Performing OCR comparison for sorItemName={} (is_ocr_field_comparable='t')",
                        input.getSorItemName());

                try {
                    // Decrypt if needed
                    if (pipelineEndToEndEncryptionActivator) {
                        log.info(aMarker, "Decrypting extracted_text with AES256 and answer with policy for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                        extractedText = encryption.decrypt(extractedText, AES_256, input.getSorItemName());
                        originalAnswer = encryption.decrypt(originalAnswer, input.getEncryptionPolicy(), input.getSorItemName());
                        log.debug(aMarker, "Decrypted answer and extracted_text for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                    }

                    // Clean the texts
                    String cleanedAnswer = (originalAnswer == null) ? "" : originalAnswer.trim().replaceAll("(^,+|,+$)", "").replaceAll(",{2,}", ",");
                    String cleanedExtractedText = (extractedText == null) ? "" : extractedText;

                    log.debug(aMarker, "Cleaned answer: '{}', Cleaned extracted text length: {}",
                            cleanedAnswer, cleanedExtractedText.length());

                    // Extract candidates from OCR text using the regex pattern
                    List<String> candidates = new ArrayList<>();
                    if (!cleanedExtractedText.isEmpty()) {
                        Matcher matcher = COMMON_PATTERN.matcher(cleanedExtractedText);
                        while (matcher.find()) {
                            String candidate = matcher.group().trim();
                            if (!candidate.isEmpty()) {
                                candidates.add(candidate);
                            }
                        }
                    }

                    candidatesList = String.join(",", candidates);
                    log.debug(aMarker, "Found {} candidates: {}", candidates.size(), candidatesList);

                    // Process candidates if we have both candidates and answer
                    if (!candidates.isEmpty() && !cleanedAnswer.isEmpty()) {
                        regexPattern = "COMMON_PATTERN"; // Update regex pattern since we found candidates

                        // Find the best match using similarity calculation
                        String bestMatch = null;
                        double bestSimilarity = 0.0;

                        for (String candidate : candidates) {
                            double similarity = calculateSimilarity(cleanedAnswer, candidate);
                            log.debug(aMarker, "Similarity between '{}' and '{}': {}%",
                                    cleanedAnswer, candidate, (int)(similarity * 100));

                            if (similarity > bestSimilarity) {
                                bestSimilarity = similarity;
                                bestMatch = candidate;
                            }
                        }

                        bestScore = (int) (bestSimilarity * 100); // Convert to percentage
                        log.info(aMarker, "Best match for '{}': '{}' with score {}%",
                                cleanedAnswer, bestMatch, bestScore);

                        // Check if the best score meets the threshold
                        if (bestScore > fuzzyMatchThreshold) {
                            isOcrFieldComparable = true;
                            finalAnswer = bestMatch; // Use OCR candidate
                            log.info(aMarker, "MATCH FOUND - Using OCR value '{}' (score: {}% > threshold: {}%) for originId={}, sorItemName={}",
                                    bestMatch, bestScore, fuzzyMatchThreshold, input.getOriginId(), input.getSorItemName());
                        } else {
                            isOcrFieldComparable = false;
                            finalAnswer = originalAnswer; // Use original answer
                            log.info(aMarker, "NO MATCH - Using original value '{}' (score: {}% <= threshold: {}%) for originId={}, sorItemName={}",
                                    originalAnswer, bestScore, fuzzyMatchThreshold, input.getOriginId(), input.getSorItemName());
                        }
                    } else {
                        // No candidates found or empty answer
                        isOcrFieldComparable = false;
                        finalAnswer = originalAnswer;
                        bestScore = 0; // Set to 0 instead of -1 when no comparison could be made
                        regexPattern = candidates.isEmpty() ? "NO_CANDIDATES" : "EMPTY_ANSWER";

                        log.debug(aMarker, "No comparison possible - candidates: {}, answer empty: {} for originId={}, sorItemName={}",
                                candidates.size(), cleanedAnswer.isEmpty(), input.getOriginId(), input.getSorItemName());
                    }

                    // Re-encrypt if needed
                    if (pipelineEndToEndEncryptionActivator) {
                        log.info(aMarker, "Encrypting final answer and extracted_text for originId={}, sorItemName={}",
                                input.getOriginId(), input.getSorItemName());
                        extractedText = encryption.encrypt(extractedText, AES_256, input.getSorItemName());
                        finalAnswer = encryption.encrypt(finalAnswer, input.getEncryptionPolicy(), input.getSorItemName());
                        if (!candidatesList.isEmpty()) {
                            candidatesList = encryption.encrypt(candidatesList, AES_256, input.getSorItemName());
                        }
                    }

                }catch (Exception e) {
                log.error(aMarker, "Encryption failed for originId={}, sorItemName={}: {}",
                        input.getOriginId(), input.getSorItemName(), e.getMessage(), e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Encryption failed for originId: " + input.getOriginId() +
                        ", sorItemName: " + input.getSorItemName(), handymanException, action);
                return;
            }
            } else {
                log.debug(aMarker, "Skipping OCR comparison for originId={}, sorItemName={} as is_ocr_field_comparable is not 't' (value: {})",
                        input.getOriginId(), input.getSorItemName(), isOcrFieldComparableValue);
                finalAnswer = originalAnswer;
                isOcrFieldComparable = false;
                bestScore = -1;
                regexPattern = "SKIPPED";
                candidatesList = "";
            }

            // Log the final values before insertion
            log.info(aMarker, "Final values for originId={}, sorItemName={}: bestScore={}, regexPattern={}, isComparable={}, candidates='{}'",
                    input.getOriginId(), input.getSorItemName(), bestScore, regexPattern, isOcrFieldComparable,
                    candidatesList.length() > 50 ? candidatesList.substring(0, 50) + "..." : candidatesList);

            // Insert the result
            try {
                insertExecutionInfo(
                        jdbi, outputTable,
                        input.getOriginId(), input.getSorItemName(), input.getTenantId(), batchId,
                        input.getSorQuestion(), finalAnswer, isOcrFieldComparableValue, input.getGroupId(), selectedPageNo,
                        input.getVqaScore(), input.getScore(), input.getWeight(),
                        input.getSorItemAttributionId(), input.getDocumentId(), input.getBBox(),
                        input.getRootPipelineId(), input.getQuestionId(), input.getSynonymId(),
                        input.getModelRegistry(), input.getCategory(), extractedText,
                        fuzzyMatchThreshold, bestScore, regexPattern, candidatesList
                );

                log.info(aMarker, "Successfully inserted result for originId={}, sorItemName={}, bestScore={}, regexPattern={}",
                        input.getOriginId(), input.getSorItemName(), bestScore, regexPattern);

            } catch (Exception e) {
                log.error(aMarker, "Insert failed for originId={}, sorItemName={}: {}",
                        input.getOriginId(), input.getSorItemName(), e.getMessage(), e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error inserting for originId " +
                        input.getOriginId() + ", sorItemName " + input.getSorItemName(), handymanException, action);
            }
        });

        log.info(aMarker, "Completed OCR text comparison for batchId: {}", batchId);
    }

    /**
     * Calculate similarity between two strings using Levenshtein distance
     * Returns a value between 0.0 and 1.0 where 1.0 is a perfect match
     */
    private double calculateSimilarity(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return 0.0;
        }

        str1 = str1.toLowerCase().trim();
        str2 = str2.toLowerCase().trim();

        if (str1.equals(str2)) {
            return 1.0;
        }

        int maxLen = Math.max(str1.length(), str2.length());
        if (maxLen == 0) {
            return 1.0;
        }

        int distance = levenshteinDistance(str1, str2);
        return 1.0 - (double) distance / maxLen;
    }

    /**
     * Calculate Levenshtein distance between two strings
     */
    private int levenshteinDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];

        for (int i = 0; i <= s1.length(); i++) {
            for (int j = 0; j <= s2.length(); j++) {
                if (i == 0) {
                    dp[i][j] = j;
                } else if (j == 0) {
                    dp[i][j] = i;
                } else {
                    dp[i][j] = Math.min(Math.min(
                                    dp[i - 1][j] + 1,      // deletion
                                    dp[i][j - 1] + 1),     // insertion
                            dp[i - 1][j - 1] + (s1.charAt(i - 1) == s2.charAt(j - 1) ? 0 : 1) // substitution
                    );
                }
            }
        }

        return dp[s1.length()][s2.length()];
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, String sorItemName, Long tenantId,
                                     String batchId, String sorQuestion, String answer, boolean isOcrFieldComparable,
                                     Integer groupId, Integer paperNo, Double vqaScore, Double score, Integer weight,
                                     Integer sorItemAttributionId, String documentId, String bBox, Long rootPipelineId,
                                     Long questionId, Long synonymId, String modelRegistry, String category,
                                     String extractedText, int threshold, int bestScore, String regexPattern,
                                     String candidatesList) {
        if (tenantId == null) {
            log.warn(aMarker, "tenantId is null for originId={}, sorItemName={}, setting to default 1", originId, sorItemName);
            tenantId = 1L;
        }
        Long finalTenantId = tenantId;
        jdbi.useHandle(handle -> handle.createUpdate(
                        "INSERT INTO " + outputTable + " (" +
                                "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                "origin_id, group_id, paper_no, sor_question, answer, vqa_score, score, weight, " +
                                "sor_item_attribution_id, sor_item_name, document_id, b_box, root_pipeline_id, " +
                                "question_id, synonym_id, model_registry, category, batch_id, is_ocr_field_comparable, " +
                                "extracted_text, threshold, best_score, regex_pattern, candidates" +
                                ") VALUES (" +
                                ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                ":originId, :groupId, :paperNo, :sorQuestion, :answer, :vqaScore, :score, :weight, " +
                                ":sorItemAttributionId, :sorItemName, :documentId, :bBox, :rootPipelineId, " +
                                ":questionId, :synonymId, :modelRegistry, :category, :batchId, :isOcrFieldComparable, " +
                                ":extractedText, :threshold, :bestScore, :regexPattern, :candidates" +
                                ");")
                .bind("createdOn", LocalDateTime.now())
                .bind("createdUserId", finalTenantId)
                .bind("lastUpdatedOn", LocalDateTime.now())
                .bind("lastUpdatedUserId", finalTenantId)
                .bind("tenantId", finalTenantId)
                .bind("originId", originId)
                .bind("groupId", groupId)
                .bind("paperNo", paperNo)
                .bind("sorQuestion", sorQuestion)
                .bind("answer", answer)
                .bind("vqaScore", vqaScore)
                .bind("score", score)
                .bind("weight", weight)
                .bind("sorItemAttributionId", sorItemAttributionId)
                .bind("sorItemName", sorItemName)
                .bind("documentId", documentId)
                .bind("bBox", bBox)
                .bind("rootPipelineId", rootPipelineId)
                .bind("questionId", questionId)
                .bind("synonymId", synonymId)
                .bind("modelRegistry", modelRegistry)
                .bind("category", category)
                .bind("batchId", batchId)
                .bind("isOcrFieldComparable", isOcrFieldComparable)
                .bind("extractedText", extractedText)
                .bind("threshold", threshold)
                .bind("bestScore", bestScore)
                .bind("regexPattern", regexPattern)
                .bind("candidates", candidatesList)
                .execute());
        log.info(aMarker, "Inserted comparison result for originId={}, sorItemName={}", originId, sorItemName);
    }

    @Override
    public boolean executeIf() throws Exception {
        return ocrTextComparator.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    public static class OcrTextComparatorInput {
        private String originId;
        private String sorItemName;
        private String sorQuestion;
        private String answer;
        private Long tenantId;
        private String batchId;
        private Integer groupId;
        private Integer paperNo;
        private Double vqaScore;
        private Double score;
        private Integer weight;
        private Integer sorItemAttributionId;
        private String documentId;
        private String bBox;
        private Long rootPipelineId;
        private Long questionId;
        private Long synonymId;
        private String modelRegistry;
        private String category;
        private Boolean isOcrFieldComparable;
        private String extractedText;
        private String encryptionPolicy;
    }
}