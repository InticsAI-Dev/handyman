package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.ocr.*;
import in.handyman.raven.lib.model.OcrTextComparator;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static in.handyman.raven.core.enums.DatabaseConstants.DB_INSERT_WRITE_BATCH_SIZE;
import static in.handyman.raven.core.enums.EncryptionConstants.ENCRYPT_DEEP_SIFT_OUTPUT;
import static in.handyman.raven.core.enums.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;


/**
 * Auto Generated By Raven - Optimized Version
 */
@ActionExecution(
        actionName = "OcrTextComparator"
)
public class OcrTextComparatorAction implements IActionExecution {
    private final int BATCH_INSERT_SIZE;

    private final ActionExecutionAudit action;
    private final Logger log;
    private LocalDateTime executionStartTime;
    private final OcrTextComparator ocrTextComparator;
    private final Marker aMarker;
    private final InticsIntegrity encryption;
    private final List<OcrTextComparatorInput> ocrTextComparatorInputs = new ArrayList<>();

    public OcrTextComparatorAction(final ActionExecutionAudit action, final Logger log,
                                   final Object ocrTextComparator) {
        this.ocrTextComparator = (OcrTextComparator) ocrTextComparator;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("OcrTextComparator:" + (ocrTextComparator != null ? this.ocrTextComparator.getName() : "unknown"));
        this.encryption = SecurityEngine.getInticsIntegrityMethod(action, log);
        this.BATCH_INSERT_SIZE = Integer.parseInt(action.getContext().getOrDefault(DB_INSERT_WRITE_BATCH_SIZE, "500"));
    }

    @Override
    public void execute() throws Exception {
        try {
            this.executionStartTime = LocalDateTime.now();

            log.info(aMarker, "Starting OCR text comparator execution at: {}", executionStartTime);

            if (ocrTextComparator == null) {
                throw new HandymanException("OcrTextComparator configuration is null");
            }
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ocrTextComparator.getResourceConn());

            final String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
            final boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr != null ? pipelineEndToEndEncryptionActivatorStr : "false");

            final String deepSiftOutputActivatorStr = action.getContext().get(ENCRYPT_DEEP_SIFT_OUTPUT);
            final boolean deepSiftOutputActivator = Boolean.parseBoolean(deepSiftOutputActivatorStr != null ? deepSiftOutputActivatorStr : "false");

            final String batchId = ocrTextComparator.getBatchId() != null ? ocrTextComparator.getBatchId() : "";
            final String outputTableName = ocrTextComparator.getOutputTable() != null ? ocrTextComparator.getOutputTable() : "";
            final int fuzzyMatchThresholdInt = Integer.parseInt(action.getContext().get("ocr.comparison.fuzzy.match.threshold"));
            final double fuzzyMatchThreshold = fuzzyMatchThresholdInt / 100.0;

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(ocrTextComparator.getQuerySet());
                for (int i = 0; i < formattedQuery.size(); i++) {
                    String sqlToExecute = formattedQuery.get(i);
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i);
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<OcrTextComparatorInput> resultIterable = query.mapToBean(OcrTextComparatorInput.class);
                    List<OcrTextComparatorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                    ocrTextComparatorInputs.addAll(processingExecutorInputs);
                    log.info(aMarker, "Executed query from index {}", i);
                }
            });

            log.info(aMarker, "OCR text comparator action total rows returned from the query {}", ocrTextComparatorInputs.size());

            try {

                performDecryption(ocrTextComparatorInputs, encryption, pipelineEndToEndEncryptionActivator, deepSiftOutputActivator);

                List<OcrTextComparatorInput> updatedResults = doOcrTextComparison(ocrTextComparatorInputs,
                        fuzzyMatchThreshold);

                performEncryption(updatedResults, encryption,
                        pipelineEndToEndEncryptionActivator, deepSiftOutputActivator);

                // Batch insert results
                if (!updatedResults.isEmpty()) {
                    batchInsertResults(jdbi, outputTableName, updatedResults);
                }


            } catch (Exception e) {
                log.error(aMarker, "OCR text comparison failed for batchId: {}", batchId, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("OCR text comparison failed", handymanException, action);
            }

            log.info(aMarker, "OCR text comparator action has been completed {}", ocrTextComparator.getName());

        } catch (Exception e) {
            action.getContext().put(ocrTextComparator.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for OCR text comparator", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("OCR text comparator failed", handymanException, action);
        }
    }

    private void performDecryption(List<OcrTextComparatorInput> records,
                                   InticsIntegrity encryptionHandler, boolean pipelineEndToEndEncryptionActivator, boolean deepSiftOutputActivator) {
        log.info(aMarker, "Total records to process for decryption: {}", records.size());

        if (pipelineEndToEndEncryptionActivator) {
            log.info(aMarker, "Starting Decryption process for item-wise encryption");
            decryptAndUpdate(records, encryptionHandler, false);
        } else {
            log.info(aMarker, "Skipping Decryption as itemWiseEncryption is false");
        }

        if (deepSiftOutputActivator) {
            log.info(aMarker, "Starting Decryption process for deep sift text encryption");
            decryptAndUpdate(records, encryptionHandler, true);
        } else {
            log.info(aMarker, "Skipping Decryption as  deep sift text is false");
        }


    }

    private void decryptAndUpdate(
            List<OcrTextComparatorInput> records,
            InticsIntegrity encryptionHandler,
            boolean isPageContent
    ) {
        log.info(aMarker, "Total records to process for decryption (isPageContent={}): {}", isPageContent, records.size());
        List<EncryptionRequestClass> requests = buildDecryptionRequests(records, isPageContent);

        if (requests.isEmpty()) {
            return;
        }

        List<EncryptionRequestClass> responses = encryptionHandler.decrypt(requests);
        Map<String, List<EncryptionRequestClass>> groupedResponses = groupResponsesByRecordId(responses);

        applyDecryptedValues(records, groupedResponses, isPageContent);
    }


    /**
     * Builds decryption requests from records.
     */
    private List<EncryptionRequestClass> buildDecryptionRequests(
            List<OcrTextComparatorInput> records,
            boolean isPageContent
    ) {
        List<EncryptionRequestClass> requests = new ArrayList<>();

        for (OcrTextComparatorInput r : records) {
            if (!"t".equalsIgnoreCase(r.getIsEncrypted())) continue;

            String rawVal = isPageContent ? r.getExtractedText() : r.getAnswer();
            if (rawVal == null || rawVal.isEmpty()) continue;

            if ("multi_value".equalsIgnoreCase(r.getLineItemType()) && rawVal.contains(",")) {
                addMultiValueRequests(requests, r, rawVal);
            } else {
                requests.add(newRequest(String.valueOf(r.getId()), rawVal, r.getEncryptionPolicy()));
            }
        }

        return requests;
    }

    /**
     * Adds split requests for multi-value fields.
     */
    private void addMultiValueRequests(List<EncryptionRequestClass> requests,
                                       OcrTextComparatorInput record,
                                       String rawVal) {
        log.info("Adding multi-value requests for record ID: {}", record.getId());
        String[] parts = rawVal.split(",");
        for (int i = 0; i < parts.length; i++) {
            String trimmed = parts[i].trim();
            if (!trimmed.isEmpty()) {
                requests.add(newRequest(record.getId() + "_" + i, trimmed, record.getEncryptionPolicy()));
            }
        }
    }

    /**
     * Builds a single request object.
     */
    private EncryptionRequestClass newRequest(String key, String value, String policy) {
        log.info("Creating request - Key: {}, Policy: {}", key, policy);
        return EncryptionRequestClass.builder()
                .key(key)
                .value(value)
                .policy(policy)
                .build();
    }


    /**
     * Applies decrypted values back to records.
     */
    private void applyDecryptedValues(List<OcrTextComparatorInput> records,
                                      Map<String, List<EncryptionRequestClass>> groupedResponses,
                                      boolean isPageContent) {
        log.info(aMarker, "Applying decrypted values to records (isPageContent={}): {}", isPageContent, records.size());
        for (OcrTextComparatorInput r : records) {
            List<EncryptionRequestClass> respList = groupedResponses.get(String.valueOf(r.getId()));
            if (respList == null) continue;

            // preserve order for multi-value
            respList.sort(Comparator.comparingInt(resp -> {
                if (!resp.getKey().contains("_")) return 0;
                return Integer.parseInt(resp.getKey().substring(resp.getKey().indexOf("_") + 1));
            }));

            String finalValue = respList.stream()
                    .map(EncryptionRequestClass::getValue)
                    .collect(Collectors.joining(","));

            if (isPageContent) {
                r.setExtractedText(finalValue);
            } else {
                r.setAnswer(finalValue);
            }
        }
    }


    private void encryptAndApply(
            List<OcrTextComparatorInput> records,
            InticsIntegrity encryptionHandler,
            boolean isPageContent
    ) {
        log.info(aMarker, "Total records to process for encryption (isPageContent={}): {}", isPageContent, records.size());
        List<EncryptionRequestClass> requests = buildEncryptionRequests(records, isPageContent);

        if (requests.isEmpty()) {
            log.info(aMarker, "No records found for encryption [{}]",
                    isPageContent ? "PageContent" : "ExtractedAnswer");
            return;
        }

        List<EncryptionRequestClass> responses = encryptionHandler.encrypt(requests);
        Map<String, List<EncryptionRequestClass>> groupedResponses = groupResponsesByRecordId(responses);

        applyEncryptedValues(records, groupedResponses, isPageContent);
    }

    /**
     * Groups responses by record id (ignores multi-value suffix).
     */
    private Map<String, List<EncryptionRequestClass>> groupResponsesByRecordId(
            List<EncryptionRequestClass> responses
    ) {
        log.info("Grouping responses by record ID, total responses: {}", responses.size());
        return responses.stream()
                .collect(Collectors.groupingBy(resp -> {
                    String key = resp.getKey();
                    return key.contains("_") ? key.substring(0, key.indexOf("_")) : key;
                }));
    }

    /**
     * Builds encryption requests (single + multi expanded).
     */
    private List<EncryptionRequestClass> buildEncryptionRequests(
            List<OcrTextComparatorInput> records,
            boolean isPageContent
    ) {
        log.info("Building encryption requests (isPageContent={}): {}", isPageContent, records.size());
        List<EncryptionRequestClass> requests = new ArrayList<>();

        for (OcrTextComparatorInput r : records) {
            if (!"t".equalsIgnoreCase(r.getIsEncrypted())) continue;

            String rawVal = isPageContent ? r.getExtractedText() : r.getBestMatch();
            if (rawVal == null || rawVal.isEmpty()) continue;

            if ("multi_value".equalsIgnoreCase(r.getLineItemType()) && rawVal.contains(",")) {
                addMultiValueRequests(requests, r, rawVal);
            } else {
                requests.add(newRequest(String.valueOf(r.getId()), rawVal, r.getEncryptionPolicy()));
            }
        }
        return requests;
    }


    /**
     * Applies encrypted values back to the original records.
     */
    private void applyEncryptedValues(List<OcrTextComparatorInput> records,
                                      Map<String, List<EncryptionRequestClass>> groupedResponses,
                                      boolean isPageContent) {
        log.info(aMarker, "Applying encrypted values to records (isPageContent={}): {}", isPageContent, records.size());
        for (OcrTextComparatorInput r : records) {
            List<EncryptionRequestClass> respList = groupedResponses.get(String.valueOf(r.getId()));
            if (respList == null) continue;

            // Preserve order for multi-value
            respList.sort(Comparator.comparingInt(resp -> {
                if (!resp.getKey().contains("_")) return 0;
                return Integer.parseInt(resp.getKey().substring(resp.getKey().indexOf("_") + 1));
            }));

            String finalValue = respList.stream()
                    .map(EncryptionRequestClass::getValue)
                    .collect(Collectors.joining(","));

            if(isPageContent){
                r.setExtractedText(finalValue);
            }else {
                r.setBestMatch(finalValue);
            }

        }
    }




    private void performEncryption(
            List<OcrTextComparatorInput> controlDataComparisonQueryInputTables,
            InticsIntegrity encryptionHandler, boolean itemWiseEncryption, boolean deepSiftOutputActivator
    ) {
        log.info(aMarker, "Total records to process for encryption: {}", controlDataComparisonQueryInputTables.size());

        if (itemWiseEncryption) {
            log.info(aMarker, "Starting Encryption process for item-wise encryption");
            encryptAndApply(controlDataComparisonQueryInputTables, encryptionHandler, false);
        } else {
            log.info(aMarker, "Skipping Encryption as itemWiseEncryption is false");
        }

        if (deepSiftOutputActivator) {
            log.info(aMarker, "Starting Encryption process for  deep sift text encryption");
            encryptAndApply(controlDataComparisonQueryInputTables, encryptionHandler, true);
        } else {
            log.info(aMarker, "Skipping Encryption as  deep sift text is false");
        }

    }
    private List<OcrTextComparatorInput> doOcrTextComparison(List<OcrTextComparatorInput> inputs, double fuzzyMatchThreshold) {
        OcrTextComparisonExecutor executor =
                new OcrTextComparisonExecutor(log, aMarker, action, 40); // 8 threads, tune as needed
        List<OcrTextComparatorInput> updatedResults = executor.executeComparisons(inputs, fuzzyMatchThreshold);
        log.info(aMarker, "OCR text comparison completed for {} inputs", updatedResults.size());
        return updatedResults;
    }



    private boolean isComparable(OcrTextComparatorInput input) {
        Boolean isOcrFieldComparable = input.getIsOcrFieldComparable();
        return Boolean.TRUE.equals(isOcrFieldComparable)
                || "t".equalsIgnoreCase(String.valueOf(isOcrFieldComparable));
    }

    /**
     * Process a single input and return comparison result
     */
    private OcrComparisonResult processInput(OcrTextComparatorInput input,
                                             double fuzzyMatchThreshold) throws Exception {
        OcrComparisonResult result ;

        String originId = input.getOriginId();
        String sorItemName = input.getSorItemName();
        Integer paperNo = input.getPaperNo();
        log.debug(aMarker, "Processing originId: {}, sorItemName: {}, paperNo: {}",
                originId, sorItemName, paperNo);

        String answer = input.getAnswer() != null ? input.getAnswer() : "";
        String extractedText = input.getExtractedText() != null ? input.getExtractedText() : "";
        int bestScore = -1;
        String candidatesList = "";
        String bestMatch = answer;

        try {

            String cleanedAnswer = answer.trim();
            String cleanedExtractedText = extractedText.trim();

            OcrComparisonAdapter adapter = OcrComparisonAdapterFactory.getAdapter(input.getAllowedAdapter());
            log.debug(aMarker, "Using adapter: {} for originId: {}, sorItemName: {}, paperNo: {}",
                    adapter.getName(), originId, sorItemName, paperNo);

            result=adapter.compareValues(cleanedAnswer, cleanedExtractedText, fuzzyMatchThreshold);


            if (input.getIsOcrFieldComparable()) {
                log.info(aMarker, "MATCH FOUND - originId: {}, sorItemName: {}, paperNo: {}, score: {}, threshold: {}",
                        originId, sorItemName, paperNo, bestScore, (int)(fuzzyMatchThreshold * 100));
            } else {
                log.info(aMarker, "NO MATCH - originId: {}, sorItemName: {}, paperNo: {}, score: {}, threshold: {}",
                        originId, sorItemName, paperNo, bestScore, (int)(fuzzyMatchThreshold * 100));
            }

            return result;
        } catch (Exception e) {
            log.error(aMarker, "Processing error for originId: {}, sorItemName: {}, paperNo: {}",
                    originId, sorItemName, paperNo, e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Processing error for originId: " + originId +
                    ", sorItemName: " + sorItemName, handymanException, action);
        }


        return OcrComparisonResult.builder()
                .isMatch(false)
                .bestMatch(bestMatch)
                .bestScore(bestScore)
                .matchingMethod("NONE")
                .candidatesList(candidatesList)
                .build();
    }

    /**
     * Batch insert comparison results
     */
    private void batchInsertResults(Jdbi jdbi, String outputTable, List<OcrTextComparatorInput> results) {
        log.info(aMarker, "Starting batch insert of {} records into {}", results.size(), outputTable);

        int totalInserted = 0;
        int batchCount = 0;

        // Process in batches
        for (int i = 0; i < results.size(); i += BATCH_INSERT_SIZE) {
            int endIndex = Math.min(i + BATCH_INSERT_SIZE, results.size());
            List<OcrTextComparatorInput> batch = results.subList(i, endIndex);
            batchCount++;

            try {
                jdbi.useHandle(handle -> {
                    PreparedBatch preparedBatch = handle.prepareBatch(
                            "INSERT INTO " + outputTable + " (" +
                                    "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                    "origin_id, group_id, paper_no, sor_question, answer, vqa_score, score, weight, " +
                                    "sor_item_attribution_id, sor_item_name, document_id, b_box, root_pipeline_id, " +
                                    "question_id, synonym_id, model_registry, category, batch_id, is_ocr_field_comparable, " +
                                    "extracted_text, threshold, best_score, regex_pattern, candidates" +
                                    ") VALUES (" +
                                    ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                    ":originId, :groupId, :paperNo, :sorQuestion, :answer, :vqaScore, :score, :weight, " +
                                    ":sorItemAttributionId, :sorItemName, :documentId, :bBox, :rootPipelineId, " +
                                    ":questionId, :synonymId, :modelRegistry, :category, :batchId, :isOcrFieldComparable, " +
                                    ":extractedText, :threshold, :bestScore, :regexPattern, :candidates" +
                                    ");"
                    );

                    LocalDateTime now = LocalDateTime.now();
                    for (OcrTextComparatorInput result : batch) {
                        Long tenantId = result.getTenantId() != null ? result.getTenantId() : 1L;

                        preparedBatch
                                .bind("createdOn", executionStartTime)
                                .bind("createdUserId", tenantId)
                                .bind("lastUpdatedOn", now)
                                .bind("lastUpdatedUserId", tenantId)
                                .bind("tenantId", tenantId)
                                .bind("originId", result.getOriginId())
                                .bind("groupId", result.getGroupId())
                                .bind("paperNo", result.getPaperNo())
                                .bind("sorQuestion", result.getSorQuestion())
                                .bind("answer", result.getBestMatch())
                                .bind("vqaScore", result.getVqaScore())
                                .bind("score", result.getScore())
                                .bind("weight", result.getWeight())
                                .bind("sorItemAttributionId", result.getSorItemAttributionId())
                                .bind("sorItemName", result.getSorItemName())
                                .bind("documentId", result.getDocumentId())
                                .bind("bBox", result.getBBox())
                                .bind("rootPipelineId", result.getRootPipelineId())
                                .bind("questionId", result.getQuestionId())
                                .bind("synonymId", result.getSynonymId())
                                .bind("modelRegistry", result.getModelRegistry())
                                .bind("category", result.getCategory())
                                .bind("batchId", result.getBatchId())
                                .bind("isOcrFieldComparable", result.getIsOcrFieldComparable())
                                .bind("extractedText", result.getExtractedText())
                                .bind("threshold", result.getThreshold())
                                .bind("bestScore", result.getBestScore())
                                .bind("regexPattern", result.getRegexPattern())
                                .bind("candidates", "")
                                .add();
                    }

                    int[] batchResult = preparedBatch.execute();
                    log.info(aMarker, "inserted {} records", batchResult.length);
                });

                totalInserted += batch.size();
                log.info(aMarker, "Progress: {}/{} records inserted", totalInserted, results.size());

            } catch (Exception e) {
                log.error(aMarker, "Batch insert failed for batch #{} (records {}-{})",
                        batchCount, i, endIndex, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Batch insert failed for batch #" + batchCount,
                        handymanException, action);
            }
        }

        log.info(aMarker, "Batch insert completed - Total inserted: {}/{}, Batches: {}",
                totalInserted, results.size(), batchCount);
    }

    @Override
    public boolean executeIf() throws Exception {
        return ocrTextComparator != null && ocrTextComparator.getCondition();
    }
}