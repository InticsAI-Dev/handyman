package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.ocr.OcrComparisonAdapter;
import in.handyman.raven.lib.adapters.ocr.OcrComparisonAdapterFactory;
import in.handyman.raven.lib.adapters.ocr.OcrComparisonResult;
import in.handyman.raven.lib.adapters.ocr.OcrTextComparatorInput;
import in.handyman.raven.lib.model.OcrTextComparator;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven - Optimized Version
 */
@ActionExecution(
        actionName = "OcrTextComparator"
)
public class OcrTextComparatorAction implements IActionExecution {
    private static final String AES_256 = "AES256";
    private static final int BATCH_INSERT_SIZE = 100; // Configurable batch size

    private final ActionExecutionAudit action;
    private final Logger log;
    private LocalDateTime executionStartTime;
    private final OcrTextComparator ocrTextComparator;
    private final Marker aMarker;
    private final List<OcrTextComparatorInput> ocrTextComparatorInputs = new ArrayList<>();

    public OcrTextComparatorAction(final ActionExecutionAudit action, final Logger log,
                                   final Object ocrTextComparator) {
        this.ocrTextComparator = (OcrTextComparator) ocrTextComparator;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("OcrTextComparator:" + (ocrTextComparator != null ? this.ocrTextComparator.getName() : "unknown"));
    }

    @Override
    public void execute() throws Exception {
        try {
            this.executionStartTime = LocalDateTime.now();

            log.info(aMarker, "Starting OCR text comparator execution at: {}", executionStartTime);

            if (ocrTextComparator == null) {
                throw new HandymanException("OcrTextComparator configuration is null");
            }
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ocrTextComparator.getResourceConn());
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
            boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr != null ? pipelineEndToEndEncryptionActivatorStr : "false");

            String batchId = ocrTextComparator.getBatchId() != null ? ocrTextComparator.getBatchId() : "";
            String outputTableName = ocrTextComparator.getOutputTable() != null ? ocrTextComparator.getOutputTable() : "";
            int fuzzyMatchThresholdInt = Integer.parseInt(action.getContext().get("ocr.comparison.fuzzy.match.threshold"));
            double fuzzyMatchThreshold = fuzzyMatchThresholdInt / 100.0;

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(ocrTextComparator.getQuerySet());
                for (int i = 0; i < formattedQuery.size(); i++) {
                    String sqlToExecute = formattedQuery.get(i);
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i);
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<OcrTextComparatorInput> resultIterable = query.mapToBean(OcrTextComparatorInput.class);
                    List<OcrTextComparatorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                    ocrTextComparatorInputs.addAll(processingExecutorInputs);
                    log.info(aMarker, "Executed query from index {}", i);
                }
            });

            log.info(aMarker, "OCR text comparator action total rows returned from the query {}", ocrTextComparatorInputs.size());

            try {
                doOcrTextComparison(ocrTextComparatorInputs, jdbi, outputTableName, pipelineEndToEndEncryptionActivator,
                        batchId, encryption, fuzzyMatchThreshold);
            } catch (Exception e) {
                log.error(aMarker, "OCR text comparison failed for batchId: {}", batchId, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("OCR text comparison failed", handymanException, action);
            }

            log.info(aMarker, "OCR text comparator action has been completed {}", ocrTextComparator.getName());

        } catch (Exception e) {
            action.getContext().put(ocrTextComparator.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for OCR text comparator", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("OCR text comparator failed", handymanException, action);
        }
    }

    private void doOcrTextComparison(List<OcrTextComparatorInput> inputs, Jdbi jdbi, String outputTable,
                                     boolean pipelineEndToEndEncryptionActivator, String batchId,
                                     InticsIntegrity encryption, double fuzzyMatchThreshold) throws Exception {
        log.info(aMarker, "Starting OCR text comparison process for batchId: {}, totalInputs: {}", batchId, inputs.size());

        // Pre-filter inputs to process only comparable ones
        List<OcrTextComparatorInput> comparableInputs = inputs.stream()
                .filter(this::isComparable)
                .collect(Collectors.toList());

        log.info(aMarker, "Filtered comparable inputs: {}/{} for batchId: {}",
                comparableInputs.size(), inputs.size(), batchId);

        // Process inputs and collect results
        List<OcrTextComparatorInput> comparisonResults = new ArrayList<>(comparableInputs.size());
        int processedCount = 0;
        int errorCount = 0;

        for (OcrTextComparatorInput input : comparableInputs) {
            try {
                OcrTextComparatorInput result = processInput(input, pipelineEndToEndEncryptionActivator,
                        encryption, fuzzyMatchThreshold, batchId);
                comparisonResults.add(result);
                processedCount++;

                // Log every 100 records or at completion
                if (processedCount % 100 == 0 || processedCount == comparableInputs.size()) {
                    log.info(aMarker, "Processed {}/{} records for batchId: {}",
                            processedCount, comparableInputs.size(), batchId);
                }
            } catch (Exception e) {
                errorCount++;
                log.error(aMarker, "Processing failed for originId: {}, sorItemName: {}, paperNo: {}",
                        input.getOriginId(), input.getSorItemName(), input.getPaperNo(), e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Processing failed for originId: " + input.getOriginId() +
                        ", sorItemName: " + input.getSorItemName(), handymanException, action);
            }
        }

        log.info(aMarker, "Comparison phase completed - Processed: {}, Errors: {}, Results to insert: {}",
                processedCount, errorCount, comparisonResults.size());

        // Batch insert results
        if (!comparisonResults.isEmpty()) {
            batchInsertResults(jdbi, outputTable, comparisonResults);
        }

        // Log unprocessed inputs
        logUnprocessedInputs(inputs, comparableInputs);

        log.info(aMarker, "Completed OCR text comparison for batchId: {} - Total: {}, Processed: {}, Errors: {}",
                batchId, inputs.size(), processedCount, errorCount);
    }

    /**
     * Check if input is comparable
     */
    private boolean isComparable(OcrTextComparatorInput input) {
        Boolean isOcrFieldComparable = input.getIsOcrFieldComparable();
        return Boolean.TRUE.equals(isOcrFieldComparable)
                || "t".equalsIgnoreCase(String.valueOf(isOcrFieldComparable));
    }

    /**
     * Process a single input and return comparison result
     */
    private OcrTextComparatorInput processInput(OcrTextComparatorInput input,
                                                boolean pipelineEndToEndEncryptionActivator,
                                                InticsIntegrity encryption,
                                                double fuzzyMatchThreshold,
                                                String batchId) throws Exception {
        String originId = input.getOriginId() != null ? input.getOriginId() : "";
        String sorItemName = input.getSorItemName() != null ? input.getSorItemName() : "";
        Integer paperNo = input.getPaperNo() != null ? input.getPaperNo() : 0;

        log.debug(aMarker, "Processing originId: {}, sorItemName: {}, paperNo: {}",
                originId, sorItemName, paperNo);

        String answer = input.getAnswer() != null ? input.getAnswer() : "";
        String extractedText = input.getExtractedText() != null ? input.getExtractedText() : "";
        int bestScore = -1;
        String regexPattern = "NONE";
        String candidatesList = "";
        String bestMatch = answer;
        boolean isOcrFieldComparable = false;

        try {
            // Decrypt if necessary
            if ("true".equals(action.getContext().get("pipeline.deep.sift.encryption"))) {
                extractedText = encryption.decrypt(extractedText, AES_256, sorItemName);
                extractedText = extractedText != null ? extractedText : "";
            }

            if (pipelineEndToEndEncryptionActivator) {
                log.debug(aMarker, "Decrypting for originId: {}, sorItemName: {}, paperNo: {}",
                        originId, sorItemName, paperNo);
                answer = encryption.decrypt(answer, AES_256, sorItemName);
                answer = answer != null ? answer : "";
            }

            // Perform comparison
            String cleanedAnswer = answer.trim();
            String cleanedExtractedText = extractedText.trim();

            OcrComparisonAdapter adapter = OcrComparisonAdapterFactory.getAdapter(input.getAllowedAdapter());
            log.debug(aMarker, "Using adapter: {} for originId: {}, sorItemName: {}, paperNo: {}",
                    adapter.getName(), originId, sorItemName, paperNo);

            OcrComparisonResult result = adapter.compareValues(cleanedAnswer, cleanedExtractedText, fuzzyMatchThreshold);


            input.setBestScore(result.getBestScore());
            input.setRegexPattern(result.getMatchingMethod());
            input.setCandidatesList(result.getCandidatesList());
            input.setBestMatch(result.getBestMatch());
            input.setIsOcrFieldComparable(result.isMatch());

            if (input.getIsOcrFieldComparable()) {
                log.info(aMarker, "MATCH FOUND - originId: {}, sorItemName: {}, paperNo: {}, score: {}, threshold: {}",
                        originId, sorItemName, paperNo, bestScore, (int)(fuzzyMatchThreshold * 100));
            } else {
                log.info(aMarker, "NO MATCH - originId: {}, sorItemName: {}, paperNo: {}, score: {}, threshold: {}",
                        originId, sorItemName, paperNo, bestScore, (int)(fuzzyMatchThreshold * 100));
            }

            // Re-encrypt if necessary
            if ("true".equals(action.getContext().get("pipeline.deep.sift.encryption"))) {
                extractedText = encryption.encrypt(extractedText, AES_256, sorItemName);
                extractedText = extractedText != null ? extractedText : "";
            }

            if (pipelineEndToEndEncryptionActivator) {
                log.debug(aMarker, "Encrypting for originId: {}, sorItemName: {}, paperNo: {}",
                        originId, sorItemName, paperNo);
                bestMatch = encryption.encrypt(bestMatch, AES_256, sorItemName);
                bestMatch = bestMatch != null ? bestMatch : "";
                candidatesList = candidatesList.isEmpty() ? candidatesList : encryption.encrypt(candidatesList, AES_256, sorItemName);
                candidatesList = candidatesList != null ? candidatesList : "";
            }

        } catch (Exception e) {
            log.error(aMarker, "Processing error for originId: {}, sorItemName: {}, paperNo: {}",
                    originId, sorItemName, paperNo, e);
            input.setBestMatch(answer);
            input.setExtractedText(input.getExtractedText() != null ? input.getExtractedText() : "");
            input.setBestScore(1);
            input.setRegexPattern("PROCESSING_FAILED");
            input.setCandidatesList("");
            input.setIsOcrFieldComparable(false);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("Processing error for originId: " + originId +
                    ", sorItemName: " + sorItemName, handymanException, action);
        }

        int fuzzyMatchThresholdInt = (int)(fuzzyMatchThreshold * 100);
        return input;
    }

    /**
     * Batch insert comparison results
     */
    private void batchInsertResults(Jdbi jdbi, String outputTable, List<OcrTextComparatorInput> results) {
        log.info(aMarker, "Starting batch insert of {} records into {}", results.size(), outputTable);

        int totalInserted = 0;
        int batchCount = 0;

        // Process in batches
        for (int i = 0; i < results.size(); i += BATCH_INSERT_SIZE) {
            int endIndex = Math.min(i + BATCH_INSERT_SIZE, results.size());
            List<OcrTextComparatorInput> batch = results.subList(i, endIndex);
            batchCount++;

            try {
                jdbi.useHandle(handle -> {
                    PreparedBatch preparedBatch = handle.prepareBatch(
                            "INSERT INTO " + outputTable + " (" +
                                    "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                    "origin_id, group_id, paper_no, sor_question, answer, vqa_score, score, weight, " +
                                    "sor_item_attribution_id, sor_item_name, document_id, b_box, root_pipeline_id, " +
                                    "question_id, synonym_id, model_registry, category, batch_id, is_ocr_field_comparable, " +
                                    "extracted_text, threshold, best_score, regex_pattern, candidates" +
                                    ") VALUES (" +
                                    ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                    ":originId, :groupId, :paperNo, :sorQuestion, :answer, :vqaScore, :score, :weight, " +
                                    ":sorItemAttributionId, :sorItemName, :documentId, :bBox, :rootPipelineId, " +
                                    ":questionId, :synonymId, :modelRegistry, :category, :batchId, :isOcrFieldComparable, " +
                                    ":extractedText, :threshold, :bestScore, :regexPattern, :candidates" +
                                    ");"
                    );

                    LocalDateTime now = LocalDateTime.now();
                    for (OcrTextComparatorInput result : batch) {
                        Long tenantId = result.getTenantId() != null ? result.getTenantId() : 1L;

                        preparedBatch
                                .bind("createdOn", executionStartTime)
                                .bind("createdUserId", tenantId)
                                .bind("lastUpdatedOn", now)
                                .bind("lastUpdatedUserId", tenantId)
                                .bind("tenantId", tenantId)
                                .bind("originId", result.getOriginId())
                                .bind("groupId", result.getGroupId())
                                .bind("paperNo", result.getPaperNo())
                                .bind("sorQuestion", result.getSorQuestion())
                                .bind("answer", result.getBestMatch())
                                .bind("vqaScore", result.getVqaScore())
                                .bind("score", result.getScore())
                                .bind("weight", result.getWeight())
                                .bind("sorItemAttributionId", result.getSorItemAttributionId())
                                .bind("sorItemName", result.getSorItemName())
                                .bind("documentId", result.getDocumentId())
                                .bind("bBox", result.getBBox())
                                .bind("rootPipelineId", result.getRootPipelineId())
                                .bind("questionId", result.getQuestionId())
                                .bind("synonymId", result.getSynonymId())
                                .bind("modelRegistry", result.getModelRegistry())
                                .bind("category", result.getCategory())
                                .bind("batchId", result.getBatchId())
                                .bind("isOcrFieldComparable", result.getIsOcrFieldComparable())
                                .bind("extractedText", result.getExtractedText())
                                .bind("threshold", result.getThreshold())
                                .bind("bestScore", result.getBestScore())
                                .bind("regexPattern", result.getRegexPattern())
                                .bind("candidates", result.getCandidatesList())
                                .add();
                    }

                    int[] batchResult = preparedBatch.execute();
                    log.info(aMarker, "inserted {} records", batchResult.length);
                });

                totalInserted += batch.size();
                log.info(aMarker, "Progress: {}/{} records inserted", totalInserted, results.size());

            } catch (Exception e) {
                log.error(aMarker, "Batch insert failed for batch #{} (records {}-{})",
                        batchCount, i, endIndex, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Batch insert failed for batch #" + batchCount,
                        handymanException, action);
            }
        }

        log.info(aMarker, "Batch insert completed - Total inserted: {}/{}, Batches: {}",
                totalInserted, results.size(), batchCount);
    }

    /**
     * Log inputs that were not processed
     */
    private void logUnprocessedInputs(List<OcrTextComparatorInput> allInputs,
                                      List<OcrTextComparatorInput> processedInputs) {
        int unprocessedCount = allInputs.size() - processedInputs.size();

        if (unprocessedCount > 0) {
            log.info(aMarker, "Unprocessed inputs count: {}/{}", unprocessedCount, allInputs.size());

            // Sample log for unprocessed items (first 5)
            allInputs.stream()
                    .filter(input -> !isComparable(input))
                    .limit(5)
                    .forEach(input -> log.debug(aMarker,
                            "Skipped - originId: {}, sorItemName: {}, paperNo: {}, isComparable: {}",
                            input.getOriginId(), input.getSorItemName(), input.getPaperNo(),
                            input.getIsOcrFieldComparable()));

            if (unprocessedCount > 5) {
                log.debug(aMarker, "... and {} more unprocessed records", unprocessedCount - 5);
            }
        }
    }

    @Override
    public boolean executeIf() throws Exception {
        return ocrTextComparator != null && ocrTextComparator.getCondition();
    }
}
