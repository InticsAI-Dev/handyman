package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.ocr.OcrComparisonAdapter;
import in.handyman.raven.lib.adapters.ocr.OcrComparisonAdapterFactory;
import in.handyman.raven.lib.adapters.ocr.OcrComparisonResult;
import in.handyman.raven.lib.adapters.ocr.OcrTextComparatorInput;
import in.handyman.raven.lib.model.OcrTextComparator;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "OcrTextComparator"
)
public class OcrTextComparatorAction implements IActionExecution {
    private static final String AES_256 = "AES256";
    private final ActionExecutionAudit action;
    private final Logger log;
    private LocalDateTime executionStartTime;
    private final OcrTextComparator ocrTextComparator;
    private final Marker aMarker;
    private final List<OcrTextComparatorInput> ocrTextComparatorInputs = new ArrayList<>();

    public OcrTextComparatorAction(final ActionExecutionAudit action, final Logger log,
                                   final Object ocrTextComparator) {
        this.ocrTextComparator = (OcrTextComparator) ocrTextComparator;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("OcrTextComparator:" + (ocrTextComparator != null ? this.ocrTextComparator.getName() : "unknown"));
    }

    @Override
    public void execute() throws Exception {
        try {
            this.executionStartTime = LocalDateTime.now();

            log.info(aMarker, "Starting OCR text comparator execution at: {}", executionStartTime);

            if (ocrTextComparator == null) {
                throw new HandymanException("OcrTextComparator configuration is null");
            }
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ocrTextComparator.getResourceConn());
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
            boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr != null ? pipelineEndToEndEncryptionActivatorStr : "false");

            String batchId = ocrTextComparator.getBatchId() != null ? ocrTextComparator.getBatchId() : "";
            String outputTableName = ocrTextComparator.getOutputTable() != null ? ocrTextComparator.getOutputTable() : "";
            int fuzzyMatchThresholdInt = Integer.parseInt(action.getContext().get("ocr.comparison.fuzzy.match.threshold"));
            double fuzzyMatchThreshold = fuzzyMatchThresholdInt / 100.0;

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(ocrTextComparator.getQuerySet());
                for (int i = 0; i < formattedQuery.size(); i++) {
                    String sqlToExecute = formattedQuery.get(i);
                    log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i);
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<OcrTextComparatorInput> resultIterable = query.mapToBean(OcrTextComparatorInput.class);
                    List<OcrTextComparatorInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
                    ocrTextComparatorInputs.addAll(processingExecutorInputs);
                    log.info(aMarker, "Executed query from index {}", i);
                }
            });

            log.info(aMarker, "OCR text comparator action total rows returned from the query {}", ocrTextComparatorInputs.size());

            try {
                doOcrTextComparison(ocrTextComparatorInputs, jdbi, outputTableName, pipelineEndToEndEncryptionActivator,
                        batchId, encryption, fuzzyMatchThreshold);
            } catch (Exception e) {
                log.error(aMarker, "OCR text comparison failed for batchId: {}", batchId, e);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("OCR text comparison failed", handymanException, action);
            }

            log.info(aMarker, "OCR text comparator action has been completed {}", ocrTextComparator.getName());

        } catch (Exception e) {
            action.getContext().put(ocrTextComparator.getName() + ".isSuccessful", "false");
            log.error(aMarker, "Error in execute method for OCR text comparator", e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("OCR text comparator failed", handymanException, action);
        }
    }

    private void doOcrTextComparison(List<OcrTextComparatorInput> inputs, Jdbi jdbi, String outputTable,
                                     boolean pipelineEndToEndEncryptionActivator, String batchId,
                                     InticsIntegrity encryption, double fuzzyMatchThreshold) throws Exception {
        log.info(aMarker, "Starting OCR text comparison process for batchId: {}, totalInputs: {}", batchId, inputs.size());

        List<String> processedKeys = new ArrayList<>();

        inputs.forEach(input -> {
            String originId = input.getOriginId() != null ? input.getOriginId() : "";
            String sorItemName = input.getSorItemName() != null ? input.getSorItemName() : "";
            String key = originId + "|" + sorItemName;
            synchronized (processedKeys) {
                processedKeys.add(key);
            }

            log.debug(aMarker, "Processing input: originId={}, sorItemName={}", originId, sorItemName);

            Integer selectedPageNo = input.getPaperNo() != null ? input.getPaperNo() : 0;
            boolean isOcrFieldComparable = false;
            String answer = input.getAnswer() != null ? input.getAnswer() : "";
            String extractedText = input.getExtractedText() != null ? input.getExtractedText() : "";
            int bestScore = -1;
            String regexPattern = "NONE";
            String candidatesList = "";
            String bestMatch = answer;

            Boolean isOcrFieldComparableValue = input.getIsOcrFieldComparable();
            if (Boolean.TRUE.equals(isOcrFieldComparableValue) || "t".equalsIgnoreCase(String.valueOf(isOcrFieldComparableValue))) {
                log.debug(aMarker, "Performing OCR comparison for sorItemName={} (is_ocr_field_comparable={})",
                        sorItemName, isOcrFieldComparableValue);

                try {
                    String encryptionPolicy = input.getEncryptionPolicy() != null ? input.getEncryptionPolicy() : "";

                    if (pipelineEndToEndEncryptionActivator) {
                        log.info(aMarker, "Decrypting extracted_text with AES256 and answer with policy for originId={}, sorItemName={}",
                                originId, sorItemName);
                        extractedText = encryption.decrypt(extractedText, AES_256, sorItemName);
                        extractedText = extractedText != null ? extractedText : "";
                        answer = encryption.decrypt(answer, encryptionPolicy, sorItemName);
                        answer = answer != null ? answer : "";
                        log.debug(aMarker, "Decrypted answer and extracted_text for originId={}, sorItemName={}", originId, sorItemName);
                    }

                    // Clean the texts (trim only, as specific cleaning is handled by adapter)
                    String cleanedAnswer = answer.trim();
                    String cleanedExtractedText = extractedText.trim();

                    log.debug(aMarker, "Cleaned extracted text length: {}", cleanedExtractedText.length());

                    OcrComparisonAdapter adapter = OcrComparisonAdapterFactory.getAdapter(input.getAllowedAdapter());
                    log.debug(aMarker, "Using adapter: {} for sorItemName={}", adapter.getName(), sorItemName);

                    OcrComparisonResult result = adapter.compareValues(cleanedAnswer, cleanedExtractedText, fuzzyMatchThreshold);

                    bestScore = result.getBestScore();
                    regexPattern = result.getMatchingMethod();
                    candidatesList = result.getCandidatesList();
                    bestMatch = result.getBestMatch();
                    isOcrFieldComparable = result.isMatch();

                    if (isOcrFieldComparable) {
                        log.info(aMarker, "MATCH FOUND - Using adapter value  (score: {} > threshold: {}) for originId={}, sorItemName={}",
                                 bestScore, fuzzyMatchThreshold, originId, sorItemName);
                    } else {
                        log.info(aMarker, "NO MATCH - Using original value (score: {} <= threshold: {}) for originId={}, sorItemName={}", bestScore, fuzzyMatchThreshold, originId, sorItemName);
                    }

                    if (pipelineEndToEndEncryptionActivator) {
                        try {
                            log.info(aMarker, "Encrypting final answer and extracted_text for originId={}, sorItemName={}", originId, sorItemName);
                            extractedText = encryption.encrypt(extractedText, AES_256, sorItemName);
                            extractedText = extractedText != null ? extractedText : "";
                            bestMatch = encryption.encrypt(bestMatch, encryptionPolicy, sorItemName);
                            bestMatch = bestMatch != null ? bestMatch : "";
                            candidatesList = candidatesList.isEmpty() ? candidatesList : encryption.encrypt(candidatesList, AES_256, sorItemName);
                            candidatesList = candidatesList != null ? candidatesList : "";
                            log.info(aMarker, "Encrypted answer and extracted_text for originId={}, sorItemName={}", originId, sorItemName);
                        } catch (Exception e) {
                            log.error(aMarker, "Encryption failed for originId={}, sorItemName={}: {}", originId, sorItemName, e.getMessage());
                            bestMatch = answer;
                            extractedText = input.getExtractedText() != null ? input.getExtractedText() : "";
                            candidatesList = "";
                        }
                    }
                } catch (Exception e) {
                    log.error(aMarker, "Processing failed for originId={}, sorItemName={}: {}", originId, sorItemName, e.getMessage());
                    HandymanException handymanException = new HandymanException(e);
                    HandymanException.insertException("Processing failed for originId: " + originId + ", sorItemName: " + sorItemName, handymanException, action);
                    bestMatch = answer;
                    extractedText = input.getExtractedText() != null ? input.getExtractedText() : "";
                    bestScore = -1;
                    regexPattern = "PROCESSING_FAILED";
                    candidatesList = "";
                }
            } else {
                log.debug(aMarker, "Skipping OCR comparison for originId={}, sorItemName={} as is_ocr_field_comparable is {} (not 't' or true)",
                        originId, sorItemName, isOcrFieldComparableValue == null ? "null" : isOcrFieldComparableValue);
                bestMatch = answer;
                bestScore = -1;
                regexPattern = "SKIPPED";
                candidatesList = "";
            }

            try {
                insertExecutionInfo(
                        jdbi, outputTable,
                        originId, sorItemName, input.getTenantId(), batchId,
                        input.getSorQuestion() != null ? input.getSorQuestion() : "",
                        bestMatch, isOcrFieldComparable, input.getGroupId() != null ? input.getGroupId() : 0,
                        selectedPageNo, input.getVqaScore(), input.getScore(), input.getWeight(),
                        input.getSorItemAttributionId(), input.getDocumentId() != null ? input.getDocumentId() : "",
                        input.getBBox() != null ? input.getBBox() : "",
                        input.getRootPipelineId(), input.getQuestionId(), input.getSynonymId(),
                        input.getModelRegistry() != null ? input.getModelRegistry() : "",
                        input.getCategory() != null ? input.getCategory() : "",
                        extractedText, (int) (fuzzyMatchThreshold * 100), bestScore, regexPattern, candidatesList
                );

                log.info(aMarker, "Inserted result for originId={}, sorItemName={}, paperNo={}, isOcrFieldComparable={}, threshold={}, bestScore={}, regexPattern={}}",
                        originId, sorItemName, selectedPageNo, isOcrFieldComparable,
                        fuzzyMatchThreshold, bestScore, regexPattern);
            } catch (Exception e) {
                log.error(aMarker, "Insert failed for originId={}, sorItemName={}: {}", originId, sorItemName, e.getMessage());
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("Error inserting for originId " + originId + ", sorItemName " + sorItemName, handymanException, action);
            }
        });

        ocrTextComparatorInputs.stream()
                .filter(input -> !processedKeys.contains((input.getOriginId() != null ? input.getOriginId() : "") + "|" + (input.getSorItemName() != null ? input.getSorItemName() : "")))
                .forEach(input -> {
                    log.warn(aMarker, "Input not processed for originId={}, sorItemName={}",
                            input.getOriginId() != null ? input.getOriginId() : "null",
                            input.getSorItemName() != null ? input.getSorItemName() : "null");
                });

        log.info(aMarker, "Completed OCR text comparison for batchId: {}", batchId);
    }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, String sorItemName, Long tenantId,
                                     String batchId, String sorQuestion, String answer, boolean isOcrFieldComparable,
                                     Integer groupId, Integer paperNo, Double vqaScore, Double score, Integer weight,
                                     Integer sorItemAttributionId, String documentId, String bBox, Long rootPipelineId,
                                     Long questionId, Long synonymId, String modelRegistry, String category,
                                     String extractedText, int threshold, int bestScore, String regexPattern,
                                     String candidatesList) {
        if (tenantId == null) {
            log.warn(aMarker, "tenantId is null for originId={}, sorItemName={}, setting to default 1", originId, sorItemName);
            tenantId = 1L;
        }
        Long finalTenantId = tenantId;
        jdbi.useHandle(handle -> handle.createUpdate(
                        "INSERT INTO " + outputTable + " (" +
                                "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                "origin_id, group_id, paper_no, sor_question, answer, vqa_score, score, weight, " +
                                "sor_item_attribution_id, sor_item_name, document_id, b_box, root_pipeline_id, " +
                                "question_id, synonym_id, model_registry, category, batch_id, is_ocr_field_comparable, " +
                                "extracted_text, threshold, best_score, regex_pattern, candidates" +
                                ") VALUES (" +
                                ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                ":originId, :groupId, :paperNo, :sorQuestion, :answer, :vqaScore, :score, :weight, " +
                                ":sorItemAttributionId, :sorItemName, :documentId, :bBox, :rootPipelineId, " +
                                ":questionId, :synonymId, :modelRegistry, :category, :batchId, :isOcrFieldComparable, " +
                                ":extractedText, :threshold, :bestScore, :regexPattern, :candidates" +
                                ");")
                .bind("createdOn", executionStartTime)
                .bind("createdUserId", finalTenantId)
                .bind("lastUpdatedOn", LocalDateTime.now())
                .bind("lastUpdatedUserId", finalTenantId)
                .bind("tenantId", finalTenantId)
                .bind("originId", originId)
                .bind("groupId", groupId)
                .bind("paperNo", paperNo)
                .bind("sorQuestion", sorQuestion)
                .bind("answer", answer)
                .bind("vqaScore", vqaScore)
                .bind("score", score)
                .bind("weight", weight)
                .bind("sorItemAttributionId", sorItemAttributionId)
                .bind("sorItemName", sorItemName)
                .bind("documentId", documentId)
                .bind("bBox", bBox)
                .bind("rootPipelineId", rootPipelineId)
                .bind("questionId", questionId)
                .bind("synonymId", synonymId)
                .bind("modelRegistry", modelRegistry)
                .bind("category", category)
                .bind("batchId", batchId)
                .bind("isOcrFieldComparable", isOcrFieldComparable)
                .bind("extractedText", extractedText)
                .bind("threshold", threshold)
                .bind("bestScore", bestScore)
                .bind("regexPattern", regexPattern)
                .bind("candidates", candidatesList)
                .execute());
        log.info(aMarker, "Inserted comparison result for originId={}, sorItemName={}", originId, sorItemName);
    }

    @Override
    public boolean executeIf() throws Exception {
        return ocrTextComparator != null && ocrTextComparator.getCondition();
    }
}