package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.JavaQuestionVerseOnboard;
import lombok.*;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "JavaQuestionVerseOnboard"
)
public class JavaQuestionVerseOnboardAction implements IActionExecution {

    private final ActionExecutionAudit action;

    private final Logger log;

    private final JavaQuestionVerseOnboard javaQuestionVerseOnboard;

    private final Marker aMarker;

    public JavaQuestionVerseOnboardAction(final ActionExecutionAudit action, final Logger log,
                                          final Object javaQuestionVerseOnboard) {
        this.javaQuestionVerseOnboard = (JavaQuestionVerseOnboard) javaQuestionVerseOnboard;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" JavaQuestionVerseOnboard:" + this.javaQuestionVerseOnboard.getName());
    }

    private static final String STATUS = "ACTIVE";
    private static final int VERSION = 1;
    private static final int PRIORITY_INDEX = 1;
    private static final String CATEGORY = "PRIMARY";
    private static final int QUESTION_WEIGHT = 100;

    private static final String DOCUMENT_TYPE_MASTER_DATA_ID_COLUMN = "document_type_master_data_id";
    private static final String DOCUMENT_ID_COLUMN = "document_id";
    private static final String CHANNEL_ID_COLUMN = "asset_id";
    private static final String TRUTH_ENTITY_ID_COLUMN = "truth_entity_id";
    private static final String SYNONYM_ID_COLUMN = "synonym_id";
    private static final String QUESTION_ID_COLUMN = "question_id";

    @Override
    public void execute() throws Exception {
        String javaTestCaseGeneratorName = javaQuestionVerseOnboard.getName();
        log.info(aMarker, "Java QuestionVerse Onboard Action for {} has been started", javaTestCaseGeneratorName);

        String resourceConn = javaQuestionVerseOnboard.getResourceConn();
        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(resourceConn);

        try {

            JavaQuestionVerseOnboardQueryResult javaQuestionVerseOnboardQueryResult = jdbi.withHandle(handle -> handle.createQuery(javaQuestionVerseOnboard.getQuerySet()).mapToBean(JavaQuestionVerseOnboardQueryResult.class).one());
            String projectPath = javaQuestionVerseOnboardQueryResult.getFolderPath();
            String documentType = javaQuestionVerseOnboardQueryResult.getDocumentType();
            Long tenantId = javaQuestionVerseOnboardQueryResult.getTenantId();
            Long userId = javaQuestionVerseOnboardQueryResult.getUserId();

            String defaultPrompt = javaQuestionVerseOnboardQueryResult.getDefaultPrompt();
            String schemaName = javaQuestionVerseOnboard.getSchemaName();
            String sipType = javaQuestionVerseOnboardQueryResult.getSipType();
            Long modelRegistryId = javaQuestionVerseOnboardQueryResult.getModelRegistryId();

            List<Channel> channels = scanProject(projectPath, defaultPrompt);

            String documentMasterDataInsertQuery = getDocumentTypeMasterDataInsertQuery(schemaName);
            String documentInsertQuery = getDocumentInsertQuery(schemaName);
            String channelInsertQuery = getChannelInsertQuery(schemaName);
            String sipInsertQuery = getSipInsertQuery(schemaName);
            String synonymInsertQuery = getSynonymInsertQuery(schemaName);
            String questionInsertQuery = getQuestionInsertQuery(schemaName);

            Long documentTypeMasterId = insertDocumentMasterData(jdbi, documentType, schemaName, userId, documentMasterDataInsertQuery);
            if (documentTypeMasterId != null) {
                doDocumentTypeInsertion(jdbi, documentType, documentTypeMasterId, tenantId, schemaName, userId, documentInsertQuery, channels, channelInsertQuery, sipType, sipInsertQuery, synonymInsertQuery, modelRegistryId, questionInsertQuery);
            }
        } catch (IOException e) {
            log.info("Error scanning project: {}", e.getMessage());
            throw new HandymanException("Error scanning project: {}", e, action);
        }
    }

    private void doDocumentTypeInsertion(Jdbi jdbi, String documentType, Long documentTypeMasterId, Long tenantId, String schemaName, Long userId, String documentInsertQuery, List<Channel> channels, String channelInsertQuery, String sipType, String sipInsertQuery, String synonymInsertQuery, Long modelRegistryId, String questionInsertQuery) {
        Long documentId = insertDocument(jdbi, documentType, documentTypeMasterId, tenantId, schemaName, userId, documentInsertQuery);
        if (documentId != null) {
            for (Channel channel : channels) {
                if (Objects.nonNull(channel.packageName)) {
                    insertChannel(jdbi, documentType, channel, tenantId, schemaName, userId, channelInsertQuery);
                    for (SIP sip : channel.sips) {
                        if (Objects.nonNull(sip.className)) {
                            Long channelId = channel.getChannelId();
                            if (channelId != null && channelId != -1L) {
                                insertSip(jdbi, channelId, sip, tenantId, sipType, schemaName, userId, sipInsertQuery);
                                Long truthEntityId = sip.getTruthEntityId();
                                if (truthEntityId != null && truthEntityId != -1L) {
                                    for (Synonym synonym : sip.synonyms) {
                                        insertSynonym(jdbi, truthEntityId, synonym, tenantId, schemaName, userId, synonymInsertQuery);
                                        Long synonymId = synonym.getSynonymId();
                                        insertQuestion(jdbi, synonymId, synonym.question, tenantId, userId, modelRegistryId, questionInsertQuery, schemaName);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    @Override
    public boolean executeIf() throws Exception {
        return javaQuestionVerseOnboard.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class JavaQuestionVerseOnboardQueryResult {

        private String folderPath;
        private String projectType;
        private String documentType;
        private String defaultPrompt;
        private Long tenantId;
        private Long userId;
        private String sipType;
        private Long modelRegistryId;
    }


    public List<Channel> scanProject(String projectPath, String defaultPrompt) throws IOException {
        List<Channel> channels = new ArrayList<>();
        Path projectDir = Paths.get(projectPath);
        try (Stream<Path> paths = Files.walk(projectDir)) {
            paths.filter(path -> path.toString().endsWith(".java"))
                    .forEach(path -> processJavaFile(path, projectDir, channels, defaultPrompt));
            return channels;
        }
    }

    private void processJavaFile(Path path, Path projectDir, List<Channel> channels, String defaultPrompt) {
        String relativePath = projectDir.relativize(path).toString();
        String packageName = getPackageName(relativePath);
        String className = getClassName(path);

        Channel channel = channels.stream()
                .filter(c -> c.packageName.equals(packageName))
                .findFirst()
                .orElseGet(() -> {
                    Channel newChannel = new Channel();
                    newChannel.packageName = packageName;
                    channels.add(newChannel);
                    return newChannel;
                });

        SIP sip = new SIP();
        sip.className = className;
        channel.sips.add(sip);

        try {

            JavaParser javaParser = new JavaParser();
            FileInputStream in = new FileInputStream(path.toFile());

            CompilationUnit compilationUnit = new CompilationUnit();
            Optional<CompilationUnit> optionalCompilationUnit = javaParser.parse(in).getResult();
            if (optionalCompilationUnit.isPresent()) {
                compilationUnit = optionalCompilationUnit.get();
            } else {
                log.error("Could not parse the file for reading method names");
            }

            // Create a MethodVisitor instance
            MethodVisitor methodVisitor = new MethodVisitor();

            // Visit methods
            methodVisitor.visit(compilationUnit, null);

            // Get the method signatures
            List<String> methodNames = methodVisitor.getMethodSignatures();

            for (String methodName : methodNames) {
                Synonym synonym = new Synonym();
                synonym.methodName = methodName;
                synonym.question = new Question();
                synonym.question.prompt = defaultPrompt;
                sip.synonyms.add(synonym);
            }
        } catch (IOException e) {
            log.info("Could not read file: {}", path);
            throw new HandymanException("Could not read file: " + path, e, action);
        }
    }

    private static String getPackageName(String relativePath) {
        String[] parts = relativePath.split(FileSystems.getDefault().getSeparator());
        return String.join(".", parts).substring(0, relativePath.lastIndexOf(FileSystems.getDefault().getSeparator())).replace(".java", "");
    }

    private static String getClassName(Path path) {
        String fileName = path.getFileName().toString();
        return fileName.substring(0, fileName.lastIndexOf('.'));
    }

    private static List<String> extractMethodsWithParameters(List<String> lines) {
        return lines.stream()
                .filter(line -> line.contains("public") || line.contains("private") || line.contains("protected"))
                .filter(line -> line.contains("(") && line.contains(")") && line.contains("{"))
                .map(line -> {
                    int start = line.lastIndexOf(' ', line.indexOf('(')) + 1;
                    int end = line.indexOf('{');
                    return line.substring(start, end).trim();
                })
                .collect(Collectors.toList());
    }

    @Getter
    private static class MethodVisitor extends VoidVisitorAdapter<Void> {
        private final List<String> methodSignatures = new ArrayList<>();

        @Override
        public void visit(MethodDeclaration md, Void arg) {
            super.visit(md, arg);
            methodSignatures.add(getMethodSignature(md));
        }

        private String getMethodSignature(MethodDeclaration md) {
            StringBuilder methodSignature = new StringBuilder();
            methodSignature.append(md.getName())
                    .append("(");

            md.getParameters().forEach(parameter -> {
                if (parameter.isFinal()) {
                    methodSignature.append("final ");
                }
                methodSignature.append(parameter.getType())
                        .append(" ")
                        .append(parameter.getName())
                        .append(", ");
            });

            // Remove the trailing comma and space if parameters exist
            if (!md.getParameters().isEmpty()) {
                methodSignature.setLength(methodSignature.length() - 2);
            }

            methodSignature.append(")");

            return methodSignature.toString();
        }

    }

    private Long insertDocumentMasterData(final Jdbi jdbi, String documentType, String schemaName, Long userId, String documentMasterDataInsertQuery) {
        try (Handle handle = jdbi.open()) {
            Optional<Map<String, Object>> insertedRowOptional = handle.createUpdate(documentMasterDataInsertQuery)
                    .bind(0, userId)
                    .bind(1, userId)
                    .bind(2, STATUS)
                    .bind(3, VERSION)
                    .bind(4, documentType)
                    .executeAndReturnGeneratedKeys()
                    .mapToMap()
                    .findFirst();

            if (insertedRowOptional.isPresent()) {
                Map<String, Object> insertedRow = insertedRowOptional.get();
                if (insertedRow.containsKey(DOCUMENT_TYPE_MASTER_DATA_ID_COLUMN)) {
                    return (Long) insertedRow.get(DOCUMENT_TYPE_MASTER_DATA_ID_COLUMN);
                }
            } else {
                String fileIdQuery = "SELECT document_type_master_data_id from " + schemaName + ".document_type_master_data where document_type = '" + documentType + "' limit 1";
                return handle.createQuery(fileIdQuery)
                        .mapTo(Long.class)
                        .one();

            }
        }
        return null;
    }

    private @NotNull String getDocumentTypeMasterDataInsertQuery(String schemaName) {
        String documentTypeMasterDataInsertQuery = "INSERT INTO " + schemaName + ".document_type_master_data " +
                "(created_on, created_user_id, last_updated_on, last_updated_user_id, status, \"version\", document_type) " +
                "VALUES (now(), ?, now(), ?, ?, ?, ?) " +
                "ON CONFLICT (document_type) DO NOTHING " +
                "RETURNING *";
        log.info("found document type master data insert query: {}", documentTypeMasterDataInsertQuery);
        return documentTypeMasterDataInsertQuery;
    }


    private Long insertDocument(final Jdbi jdbi, String documentType, Long documentTypeMasterId, Long tenantId, String schemaName, Long userId, String documentInsertQuery) {
        try (Handle handle = jdbi.open()) {
            Optional<Map<String, Object>> insertedRowOptional = handle.createUpdate(documentInsertQuery)
                    .bind(0, documentType)
                    .bind(1, tenantId)
                    .bind(2, userId)
                    .bind(3, userId)
                    .bind(4, STATUS)
                    .bind(5, VERSION)
                    .bind(6, documentType)
                    .bind(7, documentType)
                    .bind(8, documentTypeMasterId)
                    .executeAndReturnGeneratedKeys()
                    .mapToMap()
                    .findFirst();

            if (insertedRowOptional.isPresent()) {
                Map<String, Object> insertedRow = insertedRowOptional.get();
                if (insertedRow.containsKey(DOCUMENT_ID_COLUMN)) {
                    return (Long) insertedRow.get(DOCUMENT_ID_COLUMN);
                }
            } else {
                String fileIdQuery = "SELECT document_id from " + schemaName + ".document where document_type = '" + documentType + "' and tenant_id = " + tenantId + " and document_type_master_data_id = " + documentTypeMasterId + " limit 1";
                return handle.createQuery(fileIdQuery)
                        .mapTo(Long.class)
                        .one();
            }
        }
        return null;
    }

    private @NotNull String getDocumentInsertQuery(String schemaName) {
        String documentTypeInsertQuery = "INSERT INTO " + schemaName + ".document " +
                "(document_type, tenant_id, created_on, created_user_id, last_updated_on, last_updated_user_id, status, \"version\", description, document_name, document_type_master_data_id) " +
                "VALUES (?, ?, now(), ?, now(), ?, ?, ?, ?, ?, ?) " +
                "ON CONFLICT (document_type, tenant_id) DO NOTHING; ";
        log.info("found document type insert query: {}", documentTypeInsertQuery);
        return documentTypeInsertQuery;
    }


    private void insertChannel(Jdbi jdbi, String documentType, Channel channel, Long tenantId, String schemaName, Long userId, String channelInsertQuery) {
        try (Handle handle = jdbi.open()) {
            String channelName = channel.getPackageName();
            List<Map<String, Object>> insertedRows = handle.createUpdate(channelInsertQuery)
                    .bind(0, userId)
                    .bind(1, userId)
                    .bind(2, tenantId)
                    .bind(3, VERSION)
                    .bind(4, channelName)
                    .bind(5, STATUS)
                    .bind(6, documentType)
                    .executeAndReturnGeneratedKeys()
                    .mapToMap()
                    .list();

            Optional<Map<String, Object>> optionalFoundRow = findRowByColumnValue(insertedRows, "template_name", channelName);
            if (optionalFoundRow.isPresent()) {
                Map<String, Object> foundRow = optionalFoundRow.get();
                Object desiredColumn = foundRow.get(CHANNEL_ID_COLUMN);
                channel.setChannelId((Long) desiredColumn);
            } else {
                String fileIdQuery = "SELECT asset_id from " + schemaName + ".asset_info where template_name= '" + channelName + "' and document_type = '" + documentType + "' and tenant_id = " + tenantId + " limit 1";
                Long channelId = handle.createQuery(fileIdQuery)
                        .mapTo(Long.class)
                        .one();
                channel.setChannelId(channelId);
            }
        }
    }

    private @NotNull String getChannelInsertQuery(String schemaName) {
        String channelInsertQuery = "INSERT INTO " + schemaName + ".asset_info (created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, \"version\", template_name, status, document_type) " +
                "VALUES (now(),?,now(),?,?,?,?,?,?) " +
                "ON CONFLICT (document_type, template_name, tenant_id) DO NOTHING ";
        log.info("found channel insert query {}", channelInsertQuery);
        return channelInsertQuery;
    }


    private void insertSip(Jdbi jdbi, Long channelId, SIP sip, Long tenantId, String sipType, String schemaName, Long userId, String sipInsertQuery) {
        try (Handle handle = jdbi.open()) {
            String truthEntityName = sip.getClassName();
            List<Map<String, Object>> insertedRows = handle.createUpdate(sipInsertQuery)
                    .bind(0, truthEntityName)
                    .bind(1, channelId)
                    .bind(2, userId)
                    .bind(3, userId)
                    .bind(4, STATUS)
                    .bind(5, tenantId)
                    .bind(6, VERSION)
                    .bind(7, sipType)
                    .executeAndReturnGeneratedKeys()
                    .mapToMap()
                    .list();

            Optional<Map<String, Object>> optionalFoundRow = findRowByColumnValue(insertedRows, "truth_entity_name", truthEntityName);
            if (optionalFoundRow.isPresent()) {
                Map<String, Object> foundRow = optionalFoundRow.get();
                Object desiredColumnValue = foundRow.get(TRUTH_ENTITY_ID_COLUMN);
                sip.setTruthEntityId((Long) desiredColumnValue);
            } else {
                String fileIdQuery = "SELECT truth_entity_id from " + schemaName + ".truth_entity where truth_entity_name = '" + truthEntityName + "' and asset_id = " + channelId + " and tenant_id = " + tenantId + " limit 1";
                Long truthId = handle.createQuery(fileIdQuery)
                        .mapTo(Long.class)
                        .one();
                sip.setTruthEntityId(truthId);
            }
        }
    }

    private @NotNull String getSipInsertQuery(String schemaName) {
        String sipInsertQuery = "INSERT INTO " + schemaName + ".truth_entity (truth_entity_name, asset_id, created_on, created_user_id, last_updated_on, last_updated_user_id, status, tenant_id, \"version\", sip_type)" +
                "VALUES (?, ?, now(), ?, now(), ?, ?, ?, ?, ?)" +
                "ON CONFLICT (truth_entity_name, asset_id, tenant_id) DO NOTHING " +
                "RETURNING *";
        log.info("found sip insert query {}", sipInsertQuery);
        return sipInsertQuery;
    }

    private void insertSynonym(Jdbi jdbi, Long truthEntityId, Synonym synonym, Long tenantId, String schemaName, Long userId, String synonymInsertQuery) {
        try (Handle handle = jdbi.open()) {
            String synonymName = synonym.getMethodName();
            List<Map<String, Object>> insertedRows = handle.createUpdate(synonymInsertQuery)
                    .bind(0, synonymName)
                    .bind(1, truthEntityId)
                    .bind(2, userId)
                    .bind(3, userId)
                    .bind(4, STATUS)
                    .bind(5, "CODE")
                    .bind(6, PRIORITY_INDEX)
                    .bind(7, CATEGORY)
                    .bind(8, tenantId)
                    .bind(9, VERSION)
                    .executeAndReturnGeneratedKeys()
                    .mapToMap()
                    .list();

            Optional<Map<String, Object>> optionalFoundRow = findRowByColumnValue(insertedRows, "synonym", synonymName);
            if (optionalFoundRow.isPresent()) {
                Map<String, Object> foundRow = optionalFoundRow.get();
                Object desiredColumnValue = foundRow.get(SYNONYM_ID_COLUMN);
                synonym.setSynonymId((Long) desiredColumnValue);
            } else {
                String fileIdQuery = "SELECT synonym_id from " + schemaName + ".sor_tsynonym where  synonym = '" + synonymName + "' and truth_entity_id = " + truthEntityId + " and tenant_id = " + tenantId + " limit 1";
                Long synonymId = handle.createQuery(fileIdQuery)
                        .mapTo(Long.class)
                        .one();
                synonym.setSynonymId(synonymId);
            }
        }
    }

    private @NotNull String getSynonymInsertQuery(String schemaName) {
        String synonymInsertQuery = "INSERT INTO " + schemaName + ".sor_tsynonym (synonym, truth_entity_id, created_on, created_user_id, last_updated_on, last_updated_user_id, status, feature, priority_idx, category, tenant_id, \"version\")" +
                "VALUES (?, ?, now(), ?, now(), ?, ?, ?, ?, ?, ?, ?)" +
                "ON CONFLICT (synonym, truth_entity_id, tenant_id) DO NOTHING " +
                "RETURNING *";
        log.info("found synonym insert query: {}", synonymInsertQuery);
        return synonymInsertQuery;
    }

    private void insertQuestion(Jdbi jdbi, Long synonymId, Question question, Long tenantId, Long userId, Long modelRegistryId, String questionInsertQuery, String schemaName) {

        Integer questionCount = jdbi.withHandle(handle ->
        {
            String assetIdQuery = "select count(1) from " + schemaName +".sor_question where synonym_id = " + synonymId + "' and tenant_id = " + tenantId  + ";";
            return handle.createQuery(assetIdQuery)
                    .mapTo(Integer.class)
                    .one();
        });
        if (questionCount == 0){
            try (Handle handle = jdbi.open()) {
                String questionName = question.getPrompt();
                List<Map<String, Object>> insertedRows = handle.createUpdate(questionInsertQuery)
                        .bind(0, synonymId)
                        .bind(1, questionName)
                        .bind(2, QUESTION_WEIGHT)
                        .bind(3, CATEGORY)
                        .bind(4, userId)
                        .bind(5, userId)
                        .bind(6, STATUS)
                        .bind(7, PRIORITY_INDEX)
                        .bind(8, tenantId)
                        .bind(9, VERSION)
                        .bind(10, modelRegistryId)
                        .executeAndReturnGeneratedKeys()
                        .mapToMap()
                        .list();

                Optional<Map<String, Object>> optionalFoundRow = findRowByColumnValue(insertedRows, "question", questionName);
                if (optionalFoundRow.isPresent()) {
                    Map<String, Object> foundRow = optionalFoundRow.get();
                    Object desiredColumnValue = foundRow.get(QUESTION_ID_COLUMN);
                    question.setQuestionId((Long) desiredColumnValue);
                }
            }
        }
    }

    private @NotNull String getQuestionInsertQuery(String schemaName) {
        String questionInsertQuery = "INSERT INTO " + schemaName + ".sor_question (synonym_id, question, weights, category, created_on, created_user_id, last_updated_on, last_updated_user_id, status, priority_idx, tenant_id, \"version\", model_registry_id)" +
                "VALUES (?,?,?,?,now(),?,now(),?,?,?,?,?,?)" +
                "ON CONFLICT (question, synonym_id, tenant_id) DO NOTHING " +
                "RETURNING *";
        log.info("found question insert query: {}", questionInsertQuery);
        return questionInsertQuery;
    }

    private static Optional<Map<String, Object>> findRowByColumnValue(List<Map<String, Object>> rows, String columnName, String value) {
        for (Map<String, Object> row : rows) {
            if (value.equals(row.get(columnName))) {
                return Optional.of(row);
            }
        }
        return Optional.empty();
    }

    @Data
    public static class Channel {
        Long channelId;
        String packageName;
        List<SIP> sips = new ArrayList<>();
    }

    @Data
    public static class SIP {
        Long truthEntityId;
        String className;
        List<Synonym> synonyms = new ArrayList<>();
    }

    @Data
    public static class Synonym {
        Long synonymId;
        String methodName;
        Question question;
    }

    @Data
    public static class Question {
        Long questionId;
        String prompt;
    }

}
