package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.FtpConnectionTest;
import in.handyman.raven.lib.model.ftpConnectionCheck.FtpConnectionCheckInputTable;
import in.handyman.raven.lib.model.ftpConnectionCheck.FtpConnectionCheckOutputTable;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Types;
import java.time.LocalDateTime;




/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "FtpConnectionTest"
)
public class FtpConnectionTestAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final FtpConnectionTest ftpConnectionTest;

  private final Marker aMarker;

  public FtpConnectionTestAction(final ActionExecutionAudit action, final Logger log,
                                 final Object ftpConnectionTest) {
    this.ftpConnectionTest = (FtpConnectionTest) ftpConnectionTest;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" FtpConnectionTest:" + this.ftpConnectionTest.getName());
  }

  @Override
  public void execute() throws Exception {
    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ftpConnectionTest.getResourceConn());
    jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));


    FtpConnectionCheckInputTable ftpConnectionCheckInputTable = getInputTableFromQuerySet(action.getContext().get("ftpConnectionCheckQuerySet"), jdbi);
    String userName = ftpConnectionCheckInputTable.getUsername();
    String password = ftpConnectionCheckInputTable.getPassword();
    String remoteHost = ftpConnectionCheckInputTable.getServerAddress();
    String sourceDir = ftpConnectionCheckInputTable.getFolderPath();
    ObjectMapper objectMapper = new ObjectMapper();
    String ftpDownloadRequestJson = objectMapper.writeValueAsString(ftpConnectionCheckInputTable);

    final String tenantId = action.getContext().get("tenant_id");
    final Long rootPipelineId = action.getPipelineId();
    final String remotePort = action.getContext().get("ftpPort");


    boolean isFtpConnected = checkFtpConnection(userName, password, remotePort, remoteHost);// Check the FTP connection using credentials (username and password)
    boolean isDirectoryAccessOk = checkDirectoryAccess(userName, password, remotePort, remoteHost,new FTPClient(),sourceDir);
    String ftpConnectionMessage = isFtpConnected ? "FTP connection successful" : "FTP connection failed";
    String directoryAccessMessage = isDirectoryAccessOk ? "Directory access successful" : "Directory access failed";
    String completed = "COMPLETED";

    FtpConnectionCheckOutputTable data = new FtpConnectionCheckOutputTable();
    data.setTenantId(Long.valueOf(tenantId));
    data.setRootPipelineId(rootPipelineId); // Matches 'root_pipeline_id' in the database
    data.setCreatedOn(LocalDateTime.now());
    data.setLastUpdatedUserId(Long.valueOf(tenantId)); // Set as needed
    data.setCreatedUserId(Long.valueOf(tenantId)); // Set as needed
    data.setLastUpdatedOn(LocalDateTime.now());
    data.setStatus(isFtpConnected && isDirectoryAccessOk ? "ACTIVE" : "IN_ACTIVE"); // Matches 'status' in the database
    data.setMessage((isFtpConnected && isDirectoryAccessOk) ? "FTP connected and credential stored" :
            "FTP connection or directory access failed. " + ftpConnectionMessage + ". " + directoryAccessMessage); // Matches 'message' in the database
    data.setType("FTP"); // Matches 'type' in the database
    data.setInfo(ftpDownloadRequestJson);
    data.setVersion(1);// Matches 'info' in the database
    data.setLastProcessedOn(LocalDateTime.now()); // Matches 'lastprocessedon' in the database
    data.setFtpConnected(isFtpConnected && isDirectoryAccessOk); // Matches 'isftpconnected' in the database
    data.setExecutionStatus(completed);
    insertIntoOutputTable(jdbi, data);
  }

  private FtpConnectionCheckInputTable getInputTableFromQuerySet(String querySet, Jdbi jdbi) {
    try (Handle handle = jdbi.open()) {
      return handle.createQuery(querySet)
              .mapToBean(FtpConnectionCheckInputTable.class)
              .one();
    }
  }


  private void insertIntoOutputTable(Jdbi jdbi, FtpConnectionCheckOutputTable ftpConnectionCheckOutputTable) {
    jdbi.useTransaction(handle -> {
      handle.createUpdate("INSERT INTO onboard_wizard_info.ftp_connection_check\n" +
                      "                (tenant_id, root_pipeline_id, created_on, created_user_id, last_updated_on, last_updated_user_id, status, message, type, info, version, last_processed_on, ftp_connected, execution_status) " +
                      "VALUES (:tenantId, :rootPipelineId, :createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :status, :message, :type, :info, :version, :lastProcessedOn, :ftpConnected, :executionStatus);")
              .bindBean(ftpConnectionCheckOutputTable).execute();
      log.debug(aMarker, "inserted {} into ftp connection check info details", ftpConnectionCheckOutputTable);
    });
  }

  private boolean checkDirectoryAccess(String userName, String password, String remotePort, String remoteHost,FTPClient ftpClient, String destDir) throws IOException {
    try {
      ftpClient.connect(remoteHost, Integer.parseInt(remotePort));
      ftpClient.login(userName, password);
      // Retrieve information about the remote path
      FTPFile[] files = ftpClient.listFiles(destDir);
      log.error("FTP File Access: FTP server reply code is positive.");

      // If the files array is not empty and the first element is not null, it means the path exists
      return files.length > 0 && files[0] != null;

    } catch (IOException e) {
      log.error("cannot access the directory or file from FTP server: " + e.getMessage(), e);
      return false;
    }
  }

  private boolean checkFtpConnection(String userName, String password, String remotePort, String remoteHost) {
    FTPClient ftpClient = new FTPClient();

    try {
      // Connect to the FTP server
      ftpClient.connect(remoteHost, Integer.parseInt(remotePort));
      int reply = ftpClient.getReplyCode();

      if (!FTPReply.isPositiveCompletion(reply)) {
        // Connection failed
        log.error("FTP connection failed: FTP server reply code is not positive.");
        return false;
      }

      // Login with the provided username and password
      if (ftpClient.login(userName, password)) {
        log.error("FTP connected: FTP server reply code is positive.");
        return true;

      }

      // Login failed
      log.error("FTP login failed: Invalid username or password.");
      return false;
    } catch (Exception e) {
      // Handle any exceptions (e.g., connection timeout)
      log.error("Error during FTP connection: " + e.getMessage(), e);
      return false;
    } finally {
      try {
        ftpClient.disconnect();
      } catch (Exception e) {
        log.error("Error disconnecting from FTP server: " + e.getMessage(), e);
      }
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return ftpConnectionTest.getCondition();
  }
}
