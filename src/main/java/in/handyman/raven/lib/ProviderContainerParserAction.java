package in.handyman.raven.lib;

import bsh.Interpreter;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.elv.bsh.ProviderProcessorSpring;
import in.handyman.raven.lib.elv.dao.*;
import in.handyman.raven.lib.model.ProviderContainerParser;
import in.handyman.raven.lib.model.common.CreateTimeStamp;
import in.handyman.raven.lib.model.kvp.llm.jsonparser.LlmJsonQueryOutputTable;
import in.handyman.raven.util.CommonQueryUtil;
import javassist.NotFoundException;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ProviderContainerParser"
)
public class ProviderContainerParserAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final ProviderContainerParser providerContainerParser;

    private final Marker aMarker;

    public ProviderContainerParserAction(final ActionExecutionAudit action, final Logger log,
                                         final Object providerContainerParser) {
        this.providerContainerParser = (ProviderContainerParser) providerContainerParser;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" ProviderContainerParser:" + this.providerContainerParser.getName());
    }

    @Override
    public void execute() throws Exception {

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(providerContainerParser.getResourceConn());

        ObjectMapper objectMapper = new ObjectMapper();

        List<ContainerItemsDetails> containerItemLists = getDaoFromQuery(jdbi, ContainerItemsDetails.class, providerContainerParser.getContainerItemDetails());
        List<ContainerEntityDetails> containerEntityDetails = getDaoFromQuery(jdbi, ContainerEntityDetails.class, providerContainerParser.getMetaContainerEntityDetails());
        ProviderProcessorSpring providerProcessor = new ProviderProcessorSpring();
        List<SorItemNameMappingDetails> sorItemNameMappingDetails = getDaoFromQuery(jdbi, SorItemNameMappingDetails.class, providerContainerParser.getNameMappingDetails());
//    List<PaperFilterEntityDetails> paperFilterEntityDetails = getDaoFromQuery(jdbi, PaperFilterEntityDetails.class, providerContainerParser.getPaperFilterDetails());
        String PROVIDER_BSH_CLASS_NAME = "ProviderContainerParser";
        SpwBashConfig spwBashConfig = getBashDaoFromQuery(jdbi, PROVIDER_BSH_CLASS_NAME, "select * from config.spw_bsh_config where class_name= '" + PROVIDER_BSH_CLASS_NAME + "'");


        Map<String, List<String>> containerGroupedItemLists = groupBySorContainerItemName(containerItemLists);
        Map<String, List<String>> containerGroupedEntityDetails = groupBySorContainerEntityName(containerEntityDetails);
        Map<String, String> sorItemNameGroupedMappingDetails = extractSorItemMappings(sorItemNameMappingDetails);

//    List<String> paperFilterGroupedEntityDetails =extractSorContainerNames(paperFilterEntityDetails);


        List<ProviderMappingDetails> providerMappingDetails = getDaoFromQuery(jdbi, ProviderMappingDetails.class, providerContainerParser.getQuerySet());
        providerMappingDetails.forEach(providerMappingDetail -> {
            Map<String, String> updatedPredictionKeyMap = new HashMap<>();
            String response = providerMappingDetail.getResponse();
            Interpreter interpreter = new Interpreter();

            providerMappingDetail.getResponseMap().forEach((key, value) -> {
                try {
                    List<Map<String, String>> providerList;

                    // Check if value is already a List of Maps
                    if (value instanceof List) {
                        providerList = (List<Map<String, String>>) value;
                    } else {
                        // Convert the value to JSON and then parse it correctly
                        String json = objectMapper.writeValueAsString(value);
                        providerList = objectMapper.readValue(json, new TypeReference<List<Map<String, String>>>() {
                        });
                    }

                    List<ProviderProcessorSpring.OutputItem> outputItems = providerProcessor.processProviders(
                            providerList,
                            containerGroupedEntityDetails,
                            containerGroupedItemLists,
                            sorItemNameGroupedMappingDetails
                    );

                    String output = objectMapper.writeValueAsString(outputItems);
                    System.out.println(output);
                    outputItems.forEach(outputItem -> {
                        LlmJsonQueryOutputTable insertData = LlmJsonQueryOutputTable.builder()
                                .createdOn(String.valueOf(providerMappingDetail.getCreatedOn()))
                                .tenantId(providerMappingDetail.getTenantId())
                                .lastUpdatedOn(CreateTimeStamp.currentTimestamp())
                                .lastUpdatedUserId(providerMappingDetail.getTenantId())
                                .confidenceScore(outputItem.getConfidence())
                                .sorItemName(outputItem.getKey())
                                .answer(outputItem.getValue())
                                .boundingBox(outputItem.getBoundingBox().toString())
                                .paperNo(providerMappingDetail.getPaperNo())
                                .originId(providerMappingDetail.getOriginId())
                                .groupId(providerMappingDetail.getGroupId())
                                .rootPipelineId(providerMappingDetail.getRootPipelineId())
                                .batchId(providerMappingDetail.getBatchId())
                                .modelRegistry(providerMappingDetail.getModelRegistry())
                                .extractedImageUnit(providerMappingDetail.getExtractedImageUnit())
                                .imageDpi(providerMappingDetail.getImageDpi())
                                .imageHeight(providerMappingDetail.getImageHeight())
                                .imageWidth(providerMappingDetail.getImageWidth())
                                .sorContainerId(providerMappingDetail.getSorContainerId())
                                .build();
                        jdbi.useTransaction(handle -> {
                            getInsertIntoKryptonResultTable(handle, buildInsertQueryKrypton(), insertData);

                        });
                    });


                } catch (JsonProcessingException e) {
                    throw new RuntimeException("Error parsing provider list from response map", e);
                }
            });

//        try {
//          interpreter.eval(spwBashConfig.getSourceCode());
//          String classInstantiation = spwBashConfig.getClassName() + " mapper = new " + spwBashConfig.getClassName() + "();";
//            interpreter.eval(classInstantiation);
//            interpreter.set("response", response);
//            interpreter.set("containerItemLists", containerGroupedItemLists);
//            interpreter.set("containerEntityDetails", containerGroupedEntityDetails);
////            interpreter.set("paperFilterEntityDetails", paperFilterGroupedEntityDetails);
//            interpreter.set("sorItemNameMappingDetails", sorItemNameGroupedMappingDetails);
//            interpreter.eval("predictionMap = mapper.doCustomPredictionMapping(response,containerItemLists,containerEntityDetails,sorItemNameMappingDetails);");
//            Object predictionMapObject = interpreter.get("predictionMap");
//          if (predictionMapObject instanceof Map) {
//            updatedPredictionKeyMap = (Map<String, String>) predictionMapObject;
//            log.info("Updated the prediction map with {} entries for class {}", updatedPredictionKeyMap, spwBashConfig.getClassName());
//          }
//        } catch (EvalError e) {
//            throw new HandymanException("Exception in bsh interpreter class instantiation "+spwBashConfig.getClassName(),e,action);
//        }


        });

    }

    //  public static List<String> extractSorItemMappings(List<SorItemNameMappingDetails> detailsList) {
//    return detailsList.stream()
//            .flatMap(details -> details.getSorItemMappings().values().stream()) // Extract values from Map
//            .collect(Collectors.toList());
//  }
    public static Map<String, String> extractSorItemMappings(List<SorItemNameMappingDetails> detailsList) {
        return detailsList.stream()
                .map(SorItemNameMappingDetails::getSorItemMappings) // Extract each Map
                .flatMap(map -> map.entrySet().stream()) // Flatten to key-value pairs
                .collect(Collectors.toMap(
                        Map.Entry::getKey, // Use key from the Map
                        Map.Entry::getValue, // Use value from the Map
                        (existing, newValue) -> newValue // Merge strategy (keep latest value)
                ));
    }

    public static List<String> extractSorContainerNames(List<PaperFilterEntityDetails> detailsList) {
        return detailsList.stream()
                .map(PaperFilterEntityDetails::getSorContainerName) // Extract sorContainerName
                .collect(Collectors.toList()); // Collect into List<String>
    }

    public static Map<String, List<String>> groupBySorContainerItemName(List<ContainerItemsDetails> detailsList) {
        return detailsList.stream()
                .collect(Collectors.toMap(
                        ContainerItemsDetails::getSorContainerName,  // Key: sorContainerName
                        ContainerItemsDetails::getSorItemNames,      // Value: List of sorItemNames
                        (existing, newValue) -> {
                            existing.addAll(newValue);  // Merge duplicate keys
                            return existing;
                        }
                ));
    }

    public static Map<String, List<String>> groupBySorContainerEntityName(List<ContainerEntityDetails> detailsList) {
        return detailsList.stream()
                .collect(Collectors.toMap(
                        ContainerEntityDetails::getSorContainerName,  // Key: sorContainerName
                        ContainerEntityDetails::getTruthEntityNames,  // Value: List of truthEntityNames
                        (existing, newValue) -> {
                            existing.addAll(newValue);  // Merge duplicate keys
                            return existing;
                        }
                ));
    }

    @NotNull
    private String buildInsertQueryKrypton() {
//        String tableName = "sor_transaction".concat(".").concat("llm_json_parser_output_").concat("audit");

        String tableName=action.getContext().get("temp_schema_name").concat(".").concat("llm_json_parser_output_").concat(String.valueOf(action.getRootPipelineId()));
        return "INSERT INTO " + tableName +
                " (created_on,created_user_id, last_updated_on, last_updated_user_id, confidence, sor_item_name, answer, bbox, paper_no,  \n" +
                "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry, \n" +
                "extracted_image_unit, image_dpi, image_height, image_width,sor_container_id) \n" +
                "  VALUES(?::timestamp,?,?,?,?,?,?,?::jsonb,?,?,?,?,?,? ,?,?,?,?,?,?);";
    }


    private static int getInsertIntoKryptonResultTable(Handle handle, String insertQueryKrypton, LlmJsonQueryOutputTable llmJsonQueryOutputTable) {

        return handle.createUpdate(insertQueryKrypton)
                .bind(0, llmJsonQueryOutputTable.getCreatedOn())
                .bind(1, llmJsonQueryOutputTable.getTenantId())
                .bind(2, CreateTimeStamp.currentTimestamp())
                .bind(3, llmJsonQueryOutputTable.getTenantId())
                .bind(4, llmJsonQueryOutputTable.getConfidenceScore())
                .bind(5, llmJsonQueryOutputTable.getSorItemName())
                .bind(6, llmJsonQueryOutputTable.getAnswer())
                .bind(7, llmJsonQueryOutputTable.getBoundingBox())
                .bind(8, llmJsonQueryOutputTable.getPaperNo())
                .bind(9, llmJsonQueryOutputTable.getOriginId())
                .bind(10, llmJsonQueryOutputTable.getGroupId())
                .bind(11, llmJsonQueryOutputTable.getTenantId())
                .bind(12, llmJsonQueryOutputTable.getRootPipelineId())
                .bind(13, llmJsonQueryOutputTable.getBatchId())
                .bind(14, llmJsonQueryOutputTable.getModelRegistry())
                .bind(15, llmJsonQueryOutputTable.getExtractedImageUnit())
                .bind(16, llmJsonQueryOutputTable.getImageDpi())
                .bind(17, llmJsonQueryOutputTable.getImageHeight())
                .bind(18, llmJsonQueryOutputTable.getImageWidth())
                .bind(19, llmJsonQueryOutputTable.getSorContainerId())
                .execute();
    }


    private SpwBashConfig getBashDaoFromQuery(Jdbi jdbi, String className, String querySet) throws NotFoundException {
        List<SpwBashConfig> detailsList = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing bsh query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<SpwBashConfig> resultIterable = query.mapToBean(SpwBashConfig.class);
                List<SpwBashConfig> detailList = resultIterable.stream().collect(Collectors.toList());
                detailsList.addAll(detailList);
                log.info(aMarker, "executed bsh query from index {}", i.get());
            });
        });
        log.info(aMarker, "Executed bsh query output entity size : {}", detailsList.size());
        return detailsList.stream()
                .filter(spwBashConfig -> spwBashConfig.getClassName().equals(className))
                .findFirst()
                .orElseThrow(() -> new HandymanException("Java BSH script not found for the class name: " + className, new RuntimeException(), action));
    }

    private <T> List<T> getDaoFromQuery(Jdbi jdbi, Class<T> type, String querySet) {
        List<T> detailsList = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<T> resultIterable = query.mapToBean(type);
                List<T> detailList = resultIterable.stream().collect(Collectors.toList());
                detailsList.addAll(detailList);
                log.info(aMarker, "executed query from index {}", i.get());
            });
        });
        log.info(aMarker, "Executed query output entity size : {}", detailsList.size());
        return detailsList;
    }


    @Override
    public boolean executeIf() throws Exception {
        return providerContainerParser.getCondition();
    }
}
