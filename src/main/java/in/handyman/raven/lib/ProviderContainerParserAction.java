package in.handyman.raven.lib;

import bsh.EvalError;
import bsh.Interpreter;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.custom.kvp.post.processing.bsh.ProviderProcessorSpring;
import in.handyman.raven.lib.custom.kvp.post.processing.dao.*;
import in.handyman.raven.lib.custom.kvp.post.processing.dto.ProviderJsonQueryOutputTable;
import in.handyman.raven.lib.model.ProviderContainerParser;
import in.handyman.raven.lib.model.common.CreateTimeStamp;
import in.handyman.raven.util.CommonQueryUtil;
import javassist.NotFoundException;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ProviderContainerParser"
)
public class ProviderContainerParserAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final ProviderContainerParser providerContainerParser;

    private final Marker aMarker;

    public ProviderContainerParserAction(final ActionExecutionAudit action, final Logger log,
                                         final Object providerContainerParser) {
        this.providerContainerParser = (ProviderContainerParser) providerContainerParser;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" ProviderContainerParser:" + this.providerContainerParser.getName());
    }

    @Override
    public void execute() throws Exception {

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(providerContainerParser.getResourceConn());

        ObjectMapper objectMapper = new ObjectMapper();

        List<ContainerItemsDetails> containerItemLists = getDaoFromQuery(jdbi, ContainerItemsDetails.class, providerContainerParser.getContainerItemDetails());
        List<ContainerEntityDetails> containerEntityDetails = getDaoFromQuery(jdbi, ContainerEntityDetails.class, providerContainerParser.getMetaContainerEntityDetails());
        ProviderProcessorSpring providerProcessor = new ProviderProcessorSpring(log);
        List<SorItemNameMappingDetails> sorItemNameMappingDetails = getDaoFromQuery(jdbi, SorItemNameMappingDetails.class, providerContainerParser.getNameMappingDetails());
//    List<PaperFilterEntityDetails> paperFilterEntityDetails = getDaoFromQuery(jdbi, PaperFilterEntityDetails.class, providerContainerParser.getPaperFilterDetails());
        String PROVIDER_BSH_CLASS_NAME = "ProviderContainerParser";
        SpwBashConfig spwBashConfig = getBashDaoFromQuery(jdbi, PROVIDER_BSH_CLASS_NAME, "select * from config.spw_bsh_config where class_name= '" + PROVIDER_BSH_CLASS_NAME + "'");


        Map<String, List<String>> containerGroupedItemLists = groupBySorContainerItemName(containerItemLists);
        Map<String, List<String>> containerGroupedEntityDetails = groupBySorContainerEntityName(containerEntityDetails);
        Map<String, String> sorItemNameGroupedMappingDetails = extractSorItemMappings(sorItemNameMappingDetails);

//    List<String> paperFilterGroupedEntityDetails =extractSorContainerNames(paperFilterEntityDetails);


        List<ProviderMappingDetails> providerMappingDetails = getDaoFromQuery(jdbi, ProviderMappingDetails.class, providerContainerParser.getQuerySet());
        providerMappingDetails.forEach(providerMappingDetail -> {
            Map<String, String> updatedPredictionKeyMap = new HashMap<>();
            String response = providerMappingDetail.getResponse();
            Interpreter interpreter = new Interpreter();

            providerMappingDetail.getResponseMap().forEach((key, value) -> {
//                extractProviderDetailsFromLocalCode(providerMappingDetail, value, objectMapper, providerProcessor, containerGroupedEntityDetails, containerGroupedItemLists, sorItemNameGroupedMappingDetails, jdbi);
                try {
                    extractProviderFromBshCode(interpreter, spwBashConfig, value, containerGroupedItemLists, containerGroupedEntityDetails, sorItemNameGroupedMappingDetails,providerMappingDetail,jdbi,objectMapper);
                } catch (EvalError e) {
                    throw new RuntimeException(e);
                }

            });



        });

    }

    private void extractProviderFromBshCode(Interpreter interpreter, SpwBashConfig spwBashConfig,Object response, Map<String, List<String>> containerGroupedItemLists, Map<String, List<String>> containerGroupedEntityDetails, Map<String, String> sorItemNameGroupedMappingDetails,ProviderMappingDetails providerMappingDetail, Jdbi jdbi,ObjectMapper objectMapper) throws EvalError {
        try {
            List<Map<String, String>> providerList;

            // Check if value is already a List of Maps
            if (response instanceof List) {
                providerList = (List<Map<String, String>>) response;
            } else {
                // Convert the value to JSON and then parse it correctly
                String json = objectMapper.writeValueAsString(response);
                providerList = objectMapper.readValue(json, new TypeReference<List<Map<String, String>>>() {
                });
            }
            interpreter.eval(spwBashConfig.getSourceCode());
            interpreter.set("response", providerList);
            interpreter.set("containerItemLists", containerGroupedItemLists);
            interpreter.set("containerEntityDetails", containerGroupedEntityDetails);
            interpreter.set("sorItemNameMappingDetails", sorItemNameGroupedMappingDetails);
            interpreter.eval("predictionMap = processProviders(response,containerEntityDetails,containerItemLists,sorItemNameMappingDetails);");
            Object predictionMapObject = interpreter.get("predictionMap");
          if (predictionMapObject instanceof List) {
            List updatedPredictionKeyMap = (List) predictionMapObject;
              for (int i = 0; i < updatedPredictionKeyMap.size(); i++) {
                  Hashtable item = (Hashtable) updatedPredictionKeyMap.get(i);
                  String key = (String) item.get("key");
                  String value = (String) item.get("value");
                  String container = (String) item.get("sorContainerName");
                  double confidence = ((Double) item.get("confidence")).doubleValue();
                  Map boundingBox = (Map) item.get("boundingBox");
                  ProviderJsonQueryOutputTable insertData = ProviderJsonQueryOutputTable.builder()
                          .createdOn(String.valueOf(providerMappingDetail.getCreatedOn()))
                          .tenantId(providerMappingDetail.getTenantId())
                          .lastUpdatedOn(CreateTimeStamp.currentTimestamp())
                          .lastUpdatedUserId(providerMappingDetail.getTenantId())
                          .confidenceScore(confidence)
                          .sorItemName(key)
                          .answer(value)
                          .boundingBox(boundingBox.toString())
                          .paperNo(providerMappingDetail.getPaperNo())
                          .originId(providerMappingDetail.getOriginId())
                          .groupId(providerMappingDetail.getGroupId())
                          .rootPipelineId(providerMappingDetail.getRootPipelineId())
                          .batchId(providerMappingDetail.getBatchId())
                          .modelRegistry(providerMappingDetail.getModelRegistry())
                          .extractedImageUnit(providerMappingDetail.getExtractedImageUnit())
                          .imageDpi(providerMappingDetail.getImageDpi())
                          .imageHeight(providerMappingDetail.getImageHeight())
                          .imageWidth(providerMappingDetail.getImageWidth())
                          .sorContainerName(container)
                          .build();
                  jdbi.useTransaction(handle -> {
                      getInsertIntoKryptonResultTable(handle, buildInsertQueryKrypton(), insertData);

                  });
              }

            log.info("Updated the prediction map having entries {} entries for class {}", updatedPredictionKeyMap.size(), spwBashConfig.getClassName());
          }
        } catch (EvalError e) {
            throw new HandymanException("Exception in bsh interpreter class instantiation "+ spwBashConfig.getClassName(),e,action);
        } catch (JsonMappingException e) {
            throw new RuntimeException(e);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void extractProviderDetailsFromLocalCode(ProviderMappingDetails providerMappingDetail, Object value, ObjectMapper objectMapper, ProviderProcessorSpring providerProcessor, Map<String, List<String>> containerGroupedEntityDetails, Map<String, List<String>> containerGroupedItemLists, Map<String, String> sorItemNameGroupedMappingDetails, Jdbi jdbi) {
        try {
            List<Map<String, String>> providerList;

            // Check if value is already a List of Maps
            if (value instanceof List) {
                providerList = (List<Map<String, String>>) value;
            } else {
                // Convert the value to JSON and then parse it correctly
                String json = objectMapper.writeValueAsString(value);
                providerList = objectMapper.readValue(json, new TypeReference<List<Map<String, String>>>() {
                });
            }

            List<ProviderProcessorSpring.OutputItem> outputItems = providerProcessor.processProviders(
                    providerList,
                    containerGroupedEntityDetails,
                    containerGroupedItemLists,
                    sorItemNameGroupedMappingDetails
            );

            String output = objectMapper.writeValueAsString(outputItems);

            log.info(aMarker, "Provider bsh script execution output entity size {}", outputItems.size());

            outputItems.forEach(outputItem -> {
                ProviderJsonQueryOutputTable insertData = ProviderJsonQueryOutputTable.builder()
                        .createdOn(String.valueOf(providerMappingDetail.getCreatedOn()))
                        .tenantId(providerMappingDetail.getTenantId())
                        .lastUpdatedOn(CreateTimeStamp.currentTimestamp())
                        .lastUpdatedUserId(providerMappingDetail.getTenantId())
                        .confidenceScore(outputItem.getConfidence())
                        .sorItemName(outputItem.getKey())
                        .answer(outputItem.getValue())
                        .boundingBox(outputItem.getBoundingBox().toString())
                        .paperNo(providerMappingDetail.getPaperNo())
                        .originId(providerMappingDetail.getOriginId())
                        .groupId(providerMappingDetail.getGroupId())
                        .rootPipelineId(providerMappingDetail.getRootPipelineId())
                        .batchId(providerMappingDetail.getBatchId())
                        .modelRegistry(providerMappingDetail.getModelRegistry())
                        .extractedImageUnit(providerMappingDetail.getExtractedImageUnit())
                        .imageDpi(providerMappingDetail.getImageDpi())
                        .imageHeight(providerMappingDetail.getImageHeight())
                        .imageWidth(providerMappingDetail.getImageWidth())
                        .sorContainerName(outputItem.getSorContainerName())
                        .build();
                jdbi.useTransaction(handle -> {
                    getInsertIntoKryptonResultTable(handle, buildInsertQueryKrypton(), insertData);

                });
            });


        } catch (JsonProcessingException e) {
            throw new RuntimeException("Error parsing provider list from response map", e);
        }
    }

    //  public static List<String> extractSorItemMappings(List<SorItemNameMappingDetails> detailsList) {
//    return detailsList.stream()
//            .flatMap(details -> details.getSorItemMappings().values().stream()) // Extract values from Map
//            .collect(Collectors.toList());
//  }
    public static Map<String, String> extractSorItemMappings(List<SorItemNameMappingDetails> detailsList) {
        return detailsList.stream()
                .map(SorItemNameMappingDetails::getSorItemMappings) // Extract each Map
                .flatMap(map -> map.entrySet().stream()) // Flatten to key-value pairs
                .collect(Collectors.toMap(
                        Map.Entry::getKey, // Use key from the Map
                        Map.Entry::getValue, // Use value from the Map
                        (existing, newValue) -> newValue // Merge strategy (keep latest value)
                ));
    }

    public static List<String> extractSorContainerNames(List<PaperFilterEntityDetails> detailsList) {
        return detailsList.stream()
                .map(PaperFilterEntityDetails::getSorContainerName) // Extract sorContainerName
                .collect(Collectors.toList()); // Collect into List<String>
    }

    public static Map<String, List<String>> groupBySorContainerItemName(List<ContainerItemsDetails> detailsList) {
        return detailsList.stream()
                .collect(Collectors.toMap(
                        ContainerItemsDetails::getSorContainerName,  // Key: sorContainerName
                        ContainerItemsDetails::getSorItemNames,      // Value: List of sorItemNames
                        (existing, newValue) -> {
                            existing.addAll(newValue);  // Merge duplicate keys
                            return existing;
                        }
                ));
    }

    public static Map<String, List<String>> groupBySorContainerEntityName(List<ContainerEntityDetails> detailsList) {
        return detailsList.stream()
                .collect(Collectors.toMap(
                        ContainerEntityDetails::getSorContainerName,  // Key: sorContainerName
                        ContainerEntityDetails::getTruthEntityNames,  // Value: List of truthEntityNames
                        (existing, newValue) -> {
                            existing.addAll(newValue);  // Merge duplicate keys
                            return existing;
                        }
                ));
    }

    @NotNull
    private String buildInsertQueryKrypton() {
//        String tableName = "sor_transaction".concat(".").concat("llm_json_parser_output_").concat("audit");

        String tableName = action.getContext().get("gen_output_table.name");
        log.info(aMarker, "Output table name for Provider bsh executor {}", tableName);
        return "INSERT INTO " + tableName +
                " (created_on,created_user_id, last_updated_on, last_updated_user_id, confidence, sor_item_name, answer, bbox, paper_no,  \n" +
                "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry, \n" +
                "extracted_image_unit, image_dpi, image_height, image_width,sor_container_name) \n" +
                "  VALUES(?::timestamp,?,?,?,?,?,?,?::jsonb,?,?,?,?,?,? ,?,?,?,?,?,?);";
    }


    private static int getInsertIntoKryptonResultTable(Handle handle, String insertQueryKrypton, ProviderJsonQueryOutputTable providerJsonQueryOutputTable) {

        return handle.createUpdate(insertQueryKrypton)
                .bind(0, providerJsonQueryOutputTable.getCreatedOn())
                .bind(1, providerJsonQueryOutputTable.getTenantId())
                .bind(2, CreateTimeStamp.currentTimestamp())
                .bind(3, providerJsonQueryOutputTable.getTenantId())
                .bind(4, providerJsonQueryOutputTable.getConfidenceScore())
                .bind(5, providerJsonQueryOutputTable.getSorItemName())
                .bind(6, providerJsonQueryOutputTable.getAnswer())
                .bind(7, providerJsonQueryOutputTable.getBoundingBox())
                .bind(8, providerJsonQueryOutputTable.getPaperNo())
                .bind(9, providerJsonQueryOutputTable.getOriginId())
                .bind(10, providerJsonQueryOutputTable.getGroupId())
                .bind(11, providerJsonQueryOutputTable.getTenantId())
                .bind(12, providerJsonQueryOutputTable.getRootPipelineId())
                .bind(13, providerJsonQueryOutputTable.getBatchId())
                .bind(14, providerJsonQueryOutputTable.getModelRegistry())
                .bind(15, providerJsonQueryOutputTable.getExtractedImageUnit())
                .bind(16, providerJsonQueryOutputTable.getImageDpi())
                .bind(17, providerJsonQueryOutputTable.getImageHeight())
                .bind(18, providerJsonQueryOutputTable.getImageWidth())
                .bind(19, providerJsonQueryOutputTable.getSorContainerName())
                .execute();
    }


    private SpwBashConfig getBashDaoFromQuery(Jdbi jdbi, String className, String querySet) throws NotFoundException {
        List<SpwBashConfig> detailsList = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing bsh query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<SpwBashConfig> resultIterable = query.mapToBean(SpwBashConfig.class);
                List<SpwBashConfig> detailList = resultIterable.stream().collect(Collectors.toList());
                detailsList.addAll(detailList);
                log.info(aMarker, "executed bsh query from index {}", i.get());
            });
        });
        log.info(aMarker, "Executed bsh query output entity size : {}", detailsList.size());
        return detailsList.stream()
                .filter(spwBashConfig -> spwBashConfig.getClassName().equals(className))
                .findFirst()
                .orElseThrow(() -> new HandymanException("Java BSH script not found for the class name: " + className, new RuntimeException(), action));
    }

    private <T> List<T> getDaoFromQuery(Jdbi jdbi, Class<T> type, String querySet) {
        List<T> detailsList = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(querySet);
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<T> resultIterable = query.mapToBean(type);
                List<T> detailList = resultIterable.stream().collect(Collectors.toList());
                detailsList.addAll(detailList);
                log.info(aMarker, "executed query from index {}", i.get());
            });
        });
        log.info(aMarker, "Executed query output entity size : {}", detailsList.size());
        return detailsList;
    }


    @Override
    public boolean executeIf() throws Exception {
        return providerContainerParser.getCondition();
    }
}
