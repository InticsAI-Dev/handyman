package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.EncryptionHandlers;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.adapters.selections.ExtractedField;
import in.handyman.raven.lib.adapters.selections.FieldSelectionAdapter;
import in.handyman.raven.lib.adapters.selections.FieldSelectionAdapterFactory;
import in.handyman.raven.lib.adapters.selections.models.SelectionFilteringInputTable;
import in.handyman.raven.lib.model.SectionFiltering;
import in.handyman.raven.lib.model.multi.member.indicator.MultiValueMemberMapperOutputTable;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.sql.Timestamp;
import java.sql.Types;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "SectionFiltering"
)
public class SectionFilteringAction implements IActionExecution {
    public static final String AES_256 = "AES256";
    private final ActionExecutionAudit action;

  private final Logger log;

  private final SectionFiltering sectionFiltering;

  private final Marker aMarker;

    public static final String INSERT_INTO = "INSERT INTO ";
    public static final String INSERT_COLUMNS_UPDATED =
            "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, group_id, " +
                    "root_pipeline_id, batch_id, model_registry, sor_container_id, sor_container_name, " +
                    "sor_item_name, sor_item_label, section_alias, answer, confidence, bbox, " +
                    "bbox_asis, paper_no, origin_id, extracted_image_unit, image_dpi, image_height, " +
                    "image_width, is_label_matching, label_match_message, " +
                    " is_encrypted, encryption_policy";

    public static final String INSERT_INTO_VALUES_UPDATED =
            "VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?," +
                    "?, ?, ?, ?, ?, ?, ?, ?, ?, ?," +
                    " ?, ?, ?, ?, ?, ?, ?::boolean, ?)";

    public SectionFilteringAction(final ActionExecutionAudit action, final Logger log,
      final Object sectionFiltering) {
    this.sectionFiltering = (SectionFiltering) sectionFiltering;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" SectionFiltering:"+this.sectionFiltering.getName());
  }

  @Override
  public void execute() throws Exception {
      log.info(aMarker, "Section Filtering Action started");

      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(sectionFiltering.getResourceConn());
      final InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);
      jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));

      // 1 Fetch data
      List<SelectionFilteringInputTable> tableInfos = getDataFromSelectQuery(jdbi);
      log.info(aMarker, "Total records fetched from input query: {}", tableInfos.size());

      // 2 Decrypt values
      if(action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION).equals("true")){
          decryptAnswers(tableInfos, encryption);
          if(action.getContext().get("llm.json.parser.label.encryption").equals("true")){
              decryptLabels(tableInfos, encryption);
              decryptSectionAlias(tableInfos,encryption);
          }


      }
      log.info(aMarker, "Decryption completed for fetched records {}", tableInfos.size());

      // 3 Map input to adapter fields
      List<ExtractedField> extractedFields = mapToExtractedFields(tableInfos);

      // 4 Pre-filter summary
      log.debug(aMarker, "Pre-filter Extracted Fields count: {}", extractedFields.size());

      // 5 Apply adapter-based filtering
      FieldSelectionAdapter adapter = FieldSelectionAdapterFactory.getAdapter("blacklist");
      FieldSelectionAdapter whiteListedAdapter = FieldSelectionAdapterFactory.getAdapter("whitelist");
      List<ExtractedField> filteredExtractedFields = filterExtractedFields(adapter, extractedFields, whiteListedAdapter);

      // 6 Merge filtered results back into original list
      mergeFilteredResults(tableInfos, filteredExtractedFields);

      log.info(aMarker, "Filtering completed. Filtered count: {} ", filteredExtractedFields.size());

      // 7 Encrypt results before persistence or outbound
      if(action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION).equals("true")){
          encryptAnswers(tableInfos, encryption);
          if(action.getContext().get("llm.json.parser.label.encryption").equals("true")){
              encryptLabels(tableInfos, encryption);
              encryptSectionAlias(tableInfos,encryption);
          }

      }

      // 8 Prepare output rows
      executeBatchInsert(jdbi,tableInfos);

      log.info(aMarker, "Section Filtering Action completed successfully.");
  }

    private void executeBatchInsert(Jdbi jdbi, List<SelectionFilteringInputTable> rows) {

        String insertQuery = INSERT_INTO + sectionFiltering.getOutputTable() +
                " ( " + INSERT_COLUMNS_UPDATED + " ) " + INSERT_INTO_VALUES_UPDATED;

        jdbi.useHandle(handle -> {
            try (PreparedBatch batch = handle.prepareBatch(insertQuery)) {

                rows.forEach(row -> {
                    batch.bind(0, row.getCreatedOn())
                            .bind(1, row.getCreatedUserId())
                            .bind(2, row.getLastUpdatedOn())
                            .bind(3, row.getLastUpdatedUserId())
                            .bind(4, row.getTenantId())
                            .bind(5, row.getGroupId())
                            .bind(6, row.getRootPipelineId())
                            .bind(7, row.getBatchId())
                            .bind(8, row.getModelRegistry())
                            .bind(9, row.getSorContainerId())
                            .bind(10, row.getSorContainerName())
                            .bind(11, row.getSorItemName())
                            .bind(12, row.getSorItemLabel())
                            .bind(13, row.getSectionAlias())
                            .bind(14, row.getAnswer())
                            .bind(15, row.getConfidence())
                            .bind(16, row.getBbox())
                            .bind(17, row.getBboxAsIs())
                            .bind(18, row.getPaperNo())
                            .bind(19, row.getOriginId())
                            .bind(20, row.getExtractedImageUnit())
                            .bind(21, row.getImageDpi())
                            .bind(22, row.getImageHeight())
                            .bind(23,row.getImageWidth())
                            .bind(24, row.isLabelMatching())
                            .bind(25, row.getLabelMatchMessage())
                            .bind(26, row.getIsEncrypted())
                            .bind(27,row.getEncryptionPolicy());


                    batch.add();
                });

                int[] counts = batch.execute();
                log.info(aMarker, "Batch inserted {} records into {}", counts.length, sectionFiltering.getOutputTable());

            } catch (Exception e) {
                log.error(aMarker, "Batch insert failed for {}", sectionFiltering.getOutputTable(), e);
                HandymanException.insertException(
                        "Error in batch insert into " + sectionFiltering.getOutputTable(),
                        new HandymanException(e),
                        action
                );
            }
        });
    }



    /**
     * Converts SelectionFilteringInputTable â†’ ExtractedField
     */
    private List<ExtractedField> mapToExtractedFields(List<SelectionFilteringInputTable> tableInfos) {
        if (tableInfos == null || tableInfos.isEmpty()) {
            return Collections.emptyList();
        }

        return tableInfos.stream()
                .map(row ->
                        ExtractedField.builder()
                        .id(Math.toIntExact(row.getId() != null ? row.getId() : null))
                        .label(row.getSorItemLabel())
                        .sectionAlias(row.getSectionAlias())
                        .value(row.getAnswer())
                        .blacklistedLabels(splitCsvToSet(row.getBlacklistedLabels()))
                        .blacklistedSections(splitCsvToSet(row.getBlacklistedSections()))
                        .whitelistedLabels(splitCsvToSet(row.getWhitelistedLabels()))
                        .build())
                .collect(Collectors.toList());
    }

    private static Set<String> splitCsvToSet(String csv) {
        if (csv == null || csv.isBlank()) {
            return Collections.emptySet();
        }
        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toSet());
    }

    /**
     * Applies the blacklist adapter filtering logic
     */
    private List<ExtractedField> filterExtractedFields(FieldSelectionAdapter adapter, List<ExtractedField> fields, FieldSelectionAdapter whiteListedAdapter) {
        if (adapter == null) {
            log.warn(aMarker, "No adapter found. Skipping filtering step.");
            return fields;
        }

        try {
            List<ExtractedField> filtered = adapter.filter(fields);
            log.info(aMarker, "Adapter filtering completed. Original count: {}, Filtered count: {}",
                    fields.size(), filtered.size());

            return whiteListedAdapter.filter(filtered);
        } catch (Exception e) {
            log.error(aMarker, "Error during field filtering: {}", e.getMessage(), e);
            return fields;
        }
    }

    /**
     * Merges filtered field results back to SelectionFilteringInputTable list
     * based on ID reference.
     */
    public void mergeFilteredResults(List<SelectionFilteringInputTable> tableInfos,
                                      List<ExtractedField> filteredFields) {
        if (tableInfos == null || tableInfos.isEmpty()) return;

        Map<Integer, ExtractedField> filteredMap = filteredFields.stream()
                .filter(f -> f.getId() != null)
                .collect(Collectors.toMap(ExtractedField::getId, f -> f));

        for (SelectionFilteringInputTable table : tableInfos) {
            try {
                Integer id = Math.toIntExact(table.getId());
                ExtractedField matched = filteredMap.get(id);

                if (matched != null) {
                    table.setAnswer(matched.getValue());
                    table.setSectionAlias(matched.getSectionAlias());
                    table.setSorItemLabel(matched.getLabel());
                    table.setLabelMatchMessage(matched.getLabelMatchMessage());
                    table.setLabelMatching(matched.isLabelMatching());
                } else {
                    // Mark as filtered out
                    table.setLabelMatching(false);
                    table.setLabelMatchMessage("Filtered out by blacklist adapter.");
                }
            } catch (Exception e) {
                HandymanException handymanException= new HandymanException(e);
                HandymanException.insertException("Section Filtering getting error for in merging the extracted result with tableInfo ",handymanException,action);
                log.warn(aMarker, "Error merging filtered result for ID {}: {}", table.getId(), e.getMessage());
            }
        }
    }



    private List<SelectionFilteringInputTable> getDataFromSelectQuery(Jdbi jdbi) {
        List<SelectionFilteringInputTable> tableInfos = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(sectionFiltering.getQuerySet());
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<SelectionFilteringInputTable> resultIterable = query.mapToBean(SelectionFilteringInputTable.class);
                List<SelectionFilteringInputTable> detailList = resultIterable.stream().collect(Collectors.toList());
                tableInfos.addAll(detailList);
                log.info(aMarker, "executed query from index {}", i.get());
            });
        });
        log.info("Query set executed and returned entities size: {}", tableInfos.size());
        return tableInfos;
    }

    public void decryptAnswers(List<SelectionFilteringInputTable> inputList, InticsIntegrity encryption) {
        if (inputList == null || inputList.isEmpty()) {
            return;
        }

        // Step 1: Convert to EncryptionRequestClass
        List<EncryptionRequestClass> encryptionRequests = inputList.stream()
                .filter(SelectionFilteringInputTable::getIsEncrypted)
                .filter(obj -> obj.getId() != null && obj.getAnswer() != null && !obj.getAnswer().equals(""))
                .map(obj -> new EncryptionRequestClass(AES_256, obj.getAnswer(), String.valueOf(obj.getId())))
                .collect(Collectors.toList());
        log.info(aMarker, "Total records to decrypt for answers: {}", encryptionRequests.size());
        // Step 2: Call external Protegrity API
        List<EncryptionRequestClass> responseList = encryption.decrypt(encryptionRequests);

        // Step 3: Build a lookup map from response
        Map<Long, String> encryptedMap = responseList.stream()
                .filter(item -> item.getKey() != null && item.getKey().matches("\\d+"))
                .collect(Collectors.toMap(
                        item -> Long.parseLong(item.getKey()),
                        EncryptionRequestClass::getValue
                ));


        // Step 4: Update original list
        for (SelectionFilteringInputTable item : inputList) {
            if (item.getId() != null && encryptedMap.containsKey(item.getId())) {
                String answer = encryptedMap.get(item.getId());
                item.setAnswer(answer);

            }
        }
    }


    public void decryptLabels(List<SelectionFilteringInputTable> inputList, InticsIntegrity encryption) {
        if (inputList == null || inputList.isEmpty()) {
            return;
        }

        // Step 1: Convert to EncryptionRequestClass
        List<EncryptionRequestClass> encryptionRequests = inputList.stream()
                .filter(SelectionFilteringInputTable::getIsEncrypted)
                .filter(obj -> obj.getId() != null && obj.getSorItemLabel() != null && !obj.getSorItemLabel().isEmpty())
                .map(obj -> new EncryptionRequestClass(AES_256, obj.getSorItemLabel(), String.valueOf(obj.getId())))
                .collect(Collectors.toList());
        log.info(aMarker, "Total records to decrypt for labels: {}", encryptionRequests.size());
        // Step 2: Call external Protegrity API
        List<EncryptionRequestClass> responseList = encryption.decrypt(encryptionRequests);

        // Step 3: Build a lookup map from response
        Map<Long, String> encryptedMap = responseList.stream()
                .filter(item -> item.getKey() != null && item.getKey().matches("\\d+"))
                .collect(Collectors.toMap(
                        item -> Long.parseLong(item.getKey()),
                        EncryptionRequestClass::getValue
                ));


        // Step 4: Update original list
        for (SelectionFilteringInputTable item : inputList) {
            if (item.getId() != null && encryptedMap.containsKey(item.getId())) {
                String label = encryptedMap.get(item.getId());
                item.setSorItemLabel(label);

            }
        }
    }


    public void encryptAnswers(List<SelectionFilteringInputTable> inputList, InticsIntegrity encryption) {
        if (inputList == null || inputList.isEmpty()) {
            return;
        }

        // Step 1: Convert to EncryptionRequestClass
        List<EncryptionRequestClass> encryptionRequests = inputList.stream()
                .filter(SelectionFilteringInputTable::getIsEncrypted)
                .filter(obj -> obj.getId() != null && obj.getAnswer() != null)
                .map(obj -> new EncryptionRequestClass(AES_256, obj.getAnswer(),String.valueOf(obj.getId())))
                .collect(Collectors.toList());
        log.info(aMarker, "Total records to encrypt for answers: {}", encryptionRequests.size());
        // Step 2: Call external Protegrity API
        List<EncryptionRequestClass> responseList = encryption.encrypt(encryptionRequests);

        // Step 3: Build a lookup map from response
        Map<Long, String> encryptedMap = responseList.stream()
                .filter(item -> item.getKey() != null && item.getKey().matches("\\d+"))
                .collect(Collectors.toMap(
                        item -> Long.parseLong(item.getKey()),
                        EncryptionRequestClass::getValue
                ));


        // Step 4: Update original list
        for (SelectionFilteringInputTable item : inputList) {
            if (item.getId() != null && encryptedMap.containsKey(item.getId())) {
                item.setAnswer(encryptedMap.get(item.getId()));
            }
        }
    }


    public void encryptLabels(List<SelectionFilteringInputTable> inputList, InticsIntegrity encryption) {
        if (inputList == null || inputList.isEmpty()) {
            return;
        }

        // Step 1: Convert to EncryptionRequestClass
        List<EncryptionRequestClass> encryptionRequests = inputList.stream()
                .filter(SelectionFilteringInputTable::getIsEncrypted)
                .filter(obj -> obj.getId() != null && obj.getSorItemLabel() != null && !obj.getSorItemLabel().isEmpty())
                .map(obj -> new EncryptionRequestClass(AES_256, obj.getSorItemLabel(),String.valueOf(obj.getId())))
                .collect(Collectors.toList());
        log.info(aMarker, "Total records to encrypt for Labels: {}", encryptionRequests.size());
        // Step 2: Call external Protegrity API
        List<EncryptionRequestClass> responseList = encryption.encrypt(encryptionRequests);

        // Step 3: Build a lookup map from response
        Map<Long, String> encryptedMap = responseList.stream()
                .filter(item -> item.getKey() != null && item.getKey().matches("\\d+"))
                .collect(Collectors.toMap(
                        item -> Long.parseLong(item.getKey()),
                        EncryptionRequestClass::getValue
                ));


        // Step 4: Update original list
        for (SelectionFilteringInputTable item : inputList) {
            if (item.getId() != null && encryptedMap.containsKey(item.getId())) {
                item.setSorItemLabel(encryptedMap.get(item.getId()));
            }
        }
    }



    public void encryptSectionAlias(List<SelectionFilteringInputTable> inputList, InticsIntegrity encryption) {
        if (inputList == null || inputList.isEmpty()) {
            return;
        }

        // Step 1: Convert to EncryptionRequestClass
        List<EncryptionRequestClass> encryptionRequests = inputList.stream()
                .filter(SelectionFilteringInputTable::getIsEncrypted)
                .filter(obj -> obj.getId() != null && obj.getSectionAlias() != null && !obj.getSectionAlias().isEmpty())
                .map(obj -> new EncryptionRequestClass(AES_256, obj.getSectionAlias(),String.valueOf(obj.getId())))
                .collect(Collectors.toList());
        log.info(aMarker, "Total records to encrypt for section alias: {}", encryptionRequests.size());
        // Step 2: Call external Protegrity API
        List<EncryptionRequestClass> responseList = encryption.encrypt(encryptionRequests);

        // Step 3: Build a lookup map from response
        Map<Long, String> encryptedMap = responseList.stream()
                .filter(item -> item.getKey() != null && item.getKey().matches("\\d+"))
                .collect(Collectors.toMap(
                        item -> Long.parseLong(item.getKey()),
                        EncryptionRequestClass::getValue
                ));


        // Step 4: Update original list
        for (SelectionFilteringInputTable item : inputList) {
            if (item.getId() != null && encryptedMap.containsKey(item.getId())) {
                item.setSectionAlias(encryptedMap.get(item.getId()));
            }
        }
    }



    public void decryptSectionAlias(List<SelectionFilteringInputTable> inputList, InticsIntegrity encryption) {
        if (inputList == null || inputList.isEmpty()) {
            return;
        }

        // Step 1: Convert to EncryptionRequestClass
        List<EncryptionRequestClass> encryptionRequests = inputList.stream()
                .filter(SelectionFilteringInputTable::getIsEncrypted)
                .filter(obj -> obj.getId() != null && obj.getSectionAlias() != null && !obj.getSectionAlias().equals(""))
                .map(obj -> new EncryptionRequestClass(AES_256, obj.getSectionAlias(), String.valueOf(obj.getId())))
                .collect(Collectors.toList());
        log.info(aMarker, "Total records to decrypt for section alias: {}", encryptionRequests.size());
        // Step 2: Call external Protegrity API
        List<EncryptionRequestClass> responseList = encryption.decrypt(encryptionRequests);

        // Step 3: Build a lookup map from response
        Map<Long, String> encryptedMap = responseList.stream()
                .filter(item -> item.getKey() != null && item.getKey().matches("\\d+"))
                .collect(Collectors.toMap(
                        item -> Long.parseLong(item.getKey()),
                        EncryptionRequestClass::getValue
                ));


        // Step 4: Update original list
        for (SelectionFilteringInputTable item : inputList) {
            if (item.getId() != null && encryptedMap.containsKey(item.getId())) {
                String answer = encryptedMap.get(item.getId());
                item.setSectionAlias(answer);

            }
        }
    }


    @Override
  public boolean executeIf() throws Exception {
    return sectionFiltering.getCondition();
  }
}
