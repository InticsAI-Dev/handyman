package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.AumiOutboundResponse;
import in.handyman.raven.lib.model.OutboundQueryResult;
import in.handyman.raven.lib.model.OutboundResponse;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "OutboundResponse"
)
public class OutboundResponseAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final OutboundResponse outboundResponse;

  private final Marker aMarker;

  private final ObjectMapper objectMapper;
  private final Integer writeBatchSize = 100;
  private static final int FLOAT_VALUE_ROUNDING_PRECISION = 2;
  private static final int CONFIDENCE_SCORE_MULTIPLY_VALUE = 100;
  private static final int AUMI_BBOX_SCALAR_WIDTH = 1000;
  private static final int AUMI_BBOX_SCALAR_HEIGHT = 1000;
  private static final String DEFAULT_VALUE = "";
  private static final double DEFAULT_DOUBLE_VALUE = 0.0;

  public OutboundResponseAction(final ActionExecutionAudit action, final Logger log,
      final Object outboundResponse) {
    this.outboundResponse = (OutboundResponse) outboundResponse;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" OutboundResponse:"+this.outboundResponse.getName());
    this.objectMapper = new ObjectMapper();
    this.objectMapper.registerModule(new JavaTimeModule());
    this.objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
  }

  @Override
  public void execute() throws Exception {
      String tenantIdStr = action.getContext().get("tenant_id");
      Long tenantId;

      if (tenantIdStr == null || tenantIdStr.trim().isEmpty()) {
        log.error(aMarker, "tenant_id is missing or empty in context");
        throw new HandymanException("tenant_id is missing or empty in context");
      }

      try {
        tenantId = Long.valueOf(tenantIdStr);
      } catch (NumberFormatException e) {
        log.error(aMarker, "Invalid tenant_id format: {}", tenantIdStr, e);
        throw new HandymanException("Invalid tenant_id format: " + tenantIdStr, e, action);
      }

      try {
        log.info(aMarker, "Outbound Response Action for {} has been started", outboundResponse.getName());

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(outboundResponse.getResourceConn());
        final List<OutboundQueryResult> queryResults = new ArrayList<>();
        final List<AumiOutboundResponse> responses = new ArrayList<>();

        jdbi.useTransaction(handle -> {
          final List<String> formattedQueries = CommonQueryUtil.getFormattedQuery(outboundResponse.getQuerySet());
          for (String sql : formattedQueries) {
            log.info(aMarker, "Executing query: {}", sql);
            Query query = handle.createQuery(sql);
            ResultIterable<OutboundQueryResult> resultIterable = query.mapToBean(OutboundQueryResult.class);
            List<OutboundQueryResult> results = resultIterable.stream().collect(Collectors.toList());
            queryResults.addAll(results);
            results.forEach(result -> log.info(aMarker, "OutboundQueryResult: {}", result));
            log.info(aMarker, "Query executed, retrieved {} results", results.size());
          }
        });

        log.info(aMarker, "Query set executed and returned entities size: {}", queryResults.size());

        Map<String, List<OutboundQueryResult>> resultsByDocumentId = queryResults.stream()
                .collect(Collectors.groupingBy(
                        result -> result.getDocumentId() != null ? result.getDocumentId() : "UNKNOWN",
                        Collectors.toList()
                ));

        for (Map.Entry<String, List<OutboundQueryResult>> entry : resultsByDocumentId.entrySet()) {
          String documentId = entry.getKey();
          List<OutboundQueryResult> docResults = entry.getValue();
          try {
            AumiOutboundResponse response = processQueryResult(docResults, tenantId);
            responses.add(response);
            String jsonResponse = objectMapper.writeValueAsString(response);
            System.out.println("Processed AumiOutboundResponse: " + jsonResponse);
            response.setCustomResponse(jsonResponse);
            if (responses.size() >= writeBatchSize) {
              consumerBatch(jdbi, responses);
              log.info(aMarker, "Processed batch of size: {}", responses.size());
              responses.clear();
            }
          } catch (Exception e) {
            log.error(aMarker, "Error processing results for documentId: {}", documentId, e);
          }
        }

        if (!responses.isEmpty()) {
          consumerBatch(jdbi, responses);
          log.info(aMarker, "Processed final batch of size: {}", responses.size());
          responses.clear();
        }

      } catch (Exception e) {
        action.getContext().put(outboundResponse.getName().concat(".error"), "true");
        log.error(aMarker, "Exception occurred", e);
        throw new HandymanException("Exception in OutboundResponse execute", e, action);
      } finally {
        log.info(aMarker, "Outbound Response Action for {} has been completed", outboundResponse.getName());
      }
    }

    private AumiOutboundResponse processQueryResult(List<OutboundQueryResult> results, Long tenantId) {
      OutboundQueryResult firstResult = results.get(0);
      boolean isAgenticPaperFilter = getConfigValue("elv.aumi.instance", "false").equals("true");

      List<Integer> candidatePapers = results.stream()
              .filter(result -> "yes".equals(result.getApsaIsCandidatePaper()))
              .map(OutboundQueryResult::getPaperNo)
              .distinct()
              .collect(Collectors.toList());

      if (isAgenticPaperFilter) {
        log.info(aMarker, "Agentic paper filter enabled for tenantId: {}, but logic not implemented", tenantId);
      }

      Map<String, Object> dimensions = new HashMap<>();
      dimensions.put("width", firstResult.getWidth());
      dimensions.put("height", firstResult.getHeight());
      dimensions.put("file_extension", firstResult.getFileExtension() != null ? firstResult.getFileExtension() : "pdf");

      List<AumiRecord> records = results.stream()
              .map(result -> new AumiRecord(
                      result.getItemName() != null ? result.getItemName() : "N/A",
                      result.getPredictedValue() != null ? result.getPredictedValue() : "",
                      result.getPaperNo(),
                      result.getPrecision(),
                      result.getX(),
                      result.getWidth(),
                      result.getY(),
                      result.getHeight(),
                      result.getLineItemType() != null ? result.getLineItemType() : "single_value"
              ))
              .collect(Collectors.toList());

      AumiOutboundResponse.OutboundJsonMetaData metadata = AumiOutboundResponse.OutboundJsonMetaData.builder()
              .documentType(firstResult.getDocumentType() != null ? firstResult.getDocumentType() : "UMFAX")
              .documentExtension(firstResult.getFileExtension() != null ? firstResult.getFileExtension() : "pdf")
              .transactionId(firstResult.getTransactionId() != null ? firstResult.getTransactionId() : "N/A")
              .inboundDocumentName(firstResult.getFileName() != null ? firstResult.getFileName() : "N/A")
              .processStartTime(firstResult.getTransactionCreatedOn())
              .processEndTime(LocalDateTime.now())
              .processingTimeMs(firstResult.getTransactionCreatedOn() != null ?
                      ChronoUnit.SECONDS.between(firstResult.getTransactionCreatedOn(), LocalDateTime.now()) : 0L)
              .processedAt(firstResult.getSourceCreatedOn() != null ? firstResult.getSourceCreatedOn() : firstResult.getTransactionCreatedOn())
              .pageCount(candidatePapers.size())
              .candidatePaper(candidatePapers)
              .overallConfidence(0)
              .build();

      AumiOutboundResponse.AumiPayload payload = buildAumiPayload(records, dimensions, firstResult.getDocumentType() != null ? firstResult.getDocumentType() : "UMFAX");

      return AumiOutboundResponse.builder()
              .requestTxnId(firstResult.getRequestTxnId() != null ? firstResult.getRequestTxnId() : "N/A")
              .status(firstResult.getUploadReqAck() != null ? firstResult.getUploadReqAck() : "SUCCESS")
              .errorMessage("")
              .errorMessageDetail("")
              .documentId(firstResult.getDocumentId() != null ? firstResult.getDocumentId() : "N/A")
              .errorCd(null)
              .metadata(metadata)
              .aumipayload(payload)
              .build();
    }

    public void consumerBatch(Jdbi jdbi, List<AumiOutboundResponse> responses) {
      Long tenantId = Long.valueOf(action.getContext().get("tenant_id"));
      try {
        jdbi.useTransaction(handle -> {
          for (AumiOutboundResponse response : responses) {
            try {
              String jsonResponse = response.getCustomResponse() != null ? response.getCustomResponse() :
                      objectMapper.writeValueAsString(response);
              log.debug(aMarker, "Preparing to insert response for document_id: {}, jsonResponse: {}",
                      response.getDocumentId(), jsonResponse);
              int rowsAffected = handle.createUpdate("INSERT INTO " + outboundResponse.getProductResponseDetails() +
                              "(status, document_id, extension, origin_id, transaction_id, batch_id, custom_response, tenant_id, created_on, created_user_id, last_updated_on, last_updated_user_id, version) " +
                              "VALUES(:status, :documentId, :extension, :originId, :transactionId, :batchId, CAST(:customResponse AS JSON), :tenantId, NOW(), :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :version)")
                      .bind("status", response.getStatus())
                      .bind("documentId", response.getDocumentId())
                      .bind("extension", response.getMetadata() != null ? response.getMetadata().getDocumentExtension() : "pdf")
                      .bind("originId", response.getAumipayload() != null && response.getAumipayload().getAuthId() != null ? response.getAumipayload().getAuthId().getValue() : "N/A")
                      .bind("transactionId", response.getMetadata() != null ? response.getMetadata().getTransactionId() : "N/A")
                      .bind("batchId", "BATCH-" + System.currentTimeMillis())
                      .bind("customResponse", jsonResponse)
                      .bind("tenantId", tenantId)
                      .bind("createdUserId", (Long) null)
                      .bind("lastUpdatedOn", (java.sql.Timestamp) null)
                      .bind("lastUpdatedUserId", (Long) null)
                      .bind("version", 1)
                      .execute();
              log.info(aMarker, "Inserted {} row(s) for document_id: {}", rowsAffected, response.getDocumentId());
            } catch (Exception e) {
              log.error(aMarker, "Error inserting response for document_id: {}", response.getDocumentId(), e);
              throw new RuntimeException("Failed to insert response for document_id: " + response.getDocumentId(), e);
            }
          }
        });
      } catch (Exception e) {
        log.error(aMarker, "Error in batch insert", e);
        throw new HandymanException("Error in batch insert", e, action);
      }
    }

    private AumiOutboundResponse.AumiPayload buildAumiPayload(List<AumiRecord> records, Map<String, Object> dimensions, String documentType) {
      AumiOutboundResponse.AumiPayload.AumiPayloadBuilder builder = AumiOutboundResponse.AumiPayload.builder();
      Map<String, AumiOutboundResponse.ExtractedField> fieldMap = buildFieldMap(records);

      boolean customAumiOutboundCleaner = getConfigValue("custom_outbound_cleaner", "true").equals("true");
      boolean mmsIdProviderMode = getConfigValue("mmsIdProviderMode", "false").equals("true");

      AumiOutboundResponse.ExtractedField firstAuthId = fieldMap.entrySet().stream()
              .filter(entry -> entry.getKey().startsWith("auth_id"))
              .sorted(Map.Entry.comparingByKey())
              .map(Map.Entry::getValue)
              .findFirst()
              .orElse(null);

      boolean isAuthIdPresent = firstAuthId != null && firstAuthId.getValue() != null && !firstAuthId.getValue().isEmpty();

      // Always use conditional inclusion to avoid null or empty fields
      if (isAuthIdPresent) {
        builder.authId(firstAuthId);
      }
      putIfPresent(builder::hcid, fieldMap, "member_id");
      putIfPresent(builder::medicaidId, fieldMap, "medicaid_id");
      putIfPresent(builder::memberLastName, fieldMap, "member_last_name");
      putIfPresent(builder::memberFirstName, fieldMap, "member_first_name");
      putIfPresent(builder::memberDOB, fieldMap, "member_date_of_birth");
      putIfPresent(builder::groupId, fieldMap, "member_group_id");
      putIfPresent(builder::memberGender, fieldMap, "member_gender");
      putIfPresent(builder::memberAddressLine1, fieldMap, "member_address_line1");
      putIfPresent(builder::memberCity, fieldMap, "member_city");
      putIfPresent(builder::memberZipCode, fieldMap, "member_zipcode");
      putIfPresent(builder::memberState, fieldMap, "member_state");
      putIfPresent(builder::levelOfService, fieldMap, "level_of_service");
      putIfPresent(builder::serviceFromDate, fieldMap, "service_from_date");
      putIfPresent(builder::serviceToDate, fieldMap, "service_to_date");
      putIfPresent(builder::authAdmitDate, fieldMap, "auth_admit_date");
      putIfPresent(builder::authDischargeDate, fieldMap, "auth_discharge_date");
      putIfPresent(builder::authDischargeDisposition, fieldMap, "auth_discharge_disposition");

      List<AumiOutboundResponse.Provider> providers = getProviderDetails(records, documentType);
      List<AumiOutboundResponse.ServiceModifier> serviceModifiers = getServiceModifier(records, customAumiOutboundCleaner);
      List<AumiOutboundResponse.Diagnosis> diagnoses = getDiagnosis(records, customAumiOutboundCleaner);
      List<AumiOutboundResponse.AdditionalProperties> additionalProperties = getAdditionalProperties(fieldMap, customAumiOutboundCleaner);
      List<AumiOutboundResponse.AuthorizationIndicator> authorizationIndicators = getAuthorizationIndicators(fieldMap);

      if (!mmsIdProviderMode || isAuthIdPresent) {
        if (!additionalProperties.isEmpty()) {
          builder.additionalProperties(additionalProperties);
          log.info(aMarker, "Assigned {} additionalProperties to payload", additionalProperties.size());
        }
        if (!serviceModifiers.isEmpty()) {
          builder.serviceModifiers(serviceModifiers);
          log.info(aMarker, "Assigned {} serviceModifiers to payload", serviceModifiers.size());
        }
        if (!diagnoses.isEmpty()) {
          builder.diagnosis(diagnoses);
          log.info(aMarker, "Assigned {} diagnoses to payload", diagnoses.size());
        }
        if (!providers.isEmpty()) {
          builder.providers(providers);
          log.info(aMarker, "Assigned {} providers to payload", providers.size());
        }
        if (!authorizationIndicators.isEmpty()) {
          builder.authorizationIndicators(authorizationIndicators);
          log.info(aMarker, "Assigned {} authorizationIndicators to payload", authorizationIndicators.size());
        }
      } else {
        if (!authorizationIndicators.isEmpty()) {
          builder.authorizationIndicators(authorizationIndicators);
          log.info(aMarker, "Assigned {} authorizationIndicators to payload", authorizationIndicators.size());
        }
      }

      log.info(aMarker, "Built AumiPayload with conditional inclusion for all fields");
      return builder.build();
    }

    private void putIfPresent(java.util.function.Consumer<AumiOutboundResponse.ExtractedField> setter, AumiOutboundResponse.ExtractedField value) {
      if (value != null && value.getValue() != null && !value.getValue().isEmpty()) {
        setter.accept(value);
      }
    }

    private void putIfPresent(java.util.function.Consumer<AumiOutboundResponse.ExtractedField> setter, Map<String, AumiOutboundResponse.ExtractedField> fieldMap, String key) {
      AumiOutboundResponse.ExtractedField value = fieldMap.get(key);
      if (value != null && value.getValue() != null && !value.getValue().isEmpty()) {
        setter.accept(value);
      }
    }

    private List<AumiOutboundResponse.Provider> getProviderDetails(List<AumiRecord> records, String documentType) {
      List<AumiOutboundResponse.Provider> providers = new ArrayList<>();
      Map<String, List<AumiRecord>> recordsByContainer = new HashMap<>();

      String[] containerPrefixes = {
              "SERVICING_PROVIDER_DETAILS",
              "SERVICING_FACILITY_DETAILS",
              "REFERRING_PROVIDER_DETAILS",
              "UNDEFINED_PROVIDER_DETAILS"
      };

      for (AumiRecord record : records) {
        String itemName = record.getItemName();
        for (String prefix : containerPrefixes) {
          String containerName = prefix;
          if (itemName != null && itemName.startsWith(prefix.toLowerCase().replace("_DETAILS", ""))) {
            recordsByContainer.computeIfAbsent(containerName, k -> new ArrayList<>()).add(record);
          }
        }
      }

      for (Map.Entry<String, List<AumiRecord>> entry : recordsByContainer.entrySet()) {
        String containerName = entry.getKey();
        List<AumiRecord> containerRecords = entry.getValue();
        providers.addAll(mapProviderDetails(containerName, containerRecords));
      }

      return providers;
    }

    private List<AumiOutboundResponse.Provider> mapProviderDetails(String containerName, List<AumiRecord> containerRecords) {
      boolean customAumiOutboundCleaner = getConfigValue("custom_outbound_cleaner", "true").equals("true");
      Map<String, AumiOutboundResponse.ExtractedField> fieldMap = buildFieldMap(containerRecords);
      List<AumiOutboundResponse.Provider> providers = new ArrayList<>();

      String category;
      switch (containerName) {
        case "SERVICING_PROVIDER_DETAILS":
          category = "servicingProvider";
          break;
        case "SERVICING_FACILITY_DETAILS":
          category = "servicingFacility";
          break;
        case "REFERRING_PROVIDER_DETAILS":
          category = "referringProvider";
          break;
        case "UNDEFINED_PROVIDER_DETAILS":
          category = "undeterminedProvider";
          break;
        default:
          log.warn(aMarker, "Invalid provider container: {}", containerName);
          return providers;
      }

      if ("undeterminedProvider".equals(category)) {
        providers.addAll(buildUndefinedProviders(category, containerName.toLowerCase().replace("_DETAILS", ""), fieldMap, customAumiOutboundCleaner));
      } else {
        AumiOutboundResponse.Provider provider = buildProvider(category, containerName.toLowerCase().replace("_DETAILS", ""), fieldMap, customAumiOutboundCleaner);
        if (provider != null) {
          providers.add(provider);
        }
      }

      return providers;
    }

    private AumiOutboundResponse.Provider buildProvider(String category, String prefix, Map<String, AumiOutboundResponse.ExtractedField> fieldMap, boolean customAumiOutboundCleaner) {
      AumiOutboundResponse.Provider.ProviderBuilder builder = AumiOutboundResponse.Provider.builder();

      if (category != null && !category.isEmpty()) {
        builder.providerCategory(category(category));
      }

      putIfPresent(builder::providerNPI, fieldMap, prefix + "_npi");
      putIfPresent(builder::providerTIN, fieldMap, prefix + "_tin");
      putIfPresent(builder::providerFirstName, fieldMap, prefix + "_first_name");
      putIfPresent(builder::providerLastName, fieldMap, prefix + "_last_name");
      putIfPresent(builder::providerAddressLine1, fieldMap, prefix + "_address_line1");
      putIfPresent(builder::providerAddressLine2, fieldMap, prefix + "_address_line2");
      putIfPresent(builder::providerCity, fieldMap, prefix + "_city");
      putIfPresent(builder::providerState, fieldMap, prefix + "_state");
      putIfPresent(builder::providerZipCode, fieldMap, prefix + "_zipcode");
      putIfPresent(builder::providerSpeciality, fieldMap, prefix + "_specialty");

      AumiOutboundResponse.Provider provider = builder.build();
      boolean hasMeaningfulData = (provider.getProviderNPI() != null && provider.getProviderNPI().getValue() != null && !provider.getProviderNPI().getValue().isEmpty()) ||
              (provider.getProviderTIN() != null && provider.getProviderTIN().getValue() != null && !provider.getProviderTIN().getValue().isEmpty());
      if (!hasMeaningfulData) {
        log.info(aMarker, "Skipped provider for category {} due to lack of meaningful data", category);
        return null;
      }
      return provider;
    }

    private List<AumiOutboundResponse.Provider> buildUndefinedProviders(String category, String prefix, Map<String, AumiOutboundResponse.ExtractedField> fieldMap, boolean customAumiOutboundCleaner) {
      List<AumiOutboundResponse.Provider> providers = new ArrayList<>();
      String[] fieldsToSplit = {"_npi", "_tin", "_first_name", "_last_name", "_address_line1", "_address_line2", "_city", "_state", "_zipcode", "_specialty"};

      int maxValues = 1;
      for (String fieldSuffix : fieldsToSplit) {
        AumiOutboundResponse.ExtractedField field = fieldMap.getOrDefault(prefix + fieldSuffix, getDefaultExtractedField());
        String fieldValue = field.getValue() != null ? field.getValue() : "";
        if (fieldValue.contains(",")) {
          String[] values = fieldValue.split(",");
          maxValues = Math.max(maxValues, values.length);
        }
      }

      for (int i = 0; i < maxValues; i++) {
        Map<String, AumiOutboundResponse.ExtractedField> splitFieldMap = new HashMap<>();
        boolean hasMeaningfulData = false;

        for (String fieldSuffix : fieldsToSplit) {
          AumiOutboundResponse.ExtractedField field = fieldMap.getOrDefault(prefix + fieldSuffix, getDefaultExtractedField());
          String fieldValue = field.getValue() != null ? field.getValue() : "";
          String[] fieldValues = fieldValue.contains(",") ? fieldValue.split(",") : new String[]{fieldValue};
          String splitValue = fieldValues.length > i ? fieldValues[i].trim() : "";
          splitFieldMap.put(prefix + fieldSuffix, createSplitExtractedField(field, splitValue));
          if (!splitValue.isEmpty()) {
            hasMeaningfulData = true;
          }
        }

        if (!hasMeaningfulData) {
          log.info(aMarker, "Skipped provider at index {} due to lack of meaningful data", i);
          continue;
        }

        AumiOutboundResponse.Provider provider = buildProvider(category, prefix, splitFieldMap, customAumiOutboundCleaner);
        if (provider != null) {
          providers.add(provider);
        }
      }
      return providers;
    }

    private AumiOutboundResponse.ExtractedField createSplitExtractedField(AumiOutboundResponse.ExtractedField originalField, String value) {
      return AumiOutboundResponse.ExtractedField.builder()
              .value(value)
              .confidence(originalField.getConfidence())
              .page(originalField.getPage())
              .boundingBox(originalField.getBoundingBox())
              .build();
    }

    private List<AumiOutboundResponse.ServiceModifier> getServiceModifier(List<AumiRecord> records, boolean customAumiOutboundCleaner) {
      Map<String, AumiOutboundResponse.ExtractedField> fieldMap = buildFieldMap(records);
      List<AumiOutboundResponse.ServiceModifier> serviceModifiers = new ArrayList<>();

      List<Map.Entry<String, AumiOutboundResponse.ExtractedField>> serviceCodeEntries = fieldMap.entrySet().stream()
              .filter(entry -> entry.getKey().startsWith("service_code"))
              .collect(Collectors.toList());

      for (Map.Entry<String, AumiOutboundResponse.ExtractedField> entry : serviceCodeEntries) {
        String key = entry.getKey();
        AumiOutboundResponse.ExtractedField icd10CodeField = entry.getValue();
        if (icd10CodeField.getValue() == null || icd10CodeField.getValue().isEmpty()) {
          continue;
        }
        String descKey = key.replace("service_code", "service_description");
        String lineNumberKey = key.replace("service_code", "line_number");
        AumiOutboundResponse.ExtractedField description = fieldMap.getOrDefault(descKey, fieldMap.getOrDefault("service_description", null));
        AumiOutboundResponse.ExtractedField lineNumber = fieldMap.getOrDefault(lineNumberKey, fieldMap.getOrDefault("line_number", null));

        AumiOutboundResponse.ServiceModifier.ServiceModifierBuilder builder = AumiOutboundResponse.ServiceModifier.builder()
                .cd(icd10CodeField);
        if (description != null && description.getValue() != null && !description.getValue().isEmpty()) {
          builder.desc(description);
        }
        if (lineNumber != null && lineNumber.getValue() != null && !lineNumber.getValue().isEmpty()) {
          builder.lineNumber(lineNumber);
        }

        AumiOutboundResponse.ServiceModifier modifier = builder.build();
        if (modifier.getCd() != null && modifier.getCd().getValue() != null && !modifier.getCd().getValue().isEmpty()) {
          serviceModifiers.add(modifier);
        }
      }
      return serviceModifiers;
    }

    private List<AumiOutboundResponse.Diagnosis> getDiagnosis(List<AumiRecord> records, boolean customAumiOutboundCleaner) {
      Map<String, AumiOutboundResponse.ExtractedField> fieldMap = buildFieldMap(records);
      List<AumiOutboundResponse.Diagnosis> diagnoses = new ArrayList<>();

      List<Map.Entry<String, AumiOutboundResponse.ExtractedField>> diagnosisCodeEntries = fieldMap.entrySet().stream()
              .filter(entry -> entry.getKey().startsWith("diagnosis_code"))
              .collect(Collectors.toList());

      for (Map.Entry<String, AumiOutboundResponse.ExtractedField> entry : diagnosisCodeEntries) {
        String key = entry.getKey();
        AumiOutboundResponse.ExtractedField icd10CodeField = entry.getValue();
        if (icd10CodeField.getValue() == null || icd10CodeField.getValue().isEmpty()) {
          continue;
        }
        String descKey = key.replace("diagnosis_code", "diagnosis_description");
        String codePointerKey = key.replace("diagnosis_code", "code_pointer");
        AumiOutboundResponse.ExtractedField description = fieldMap.getOrDefault(descKey, fieldMap.getOrDefault("diagnosis_description", null));
        AumiOutboundResponse.ExtractedField codePointer = fieldMap.getOrDefault(codePointerKey, fieldMap.getOrDefault("code_pointer", null));

        AumiOutboundResponse.Diagnosis.DiagnosisBuilder builder = AumiOutboundResponse.Diagnosis.builder()
                .cd(icd10CodeField);
        if (description != null && description.getValue() != null && !description.getValue().isEmpty()) {
          builder.desc(description);
        }
        if (codePointer != null && codePointer.getValue() != null && !codePointer.getValue().isEmpty()) {
          builder.codePointer(codePointer);
        }

        AumiOutboundResponse.Diagnosis diagnosis = builder.build();
        if (diagnosis.getCd() != null && diagnosis.getCd().getValue() != null && !diagnosis.getCd().getValue().isEmpty()) {
          diagnoses.add(diagnosis);
        }
      }
      return diagnoses;
    }

    private List<AumiOutboundResponse.AdditionalProperties> getAdditionalProperties(Map<String, AumiOutboundResponse.ExtractedField> fieldMap, boolean customAumiOutboundCleaner) {
      List<AumiOutboundResponse.AdditionalProperties> additionalProperties = new ArrayList<>();
      List<Map.Entry<String, AumiOutboundResponse.ExtractedField>> levelOfCareEntries = fieldMap.entrySet().stream()
              .filter(entry -> entry.getKey().startsWith("level_of_care"))
              .sorted(Map.Entry.comparingByKey())
              .collect(Collectors.toList());

      for (Map.Entry<String, AumiOutboundResponse.ExtractedField> entry : levelOfCareEntries) {
        AumiOutboundResponse.ExtractedField levelOfCareField = entry.getValue();
        String levelOfCareValue = levelOfCareField.getValue();
        if (levelOfCareValue == null || levelOfCareValue.isEmpty()) {
          continue;
        }
        String[] levelOfCareValues = levelOfCareValue.contains(",") ?
                levelOfCareValue.split(",") : new String[]{levelOfCareValue};
        for (String value : levelOfCareValues) {
          value = value.trim();
          if (value.isEmpty()) {
            continue;
          }
          additionalProperties.add(AumiOutboundResponse.AdditionalProperties.builder()
                  .propName("AUTH_KEYWORD")
                  .propValue(value)
                  .page(levelOfCareField.getPage())
                  .confidence(levelOfCareField.getConfidence())
                  .boundingBox(levelOfCareField.getBoundingBox())
                  .build());
        }
      }

      List<Map.Entry<String, AumiOutboundResponse.ExtractedField>> additionalAuthEntries = fieldMap.entrySet().stream()
              .filter(entry -> entry.getKey().startsWith("additional_auth_properties"))
              .collect(Collectors.toList());

      for (Map.Entry<String, AumiOutboundResponse.ExtractedField> entry : additionalAuthEntries) {
        AumiOutboundResponse.ExtractedField additionalAuthField = entry.getValue();
        String additionalAuthFieldValue = additionalAuthField.getValue();
        if (additionalAuthFieldValue == null || additionalAuthFieldValue.isEmpty()) {
          continue;
        }
        additionalProperties.add(AumiOutboundResponse.AdditionalProperties.builder()
                .propName("AUTH_ADDL_KEYWORD")
                .propValue(additionalAuthFieldValue)
                .page(additionalAuthField.getPage())
                .confidence(additionalAuthField.getConfidence())
                .boundingBox(additionalAuthField.getBoundingBox())
                .build());
      }

      return additionalProperties;
    }

    private List<AumiOutboundResponse.AuthorizationIndicator> getAuthorizationIndicators(Map<String, AumiOutboundResponse.ExtractedField> fieldMap) {
      List<AumiOutboundResponse.AuthorizationIndicator> authorizationIndicators = new ArrayList<>();
      List<Map.Entry<String, AumiOutboundResponse.ExtractedField>> authIdEntries = fieldMap.entrySet().stream()
              .filter(entry -> entry.getKey().startsWith("auth_id_"))
              .sorted(Map.Entry.comparingByKey())
              .collect(Collectors.toList());

      for (Map.Entry<String, AumiOutboundResponse.ExtractedField> entry : authIdEntries) {
        AumiOutboundResponse.ExtractedField authIdField = entry.getValue();
        String authIdValue = authIdField.getValue();
        if (authIdValue == null || authIdValue.isEmpty()) {
          continue;
        }
        authorizationIndicators.add(AumiOutboundResponse.AuthorizationIndicator.builder()
                .propName("ADDL_MMS_ID")
                .propValue(authIdValue)
                .page(authIdField.getPage())
                .confidence(authIdField.getConfidence())
                .boundingBox(authIdField.getBoundingBox())
                .build());
      }
      return authorizationIndicators;
    }

    private Map<String, AumiOutboundResponse.ExtractedField> buildFieldMap(List<AumiRecord> records) {
      Map<String, AumiOutboundResponse.ExtractedField> fieldMap = new HashMap<>();
      boolean aumiReorderPaperNumber = getConfigValue("aumi.reorder.paper.number", "true").equals("true");
      int floatValueRoundingPrecision = Integer.parseInt(getConfigValue("FLOAT_VALUE_ROUNDING_PRECISION", String.valueOf(FLOAT_VALUE_ROUNDING_PRECISION)));
      int confidenceScoreMultiplyValue = Integer.parseInt(getConfigValue("CONFIDENCE_SCORE_MULTIPLY_VARIABLE", String.valueOf(CONFIDENCE_SCORE_MULTIPLY_VALUE)));
      int scaledWidth = Integer.parseInt(getConfigValue("AUMI_BBOX_SCALAR_WIDTH", String.valueOf(AUMI_BBOX_SCALAR_WIDTH)));
      int scaledHeight = Integer.parseInt(getConfigValue("AUMI_BBOX_SCALAR_HEIGHT", String.valueOf(AUMI_BBOX_SCALAR_HEIGHT)));

      for (AumiRecord record : records) {
        String itemName = record.getItemName();
        String predictedValue = record.getPredictedValue();
        if (predictedValue == null || predictedValue.isEmpty()) {
          continue;
        }
        List<String> values = "multi_value".equals(record.getLineItemType()) ?
                Arrays.stream(predictedValue.split(","))
                        .map(String::trim)
                        .filter(val -> !val.isEmpty())
                        .collect(Collectors.toList()) :
                List.of(predictedValue);

        int precisionValue = (int) (record.getPrecision() * confidenceScoreMultiplyValue);
        int roundedConfidenceScore = (int) (Math.round(precisionValue / 10.0) * 10);
        int paperNo = record.getPaperNo();
        int paperNumber = aumiReorderPaperNumber && paperNo >= 1 ? paperNo - 1 : paperNo;

        double[] boundingBoxArray = new double[]{
                record.getX(), record.getY(), record.getWidth(), record.getHeight()
        };
        double[] rescaledBoxes = rescaleBoundingBox(
                boundingBoxArray, 1000, 1000, scaledWidth, scaledHeight, floatValueRoundingPrecision);

        ObjectNode boundingBoxJsonNode = objectMapper.createObjectNode();
        boundingBoxJsonNode.put("x", rescaledBoxes[0]);
        boundingBoxJsonNode.put("y", rescaledBoxes[1]);
        boundingBoxJsonNode.put("width", rescaledBoxes[2]);
        boundingBoxJsonNode.put("height", rescaledBoxes[3]);

        for (int i = 0; i < values.size(); i++) {
          String value = values.get(i);
          if (value.isEmpty()) {
            continue;
          }
          String key = values.size() > 1 ? itemName + "_" + (i + 1) : itemName;
          AumiOutboundResponse.ExtractedField extractedField = AumiOutboundResponse.ExtractedField.builder()
                  .value(value)
                  .confidence((double) roundedConfidenceScore)
                  .page(paperNumber)
                  .boundingBox(boundingBoxJsonNode)
                  .build();
          fieldMap.put(key, extractedField);
        }
      }
      return fieldMap;
    }

    private AumiOutboundResponse.ExtractedField getDefaultExtractedField() {
      ObjectNode boundingBoxJsonNode = objectMapper.createObjectNode();
      boundingBoxJsonNode.put("x", DEFAULT_DOUBLE_VALUE);
      boundingBoxJsonNode.put("y", DEFAULT_DOUBLE_VALUE);
      boundingBoxJsonNode.put("width", DEFAULT_DOUBLE_VALUE);
      boundingBoxJsonNode.put("height", DEFAULT_DOUBLE_VALUE);

      return AumiOutboundResponse.ExtractedField.builder()
              .value(DEFAULT_VALUE)
              .page(0)
              .confidence(0.0)
              .boundingBox(boundingBoxJsonNode)
              .build();
    }

    private double[] rescaleBoundingBox(double[] boundingBox, int originalWidth, int originalHeight, int scaledWidth, int scaledHeight, int floatValueRoundingPrecision) {
      double xScale = (double) originalWidth / scaledWidth;
      double yScale = (double) originalHeight / scaledHeight;

      double xMin = round(boundingBox[0] * xScale, floatValueRoundingPrecision);
      double yMin = round(boundingBox[1] * yScale, floatValueRoundingPrecision);
      double xMax = round(boundingBox[2] * xScale, floatValueRoundingPrecision);
      double yMax = round(boundingBox[3] * yScale, floatValueRoundingPrecision);

      return new double[]{xMin, yMin, xMax, yMax};
    }

    private double round(double value, int places) {
      if (places < 0) throw new IllegalArgumentException("Decimal places must be non-negative.");
      BigDecimal bd = BigDecimal.valueOf(value);
      bd = bd.setScale(places, RoundingMode.HALF_UP);
      return bd.doubleValue();
    }

    private String getConfigValue(String variable, String defaultValue) {
      String value = action.getContext().get(variable);
      if (value == null || value.isEmpty()) {
        log.info(aMarker, "Configuration variable {} not found in context, using default: {}", variable, defaultValue);
        return defaultValue;
      }
      log.info(aMarker, "Retrieved configuration variable {}: {}", variable, value);
      return value;
    }

    private AumiOutboundResponse.CategoryField category(String category) {
      return AumiOutboundResponse.CategoryField.builder()
              .value(category)
              .build();
    }

    @Override
    public boolean executeIf() throws Exception {
      return outboundResponse.getCondition();
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class SummaryAudit {
      private int rowCount;
      private int correctRowCount;
      private int errorRowCount;
      private String comments;
      private Long tenantId;
      private String batchId;
    }

    private static class AumiRecord {
      private final String itemName;
      private final String predictedValue;
      private final int paperNo;
      private final double precision;
      private final double x;
      private final double width;
      private final double y;
      private final double height;
      private final String lineItemType;

      public AumiRecord(String itemName, String predictedValue, int paperNo, double precision, double x, double width, double y, double height, String lineItemType) {
        this.itemName = itemName;
        this.predictedValue = predictedValue;
        this.paperNo = paperNo;
        this.precision = precision;
        this.x = x;
        this.width = width;
        this.y = y;
        this.height = height;
        this.lineItemType = lineItemType;
      }

      public String getItemName() { return itemName; }
      public String getPredictedValue() { return predictedValue; }
      public int getPaperNo() { return paperNo; }
      public double getPrecision() { return precision; }
      public double getX() { return x; }
      public double getWidth() { return width; }
      public double getY() { return y; }
      public double getHeight() { return height; }
      public String getLineItemType() { return lineItemType; }
    }
}
