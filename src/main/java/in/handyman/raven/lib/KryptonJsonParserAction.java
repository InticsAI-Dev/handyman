package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.KryptonJsonParser;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


import in.handyman.raven.lib.model.krypton.jsonparser.KryptonJsonParsedResponse;
import in.handyman.raven.lib.model.krypton.jsonparser.KryptonJsonQueryInputTable;
import in.handyman.raven.lib.model.krypton.jsonparser.KryptonJsonQueryOutputTable;

import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;

import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "KryptonJsonParser"
)
public class KryptonJsonParserAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final KryptonJsonParser kryptonJsonParser;
  public static final String READ_BATCH_SIZE = "read.batch.size";
  public static final String WRITE_BATCH_SIZE = "write.batch.size";
  public static final String THREAD_SLEEP_TIME = "1000";
  public static final String CONSUMER_API_COUNT = "krypton.kvp.parser.consumer.API.count";

  private final Marker aMarker;
  private final int threadSleepTime;
  private final Integer readBatchSize;
  private final Integer writeBatchSize;
  //private final Integer consumerApiCount;

  public KryptonJsonParserAction(final ActionExecutionAudit action, final Logger log,
      final Object kryptonJsonParser) {
    this.kryptonJsonParser = (KryptonJsonParser) kryptonJsonParser;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" KryptonJsonParser:"+this.kryptonJsonParser.getName());
    this.threadSleepTime = Integer.parseInt(THREAD_SLEEP_TIME);
    String writeBatchSizeStr = this.action.getContext().get(WRITE_BATCH_SIZE);
    this.writeBatchSize = Integer.valueOf(writeBatchSizeStr);
    //String consumerApiCountStr = this.action.getContext().get(CONSUMER_API_COUNT);
    //consumerApiCount = Integer.valueOf(consumerApiCountStr);
    this.readBatchSize = Integer.valueOf(action.getContext().get(READ_BATCH_SIZE));
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(kryptonJsonParser.getResourceConn());
      jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
      log.info(aMarker, "krypton json parser action {} has been started ", kryptonJsonParser.getName());

      final String insertQuery = "INSERT INTO " + kryptonJsonParser.getOutputTable() +
              "(created_on,created_user_id, last_updated_on, last_updated_user_id,sor_container_name,sor_item_name, answer, paper_no, " +
              "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
              "extracted_image_unit, image_dpi, image_height, image_width) "
              + " VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?  ,?,?,?,?)";
      log.info(aMarker, "krypton json parser insert query {}", insertQuery);

      final String selectQuery = kryptonJsonParser.getQuerySet();
      List<KryptonJsonQueryInputTable> inputTableList = jdbi.withHandle(handle -> handle.createQuery(selectQuery)
              .mapToBean(KryptonJsonQueryInputTable.class)
              .list());

      ObjectMapper objectMapper = new ObjectMapper();

      jdbi.useTransaction(handle -> {
        for (KryptonJsonQueryInputTable inputTable: inputTableList){
          String jsonResponse = inputTable.getResponse();
          JsonNode rootNode = objectMapper.readTree(jsonResponse);
          List<KryptonJsonParsedResponse> innerParsedResponses = new ArrayList<>();
          parseJsonNode(rootNode, "", "", innerParsedResponses);
          for (KryptonJsonParsedResponse parsedResponse : innerParsedResponses) {
            handle.createUpdate(insertQuery)
                    .bind(0,Timestamp.valueOf(LocalDateTime.now()))
                    .bind(1, inputTable.getTenantId())
                    .bind(2, Timestamp.valueOf(LocalDateTime.now()))
                    .bind(3, inputTable.getTenantId())
                    .bind(4, parsedResponse.getSorContainerName())
                    .bind(5, parsedResponse.getSorItemName())
                    .bind(6, parsedResponse.getAnswer())
                    .bind(7,inputTable.getPaperNo())
                    .bind(8, inputTable.getOriginId())
                    .bind(9, inputTable.getGroupId())
                    .bind(10, inputTable.getTenantId())
                    .bind(11, inputTable.getRootPipelineId())
                    .bind(12, inputTable.getBatchId())
                    .bind(13, inputTable.getModelRegistry())
                    .bind(14, inputTable.getExtractedImageUnit())
                    .bind(15, inputTable.getImageDpi())
                    .bind(16, inputTable.getImageHeight())
                    .bind(17, inputTable.getImageWidth())
                    .execute();

        }}

      });


      log.info(aMarker, " krypton json parser actionhas been completed {}  ", kryptonJsonParser.getName());
    }catch (Exception e) {
      action.getContext().put(kryptonJsonParser.getName() + ".isSuccessful", "false");
      log.error(aMarker, "error in execute method for krypton json parser action", e);
      throw new HandymanException("error in execute method for krypton json parser action", e,action);
    }
  }

  private void parseJsonNode(JsonNode rootNode, String currentKey, String parentPath, List<KryptonJsonParsedResponse> parsedResponses) {
    if (rootNode.isObject()) {
      Iterator<Map.Entry<String, JsonNode>> fields = rootNode.fields();
      while (fields.hasNext()) {
        Map.Entry<String, JsonNode> field = fields.next();
        String key = field.getKey();
        String newCurrentKey = key;
        String newParentPath = parentPath.isEmpty() ? currentKey : parentPath + ", " + currentKey;
        parseJsonNode(field.getValue(), newCurrentKey, newParentPath, parsedResponses);
        //parseJsonNode(value, parentKey.isEmpty() ? key : parentKey , parsedResponses);
      }
    } else if (rootNode.isArray()) {
      for (JsonNode arrayElement : rootNode) {
        parseJsonNode(arrayElement, currentKey, parentPath, parsedResponses);
      }
    } else {
      KryptonJsonParsedResponse parsedResponse = KryptonJsonParsedResponse.builder()
              .sorContainerName(parentPath)
              .sorItemName(currentKey)
              .answer(rootNode.asText())
              .build();
      parsedResponses.add(parsedResponse);
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return kryptonJsonParser.getCondition();
  }
}
