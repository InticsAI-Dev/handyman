package in.handyman.raven.lib;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.core.encryption.impl.EncryptionRequestClass;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.lib.model.LlmJsonParser;
import in.handyman.raven.lib.model.common.CreateTimeStamp;
import in.handyman.raven.lib.model.kvp.llm.jsonparser.*;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.sql.Types;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "LlmJsonParser"
)
public class LlmJsonParserAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final LlmJsonParser llmJsonParser;
    public static final String READ_BATCH_SIZE = "read.batch.size";
    public static final String WRITE_BATCH_SIZE = "write.batch.size";
    private final Marker aMarker;


    public LlmJsonParserAction(final ActionExecutionAudit action, final Logger log,
                               final Object llmJsonParser) {
        this.llmJsonParser = (LlmJsonParser) llmJsonParser;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" LlmJsonParser:" + this.llmJsonParser.getName());

    }

    @Override
    public void execute() {
        try {
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(llmJsonParser.getResourceConn());
            jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
            log.info(aMarker, "LLM JSON parser action {} has started", llmJsonParser.getName());

            final String selectQuery = llmJsonParser.getQuerySet();
            List<LlmJsonQueryInputTable> inputTableList = jdbi.withHandle(handle ->
                    handle.createQuery(selectQuery)
                            .mapToBean(LlmJsonQueryInputTable.class)
                            .list()
            );
            log.info("Query executed, returned {} rows", inputTableList.size());

            boolean decryptEnabled = Boolean.parseBoolean(action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION));
            InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

            // Batch decryption
            if (decryptEnabled) {
                List<EncryptionRequestClass> decryptRequests = inputTableList.stream()
                        .map(item -> new EncryptionRequestClass( "AES256",item.getResponse(), "LLM_OUTPUT_JSON"))
                        .collect(Collectors.toList());

                List<EncryptionRequestClass> decryptedResults = encryption.decrypt(decryptRequests);
                for (int i = 0; i < inputTableList.size(); i++) {
                    inputTableList.get(i).setResponse(decryptedResults.get(i).getValue());
                }
            }

            ObjectMapper objectMapper = new ObjectMapper();

            jdbi.useTransaction(handle -> {
                for (LlmJsonQueryInputTable inputTable : inputTableList) {
                    String jsonResponse = inputTable.getResponse();
                    JsonNode rootNode = convertFormattedJsonStringToJsonNode(jsonResponse, objectMapper);
                    if (rootNode == null) continue;

                    final String insertQuery = rootNode.isObject()
                            ? buildInsertQueryXenon()
                            : buildInsertQueryKrypton();

                    if (rootNode.isObject()) {
                        List<LlmJsonParsedResponse> parsedList = new ArrayList<>();
                        parseJsonNode(rootNode, "", "", parsedList);

                        // Batch encryption of parsed responses
                        List<LlmJsonParsedResponse> encryptedList = batchEncryptJsonAnswers(
                                action,
                                parsedList,
                                inputTable.getSorMetaDetail(),
                                encryption,
                                decryptEnabled
                        );

                        for (LlmJsonParsedResponse parsedResponse : encryptedList) {
                            getInsertIntoXenonResultTable(handle, inputTable, parsedResponse, insertQuery);
                        }

                    } else if (rootNode.isArray()) {
                        List<LlmJsonParserKvpKrypton> parsedArray = objectMapper.convertValue(
                                rootNode, new TypeReference<>() {}
                        );

                        List<LlmJsonParserKvpKrypton> encryptedArray = batchEncryptJsonArrayAnswers(
                                action,
                                parsedArray,
                                inputTable.getSorMetaDetail(),
                                encryption,
                                decryptEnabled
                        );

                        for (LlmJsonParserKvpKrypton parsedResponse : encryptedArray) {
                            boolean isBboxEnabled = Objects.equals(
                                    action.getContext().get("sor.transaction.bbox.parser.activator.enable"), "true"
                            );
                            boolean isConfidenceScoreEnabled = Objects.equals(
                                    action.getContext().get("sor.transaction.parser.confidence.activator.enable"), "true"
                            );

                            String boundingBox = isBboxEnabled
                                    ? Optional.ofNullable(parsedResponse.getBoundingBox()).map(Object::toString).orElse("{}")
                                    : "{}";
                            double confidenceScore = isConfidenceScoreEnabled
                                    ? parsedResponse.getConfidence()
                                    : 0.00;

                            LlmJsonQueryOutputTable insertData = LlmJsonQueryOutputTable.builder()
                                    .createdOn(String.valueOf(inputTable.getCreatedOn()))
                                    .tenantId(inputTable.getTenantId())
                                    .lastUpdatedOn(CreateTimeStamp.currentTimestamp())
                                    .lastUpdatedUserId(inputTable.getTenantId())
                                    .confidenceScore(confidenceScore)
                                    .sorItemName(parsedResponse.getKey())
                                    .answer(parsedResponse.getValue())
                                    .boundingBox(boundingBox)
                                    .paperNo(inputTable.getPaperNo())
                                    .originId(inputTable.getOriginId())
                                    .groupId(inputTable.getGroupId())
                                    .rootPipelineId(inputTable.getRootPipelineId())
                                    .batchId(inputTable.getBatchId())
                                    .modelRegistry(inputTable.getModelRegistry())
                                    .extractedImageUnit(inputTable.getExtractedImageUnit())
                                    .imageDpi(inputTable.getImageDpi())
                                    .imageHeight(inputTable.getImageHeight())
                                    .imageWidth(inputTable.getImageWidth())
                                    .sorContainerId(inputTable.getSorContainerId())
                                    .sorItemLabel(parsedResponse.getLabel())
                                    .build();

                            getInsertIntoKryptonResultTable(handle, insertQuery, insertData);
                        }
                    }
                }
            });

            log.info(aMarker, "LLM JSON parser action {} completed", llmJsonParser.getName());
        } catch (Exception e) {
            action.getContext().put(llmJsonParser.getName() + ".isSuccessful", "false");
            HandymanException ex = new HandymanException(e);
            HandymanException.insertException("Error in execute() for LLM JSON parser", ex, action);
        }
    }


    private List<LlmJsonParsedResponse> batchEncryptJsonAnswers(
            ActionExecutionAudit action,
            List<LlmJsonParsedResponse> parsedResponses,
            String sorMetaDetail,
            InticsIntegrity encryption,
            boolean isEncryptionEnabled) throws Exception {

        if (!isEncryptionEnabled || parsedResponses == null || parsedResponses.isEmpty()) {
            return parsedResponses;
        }

        ObjectMapper mapper = new ObjectMapper();

        List<LlmJsonQueryInputTableSorMeta> sorMetaList = mapper.readValue(
                sorMetaDetail,
                new TypeReference<List<LlmJsonQueryInputTableSorMeta>>() {}
        );

        List<EncryptionRequestClass> encryptionRequests = new ArrayList<>();
        for (LlmJsonParsedResponse response : parsedResponses) {
            String policy = getEncryptionPolicyForKey(sorMetaList, response.getSorItemName());
            encryptionRequests.add(new EncryptionRequestClass(
                    policy, response.getAnswer(),
                    response.getSorItemName()
            ));
        }

        List<EncryptionRequestClass> encryptedResults = encryption.encrypt(encryptionRequests);
        for (int i = 0; i < parsedResponses.size(); i++) {
            parsedResponses.get(i).setAnswer(encryptedResults.get(i).getValue());
        }

        return parsedResponses;
    }
    private String getEncryptionPolicyForKey(List<LlmJsonQueryInputTableSorMeta> metaList, String key) {
        return metaList.stream()
                .filter(meta -> key.equalsIgnoreCase(meta.getSorItemName()))
                .map(LlmJsonQueryInputTableSorMeta::getEncryptionPolicy)
                .findFirst()
                .orElse("AES256");  // Default fallback
    }

    private List<LlmJsonParserKvpKrypton> batchEncryptJsonArrayAnswers(
            ActionExecutionAudit action,
            List<LlmJsonParserKvpKrypton> parsedResponses,
            String sorMetaDetail,
            InticsIntegrity encryption,
            boolean isEncryptionEnabled) throws Exception {

        if (!isEncryptionEnabled || parsedResponses == null || parsedResponses.isEmpty()) {
            return parsedResponses;
        }

        ObjectMapper mapper = new ObjectMapper();

        List<LlmJsonQueryInputTableSorMeta> sorMetaList = mapper.readValue(
                sorMetaDetail,
                new TypeReference<List<LlmJsonQueryInputTableSorMeta>>() {}
        );

        // Prepare batch encryption requests
        List<EncryptionRequestClass> encryptionRequests = new ArrayList<>();
        for (LlmJsonParserKvpKrypton response : parsedResponses) {
            String policy = getEncryptionPolicyForKey(sorMetaList, response.getKey());
            encryptionRequests.add(new EncryptionRequestClass(
                    policy , response.getValue(),
                    response.getKey()
            ));
        }

        // Perform batch encryption
        List<EncryptionRequestClass> encryptedResults = encryption.encrypt(encryptionRequests);

        // Update original list with encrypted values
        for (int i = 0; i < parsedResponses.size(); i++) {
            parsedResponses.get(i).setValue(encryptedResults.get(i).getValue());
        }

        return parsedResponses;
    }

    private String buildInsertQueryKrypton() {
        return "INSERT INTO " + llmJsonParser.getOutputTable() +
                "(created_on, created_user_id, last_updated_on, last_updated_user_id, confidence, sor_item_name, answer, bbox, paper_no, \n" +
                "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry, \n" +
                "extracted_image_unit, image_dpi, image_height, image_width, sor_container_id, sor_item_label) \n" +
                "VALUES (?::timestamp, ?, ?, ?, ?, ?, ?, ?::jsonb, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    }


    @NotNull
    private String buildInsertQueryXenon() {
        return "INSERT INTO " + llmJsonParser.getOutputTable() +
                "(created_on,created_user_id, last_updated_on, last_updated_user_id,sor_container_name,sor_item_name, answer, paper_no, " +
                "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
                "extracted_image_unit, image_dpi, image_height, image_width, sor_container_id, sor_item_label) "
                + " VALUES(?::timestamp,?,?,?,?,?,?,?,?,?,?,?,?,?  ,?,?,?,?,?,?)";
    }

    public static List<LlmJsonParsedResponse> encryptJsonAnswers(ActionExecutionAudit action,
                                                                 List<LlmJsonParsedResponse> responses,
                                                                 List<LlmJsonQueryInputTableSorMeta> metaList, InticsIntegrity inticsIntegrity, String encryptData
    ) throws Exception {

        // Create a map of sorItemName to encryption policy
        Map<String, LlmJsonQueryInputTableSorMeta> metaMap = new HashMap<>();
        for (LlmJsonQueryInputTableSorMeta meta : metaList) {
            metaMap.put(meta.getSorItemName(), meta);
        }

        // Process encryption
        return responses.stream().map(response -> {
            try {
                LlmJsonQueryInputTableSorMeta meta = metaMap.get(response.getSorItemName());
                if (meta != null && "true".equalsIgnoreCase(meta.getIsEncrypted())) {

                    if (Objects.equals(encryptData, "true")) {
                        if (Objects.equals(meta.getIsEncrypted().toString(), "true")) {
                            response.setAnswer(trimTo255Characters(response.getAnswer(), action));
                            response.setAnswer(inticsIntegrity.encrypt(response.getAnswer(), "AES256", meta.getSorItemName()));
                        } else {
                            response.setAnswer(trimTo255Characters(response.getAnswer(), action));
                            response.setAnswer(response.getAnswer());
                        }
                    } else {
                        response.setAnswer(response.getAnswer());
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return response;
        }).collect(Collectors.toList());
    }


    public static LlmJsonParserKvpKrypton encryptJsonArrayAnswers(
            ActionExecutionAudit action,
            LlmJsonParserKvpKrypton response,
            List<LlmJsonQueryInputTableSorMeta> metaList,
            InticsIntegrity inticsIntegrity,
            String encryptData
    ) throws Exception {

        // Create a map of sorItemName to encryption metadata
        Map<String, LlmJsonQueryInputTableSorMeta> metaMap = new HashMap<>();
        for (LlmJsonQueryInputTableSorMeta meta : metaList) {
            metaMap.put(meta.getSorItemName(), meta);
        }

        // Check if response key exists in the metadata map
        LlmJsonQueryInputTableSorMeta meta = metaMap.get(response.getKey());

        if (meta != null && "true".equalsIgnoreCase(meta.getIsEncrypted())) {
            if (Objects.equals(encryptData, "true")) {
                response.setValue(trimTo255Characters(response.getValue(), action));
                response.setValue(inticsIntegrity.encrypt(response.getValue(), "AES256", meta.getSorItemName()));
            } else {
                response.setValue(trimTo255Characters(response.getValue(), action));
            }
        } else {
            response.setValue(trimTo255Characters(response.getValue(), action));
        }

        return response;
    }

    private static void getInsertIntoXenonResultTable(Handle handle, LlmJsonQueryInputTable inputTable, LlmJsonParsedResponse parsedResponse, String insertQueryXenon) {

        handle.createUpdate(insertQueryXenon)
                .bind(0, inputTable.getCreatedOn())
                .bind(1, inputTable.getTenantId())
                .bind(2, CreateTimeStamp.currentTimestamp())
                .bind(3, inputTable.getTenantId())
                .bind(4, parsedResponse.getSorContainerName())
                .bind(5, parsedResponse.getSorItemName())
                .bind(6, parsedResponse.getAnswer())
                .bind(7, inputTable.getPaperNo())
                .bind(8, inputTable.getOriginId())
                .bind(9, inputTable.getGroupId())
                .bind(10, inputTable.getTenantId())
                .bind(11, inputTable.getRootPipelineId())
                .bind(12, inputTable.getBatchId())
                .bind(13, inputTable.getModelRegistry())
                .bind(14, inputTable.getExtractedImageUnit())
                .bind(15, inputTable.getImageDpi())
                .bind(16, inputTable.getImageHeight())
                .bind(17, inputTable.getImageWidth())
                .bind(18, inputTable.getSorContainerId())
                .bind(19, inputTable.getSorItemLabel())
                .execute();
    }

    private static int getInsertIntoKryptonResultTable(Handle handle, String insertQueryKrypton, LlmJsonQueryOutputTable llmJsonQueryOutputTable) {

        return handle.createUpdate(insertQueryKrypton)
                .bind(0, llmJsonQueryOutputTable.getCreatedOn())
                .bind(1, llmJsonQueryOutputTable.getTenantId())
                .bind(2, CreateTimeStamp.currentTimestamp())
                .bind(3, llmJsonQueryOutputTable.getTenantId())
                .bind(4, llmJsonQueryOutputTable.getConfidenceScore())
                .bind(5, llmJsonQueryOutputTable.getSorItemName())
                .bind(6, llmJsonQueryOutputTable.getAnswer())
                .bind(7, llmJsonQueryOutputTable.getBoundingBox())
                .bind(8, llmJsonQueryOutputTable.getPaperNo())
                .bind(9, llmJsonQueryOutputTable.getOriginId())
                .bind(10, llmJsonQueryOutputTable.getGroupId())
                .bind(11, llmJsonQueryOutputTable.getTenantId())
                .bind(12, llmJsonQueryOutputTable.getRootPipelineId())
                .bind(13, llmJsonQueryOutputTable.getBatchId())
                .bind(14, llmJsonQueryOutputTable.getModelRegistry())
                .bind(15, llmJsonQueryOutputTable.getExtractedImageUnit())
                .bind(16, llmJsonQueryOutputTable.getImageDpi())
                .bind(17, llmJsonQueryOutputTable.getImageHeight())
                .bind(18, llmJsonQueryOutputTable.getImageWidth())
                .bind(19, llmJsonQueryOutputTable.getSorContainerId())
                .bind(20,llmJsonQueryOutputTable.getSorItemLabel())
                .execute();
    }


    private void parseJsonNode(JsonNode rootNode, String currentKey, String parentPath, List<LlmJsonParsedResponse> parsedResponses) {
        if (rootNode.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = rootNode.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                String key = field.getKey();
                String newCurrentKey = key;
                String newParentPath = parentPath.isEmpty() ? currentKey : parentPath + ", " + currentKey;
                parseJsonNode(field.getValue(), newCurrentKey, newParentPath, parsedResponses);
            }
        } else if (rootNode.isArray()) {
            for (JsonNode arrayElement : rootNode) {
                parseJsonNode(arrayElement, currentKey, parentPath, parsedResponses);
            }
        } else {
            LlmJsonParsedResponse parsedResponse = LlmJsonParsedResponse.builder()
                    .sorContainerName(parentPath)
                    .sorItemName(currentKey)
                    .answer(rootNode.asText())
                    .build();
            parsedResponses.add(parsedResponse);
        }
    }

    public JsonNode convertFormattedJsonStringToJsonNode(String jsonResponse, ObjectMapper objectMapper) {
        try {
            if (jsonResponse.contains("```json")) {
                log.info("Input contains the required ```json``` markers. So processing it based on the ```json``` markers.");
                // Define the regex pattern to match content between ```json and ```
                Pattern pattern = Pattern.compile("(?s)```json\\s*(.*?)\\s*```");
                Matcher matcher = pattern.matcher(jsonResponse);
                if (matcher.find()) {
                    // Extract the JSON string from the matched group
                    String jsonString = matcher.group(1);
                    jsonString = jsonString.replace("\n", "");
                    // Convert the cleaned JSON string to a JsonNode
                    jsonResponse = repairJson(jsonString);
                    if (!jsonResponse.isEmpty()) {
                        return objectMapper.readTree(jsonResponse);
                    } else {
                        return null;
                    }
                } else {
                    jsonResponse = repairJson(jsonResponse);
                    return objectMapper.readTree(jsonResponse);
                }
            } else if ((jsonResponse.contains("{")) | (jsonResponse.contains("["))) {
                log.info("Input does not contain the required ```json``` markers. So processing it based on the indication of object literals.");
                return objectMapper.readTree(jsonResponse);
            } else {
                log.info("Input does not contain the required ```json``` markers or any indication of object literals. So returning null.");
                return null;
            }
        } catch (Exception e) {
            e.printStackTrace();
            log.info("json not found {}", e);
            return null;
        }
    }

    private String repairJson(String jsonString) {

        // Ensure keys and string values are enclosed in double quotes
        jsonString = addMissingQuotes(jsonString);

        // Balance braces and brackets
        jsonString = balanceBracesAndBrackets(jsonString);

        // Assign empty strings to keys with no values
        jsonString = assignEmptyValues(jsonString);

        return jsonString;
    }

    private String addMissingQuotes(String jsonString) {
        // Ensure keys are enclosed in double quotes
        jsonString = jsonString.replaceAll("(\\{|,\\s*)(\\w+)(?=\\s*:)", "$1\"$2\"");

        // Ensure string values are enclosed in double quotes
        // This regex matches values that are not already enclosed in quotes
        jsonString = jsonString.replaceAll("(?<=:)\\s*([^\"\\s,\\n}\\]]+)(?=\\s*(,|}|\\n|\\]))", "\"$1\"");

        return jsonString;
    }

    private String balanceBracesAndBrackets(String jsonString) {
        // Balance braces and brackets
        int openBraces = 0;
        int closeBraces = 0;
        int openBrackets = 0;
        int closeBrackets = 0;

        for (char c : jsonString.toCharArray()) {
            if (c == '{') openBraces++;
            if (c == '}') closeBraces++;
            if (c == '[') openBrackets++;
            if (c == ']') closeBrackets++;
        }

        // Add missing closing braces
        while (openBraces > closeBraces) {
            jsonString += "}";
            closeBraces++;
        }

        // Add missing closing brackets
        while (openBrackets > closeBrackets) {
            jsonString += "]";
            closeBrackets++;
        }

        return jsonString;
    }

    private String assignEmptyValues(String jsonString) {
        // Assign empty strings to keys with no values
        jsonString = jsonString.replaceAll("(?<=:)\\s*(?=,|\\s*}|\\s*\\])", "\"\"");
        return jsonString;
    }

    @Override
    public boolean executeIf() throws Exception {
        return llmJsonParser.getCondition();
    }

    private static String trimTo255Characters(String input, ActionExecutionAudit action) {
        boolean trimExtractedValue = Objects.equals(action.getContext().get("llm.json.parser.trim.extracted.value"), "true");
        String trimmedPredictedValue = "";
        if (trimExtractedValue) {
            if (input != null && input.length() > 255) {
                trimmedPredictedValue = input.substring(0, 255);
            } else {
                // Return the original string if length is <= 255
                trimmedPredictedValue = input;
            }

        }
        return trimmedPredictedValue;
    }

}