package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.LlmJsonParser;
import in.handyman.raven.lib.model.common.CreateTimeStamp;
import in.handyman.raven.lib.model.jsonParser.KVP.SORParser;
import in.handyman.raven.lib.model.jsonParser.Text.ContentNode;
import in.handyman.raven.lib.model.jsonParser.KVP.KVPContentNode;
import in.handyman.raven.lib.model.jsonParser.Text.TextLineItems;
import in.handyman.raven.lib.model.jsonParser.Text.TextParser;
import in.handyman.raven.lib.model.kvp.llm.jsonparser.LlmJsonParsedResponse;
import in.handyman.raven.lib.model.kvp.llm.jsonparser.LlmJsonQueryInputTable;
import in.handyman.raven.lib.model.jsonParser.Table.TableParser;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;
import com.fasterxml.jackson.databind.node.ArrayNode;
import in.handyman.raven.lib.model.jsonParser.Bbox;


import java.sql.Types;
import java.util.*;

import static in.handyman.raven.lib.model.jsonParser.checkbox.CheckboxParser.processJson;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "LlmJsonParser"
)
public class LlmJsonParserAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final LlmJsonParser llmJsonParser;
  public static final String READ_BATCH_SIZE = "read.batch.size";
  public static final String WRITE_BATCH_SIZE = "write.batch.size";
  private final Marker aMarker;


  public LlmJsonParserAction(final ActionExecutionAudit action, final Logger log,
                             final Object llmJsonParser) {
    this.llmJsonParser = (LlmJsonParser) llmJsonParser;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" LlmJsonParser:" + this.llmJsonParser.getName());

  }

  @Override
  public void execute() {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(llmJsonParser.getResourceConn());
      jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
      log.info(aMarker, "Llm json parser action {} has been started ", llmJsonParser.getName());

      final String insertQuery = "INSERT INTO " + llmJsonParser.getOutputTable() +
              "(created_on,created_user_id, last_updated_on, last_updated_user_id,sor_container_name,sor_item_name, answer, paper_no, " +
              "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
              "extracted_image_unit, image_dpi, image_height, image_width) "
              + " VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?  ,?,?,?,?)";
      log.info(aMarker, "Llm json parser insert query {}", insertQuery);

      final String selectQuery = llmJsonParser.getQuerySet();
      List<LlmJsonQueryInputTable> inputTableList = jdbi.withHandle(handle -> handle.createQuery(selectQuery)
              .mapToBean(LlmJsonQueryInputTable.class)
              .list());



      ObjectMapper objectMapper = new ObjectMapper();

      jdbi.useTransaction(handle -> {
        for (LlmJsonQueryInputTable inputTable : inputTableList) {
          String jsonResponse = inputTable.getResponse();
          String safeJsonResponse = (jsonResponse == null || jsonResponse.isEmpty()) ? "{}" : jsonResponse;
          JsonNode rootNode = objectMapper.readTree(safeJsonResponse);
          List<LlmJsonParsedResponse> innerParsedResponses = new ArrayList<>();

          if (Objects.equals(inputTable.getProcess(), "KVP_ATTRIBUTION")) {
                log.info("\n KVP parsing started {}:\n", inputTable.getProcess());
          parseJsonNode(rootNode, "", "", innerParsedResponses);
          for (LlmJsonParsedResponse parsedResponse : innerParsedResponses) {
            handle.createUpdate(insertQuery)
                    .bind(0, inputTable.getCreatedOn())
                    .bind(1, inputTable.getTenantId())
                    .bind(2, CreateTimeStamp.currentTimestamp())
                    .bind(3, inputTable.getTenantId())
                    .bind(4, parsedResponse.getSorContainerName())
                    .bind(5, parsedResponse.getSorItemName())
                    .bind(6, parsedResponse.getAnswer())
                    .bind(7, inputTable.getPaperNo())
                    .bind(8, inputTable.getOriginId())
                    .bind(9, inputTable.getGroupId())
                    .bind(10, inputTable.getTenantId())
                    .bind(11, inputTable.getRootPipelineId())
                    .bind(12, inputTable.getBatchId())
                    .bind(13, inputTable.getModelRegistry())
                    .bind(14, inputTable.getExtractedImageUnit())
                    .bind(15, inputTable.getImageDpi())
                    .bind(16, inputTable.getImageHeight())
                    .bind(17, inputTable.getImageWidth())
                    .execute();
              log.info("\n insert processing for process {} :\n", inputTable.getProcess());

            }
          }else if(Objects.equals(inputTable.getProcess(), "TEXT_EXTRACTION")) {

              try {

                  final String insertQueryText = "INSERT INTO " + llmJsonParser.getOutputTable() +
                          "(created_on,created_user_id, last_updated_on, last_updated_user_id, response, paper_no, " +
                          "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
                          "image_dpi, image_height, image_width) "
                          + " VALUES(?,?,?,?,?::jsonb,?,?,?,?,?,?,?,?,?,?)";
                  log.info("\n text parsing started for {}:\n", inputTable.getProcess());
                  ObjectMapper textParser = new ObjectMapper();
                  String finalResult = "";


                  ObjectNode resultWrapper = null;
                  if (!Objects.equals(jsonResponse, "null") && jsonResponse != null && !jsonResponse.isEmpty()) {
                      TextParser lineParser = textParser.readValue(jsonResponse, TextParser.class);
                      List<ContentNode> aggregatedResult = new ArrayList<>(); // creating list of content object


                      List<TextLineItems> lines = lineParser.getLines();
                      lines.sort(Comparator.comparing(TextLineItems::getLineNumber)); // comparator is used to order it with getLineNumber value
                      lineParser.getLines().forEach(item -> {
                          // Create an ObjectNode for the bounding box
                          Bbox bBox = new Bbox();
                          bBox.setX(0); bBox.setY(0); bBox.setWidth(0); bBox.setHeight(0);

                          ContentNode contentNode = new ContentNode();
                          contentNode.setContent(item.getContent());
                          contentNode.setConfidence(0.0F);
                          contentNode.setBBox(bBox);
                          // Add the contentNode to the aggregatedResult list
                          aggregatedResult.add(contentNode);
                      });
                      resultWrapper = objectMapper.createObjectNode();
                      ArrayNode arrayNode = objectMapper.valueToTree(aggregatedResult);

                      finalResult = resultWrapper.set("textLine", arrayNode).toString();
                  } else {
                      log.info("input is NULL for {}", inputTable.getProcess());
                      finalResult = "{}"; // Set an empty array to "textLine"
                  }


                  handle.createUpdate(insertQueryText)
                          .bind(0, inputTable.getCreatedOn())           // created_on
                          .bind(1, inputTable.getTenantId())       // created_user_id
                          .bind(2, inputTable.getCreatedOn())       // last_updated_on
                          .bind(3, inputTable.getTenantId())   // last_updated_user_id
                          .bind(4, finalResult)             // content
                          .bind(5, inputTable.getPaperNo())             // paper_no
                          .bind(6, inputTable.getOriginId())            // origin_id
                          .bind(7, inputTable.getGroupId())             // group_id
                          .bind(8, inputTable.getTenantId())            // tenant_id
                          .bind(9, inputTable.getRootPipelineId())     // root_pipeline_id
                          .bind(10, inputTable.getBatchId())            // batch_id
                          .bind(11, inputTable.getModelRegistry())      // model_registry
                          .bind(12, inputTable.getImageDpi())           // image_dpi
                          .bind(13, inputTable.getImageHeight())        // image_height
                          .bind(14, inputTable.getImageWidth())         // image_width
                          .execute();
                  log.info("\n insert processing for {}:\n", inputTable.getProcess());

              }catch (Exception e) {
                  log.error("Error in processing the {}", inputTable.getProcess(), e);
                  HandymanException handymanException = new HandymanException(e);
                  HandymanException.insertException("Error in processing the ", handymanException, action);

              }

          }else if(Objects.equals(inputTable.getProcess(), "KVP_EXTRACTION")) {
              try{
                    final String insertQueryText = "INSERT INTO " + llmJsonParser.getOutputTable() +
                          "(created_on,created_user_id, last_updated_on, last_updated_user_id, kvp_results, paper_no, " +
                          "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
                          "image_dpi, image_height, image_width) "
                          + " VALUES(?,?,?,?,?::jsonb,?,?,?,?,?,?,?,?,?,?)";
                      log.info("\n kvp parsing started for {}:\n", inputTable.getProcess());
                      String finalResult = "";

                      if (!Objects.equals(jsonResponse, "null") && jsonResponse != null && !jsonResponse.isEmpty()) {
                          SORParser parser = new SORParser(action);
                          parser.parseJSON(jsonResponse);

                          List<KVPContentNode> aggregatedResult = new ArrayList<>();

                          parser.getSorItems().forEach((sorItem, value) -> {
                              Bbox bBox = new Bbox();
                              bBox.setX(0); bBox.setY(0); bBox.setWidth(0); bBox.setHeight(0);

                              // Create an ObjectNode for the content
                              KVPContentNode kvpContentNode = new KVPContentNode();
                              kvpContentNode.setKey(sorItem);
                              kvpContentNode.setValue(value);
                              kvpContentNode.setConfidence(0.0F);
                              kvpContentNode.setBBox(bBox);

                              // Add the contentNode to the aggregatedResult list
                              aggregatedResult.add(kvpContentNode);
                          });

                          ObjectNode formElementsMapper = objectMapper.createObjectNode();
                          ObjectNode form = objectMapper.createObjectNode();

                          ArrayNode arrayNode = objectMapper.valueToTree(aggregatedResult);

                          formElementsMapper.set("formElements", arrayNode);
                          form.set("form", formElementsMapper);
                          finalResult = form.toString();
                    } else {

                      log.info("input is NULL for {}", inputTable.getProcess());
                      finalResult = "{}"; // Set an empty array to "textLine"
                    }


                  handle.createUpdate(insertQueryText)
                          .bind(0, inputTable.getCreatedOn())           // created_on
                          .bind(1, inputTable.getTenantId())       // created_user_id
                          .bind(2, inputTable.getCreatedOn())       // last_updated_on
                          .bind(3, inputTable.getTenantId())   // last_updated_user_id
                          .bind(4, finalResult)          // value
                          .bind(5, inputTable.getPaperNo())             // paper_no
                          .bind(6, inputTable.getOriginId())            // origin_id
                          .bind(7, inputTable.getGroupId())             // group_id
                          .bind(8, inputTable.getTenantId())            // tenant_id
                          .bind(9, inputTable.getRootPipelineId())     // root_pipeline_id
                          .bind(10, inputTable.getBatchId())            // batch_id
                          .bind(11, inputTable.getModelRegistry())      // model_registry
                          .bind(12, inputTable.getImageDpi())           // image_dpi
                          .bind(13, inputTable.getImageHeight())        // image_height
                          .bind(14, inputTable.getImageWidth())         // image_width
                          .execute();

              log.info("\n insert processing for {}:\n", inputTable.getProcess());

              } catch (Exception e) {
                  log.error("Error in processing the {}", inputTable.getProcess(), e);
                  HandymanException handymanException = new HandymanException(e);
                  HandymanException.insertException("Error in processing the ", handymanException, action);

              }

          }else if(Objects.equals(inputTable.getProcess(), "TABLE_EXTRACTION")) {

              try{
                  final String insertQueryText = "INSERT INTO " + llmJsonParser.getOutputTable() +
                          "(created_on,created_user_id, last_updated_on, last_updated_user_id, table_response, paper_no, " +
                          "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
                          "image_dpi, image_height, image_width) "
                          + " VALUES(?,?,?,?,?::jsonb,?,?,?,?,?,?,?,?,?,?)";

                  log.info("\n Table parsing started for {}:\n", inputTable.getProcess());

                  JsonNode tables = TableParser.parseTables(safeJsonResponse);


                  handle.createUpdate(insertQueryText)
                          .bind(0, inputTable.getCreatedOn())       // created_on
                          .bind(1, inputTable.getTenantId())        // created_user_id
                          .bind(2, inputTable.getCreatedOn())       // last_updated_on
                          .bind(3, inputTable.getTenantId())        // last_updated_user_id
                          .bind(4, tables.toString())                          // response
                          .bind(5, inputTable.getPaperNo())             // paper_no
                          .bind(6, inputTable.getOriginId())            // origin_id
                          .bind(7, inputTable.getGroupId())             // group_id
                          .bind(8, inputTable.getTenantId())            // tenant_id
                          .bind(9, inputTable.getRootPipelineId())     // root_pipeline_id
                          .bind(10, inputTable.getBatchId())            // batch_id
                          .bind(11, inputTable.getModelRegistry())      // model_registry
                          .bind(12, inputTable.getImageDpi())           // image_dpi
                          .bind(13, inputTable.getImageHeight())        // image_height
                          .bind(14, inputTable.getImageWidth())         // image_width
                          .execute();

                  log.info("\n insert processing for {}:\n", inputTable.getProcess());

              }catch (Exception e) {
                      log.error("Error in processing the {}", inputTable.getProcess(), e);
                      HandymanException handymanException = new HandymanException(e);
                      HandymanException.insertException("Error in processing the ", handymanException, action);

              }
          }
          else if(Objects.equals(inputTable.getProcess(), "CHECKBOX_EXTRACTION")) {

              try{
                  String finalResult = "";
                  final String insertQueryText = "INSERT INTO " + llmJsonParser.getOutputTable() +
                          "(created_on,created_user_id, last_updated_on, last_updated_user_id, response, paper_no, " +
                          "origin_id, group_id, tenant_id, root_pipeline_id, batch_id, model_registry," +
                          "image_dpi, image_height, image_width) "
                          + " VALUES(?,?,?,?,?::jsonb,?,?,?,?,?,?,?,?,?,?)";

                  log.info("\n Checkbox parsing started for {}:\n", inputTable.getProcess());

                  try {
                      if (!Objects.equals(jsonResponse, "null") && jsonResponse != null && !jsonResponse.isEmpty()) {

                          if (!Objects.equals(jsonResponse, "[]")) {

                              if (jsonResponse.trim().startsWith("{")) {
                                  try {
                                      // Try parsing it as a JSONObject
                                      JsonNode jsonObject = objectMapper.readTree(jsonResponse);
                                      log.info("It is a json object");
                                      finalResult = processJson(jsonObject);

                                  } catch (Exception e) {
                                      log.error("Error in processing the {}", inputTable.getProcess(), e);
                                      HandymanException handymanException = new HandymanException(e);
                                      HandymanException.insertException("Error in processing the ", handymanException, action);
                                  }
                              } else if (jsonResponse.trim().startsWith("[")) {
                                  try {
                                      // Try parsing it as a JSONArray
                                      ArrayNode jsonArray = (ArrayNode) objectMapper.readTree(jsonResponse);
                                      log.info("It is a json array");
                                      finalResult = processJson(jsonArray);

                                  } catch (Exception e) {
                                      log.error("Error in processing the {}", inputTable.getProcess(), e);
                                      HandymanException handymanException = new HandymanException(e);
                                      HandymanException.insertException("Error in processing the ", handymanException, action);
                                  }
                              } else {
                                  log.info("input is NULL for {}", inputTable.getProcess());
                                  finalResult = "{}";
                              }

                          } else {
                              log.info("input is NULL for {}", inputTable.getProcess());
                              finalResult = "{}";

                          }
                          // Create the output JSON structure
                      } else {
                          log.info("input is NULL for {}", inputTable.getProcess());
                          finalResult = "{}";
                      }

                  } catch (Exception e) {
                          log.error("Error in processing the {}", inputTable.getProcess(), e);
                          HandymanException handymanException = new HandymanException(e);
                          HandymanException.insertException("Error in processing the ", handymanException, action);

                  }


                 handle.createUpdate(insertQueryText)
                      .bind(0, inputTable.getCreatedOn())       // created_on
                      .bind(1, inputTable.getTenantId())        // created_user_id
                      .bind(2, inputTable.getCreatedOn())       // last_updated_on
                      .bind(3, inputTable.getTenantId())        // last_updated_user_id
                      .bind(4, finalResult)                          // response
                      .bind(5, inputTable.getPaperNo())             // paper_no
                      .bind(6, inputTable.getOriginId())            // origin_id
                      .bind(7, inputTable.getGroupId())             // group_id
                      .bind(8, inputTable.getTenantId())            // tenant_id
                      .bind(9, inputTable.getRootPipelineId())     // root_pipeline_id
                      .bind(10, inputTable.getBatchId())            // batch_id
                      .bind(11, inputTable.getModelRegistry())      // model_registry
                      .bind(12, inputTable.getImageDpi())           // image_dpi
                      .bind(13, inputTable.getImageHeight())        // image_height
                      .bind(14, inputTable.getImageWidth())         // image_width
                      .execute();

                  log.info("\n insert processing for {}:\n", inputTable.getProcess());

              }catch (Exception e) {
                  log.error("Error in processing the {}", inputTable.getProcess(), e);
                  HandymanException handymanException = new HandymanException(e);
                  HandymanException.insertException("Error in processing the ", handymanException, action);

              }

          }

        }
      });


      log.info(aMarker, " Llm json parser action has been completed {}  ", llmJsonParser.getName());
    } catch (Exception e) {
      action.getContext().put(llmJsonParser.getName() + ".isSuccessful", "false");
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("error in execute method for Llm json parser action", handymanException, action);

    }
  }


      private void parseJsonNode(JsonNode rootNode, String currentKey, String parentPath, List<LlmJsonParsedResponse> parsedResponses) {
    if (rootNode.isObject()) {
      Iterator<Map.Entry<String, JsonNode>> fields = rootNode.fields();
      while (fields.hasNext()) {
        Map.Entry<String, JsonNode> field = fields.next();
        String key = field.getKey();
        String newCurrentKey = key;
        String newParentPath = parentPath.isEmpty() ? currentKey : parentPath + ", " + currentKey;
        parseJsonNode(field.getValue(), newCurrentKey, newParentPath, parsedResponses);
      }
    } else if (rootNode.isArray()) {
      for (JsonNode arrayElement : rootNode) {
        parseJsonNode(arrayElement, currentKey, parentPath, parsedResponses);
      }
    } else {
      LlmJsonParsedResponse parsedResponse = LlmJsonParsedResponse.builder()
              .sorContainerName(parentPath)
              .sorItemName(currentKey)
              .answer(rootNode.asText())
              .build();
      parsedResponses.add(parsedResponse);
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return llmJsonParser.getCondition();
  }
}
