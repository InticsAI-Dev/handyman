package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.Option;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.KafkaOutboundComparison;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.mapper.ColumnMapper;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.StatementContext;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "KafkaOutboundComparison"
)
public class KafkaOutboundComparisonAction implements IActionExecution {
  private final ActionExecutionAudit action;
  private final Logger log;
  private final KafkaOutboundComparison kafkaOutboundComparison;
  private final Marker aMarker;
  private final Configuration jsonPathConfig = Configuration.defaultConfiguration()
          .addOptions(Option.SUPPRESS_EXCEPTIONS, Option.DEFAULT_PATH_LEAF_TO_NULL);

  public KafkaOutboundComparisonAction(final ActionExecutionAudit action, final Logger log,
                                       final Object kafkaOutboundComparison) {
    this.kafkaOutboundComparison = (KafkaOutboundComparison) kafkaOutboundComparison;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker("KafkaOutboundComparison:" + this.kafkaOutboundComparison.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(kafkaOutboundComparison.getResourceConn());
      jdbi.registerColumnMapper(new JsonNodeColumnMapper());
      InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action);
      String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
      boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);
      String batchId = kafkaOutboundComparison.getBatchId();
      String outputTableName = kafkaOutboundComparison.getOutputTable();

      if (outputTableName == null || outputTableName.trim().isEmpty()) {
        log.error(aMarker, "Output table name is empty or null");
        throw new HandymanException("Output table name is required");
      }

      Map<Long, FieldConfig> fieldConfigs = fetchFieldConfigs(jdbi);
      log.info(aMarker, "Fetched {} field configurations: {}", fieldConfigs.size(), fieldConfigs.values());

      if (fieldConfigs.isEmpty()) {
        log.error(aMarker, "No field configurations found in sor_meta.field_wise_outbound_config");
        throw new HandymanException("No field configurations found");
      }

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(kafkaOutboundComparison.getQuerySet());
        AtomicInteger queryIndex = new AtomicInteger(0);
        for (String sqlToExecute : formattedQuery) {
          log.info(aMarker, "Executing query {} from index {}: {}", sqlToExecute, queryIndex.getAndIncrement(), sqlToExecute);
          Query query = handle.createQuery(sqlToExecute);
          query.execute((rs, ctx) -> {
            java.sql.ResultSetMetaData metaData = rs.get().getMetaData();
            int columnCount = metaData.getColumnCount();
            for (int i = 1; i <= columnCount; i++) {
              log.info(aMarker, "Column {}: {}", i, metaData.getColumnName(i));
            }
            return null;
          });
          List<KafkaOutboundComparisonInput> inputs = query.mapToBean(KafkaOutboundComparisonInput.class)
                  .stream()
                  .collect(Collectors.toList());
          log.info(aMarker, "Executed query from index {}, fetched {} records", queryIndex.get(), inputs.size());

          if (inputs.isEmpty()) {
            log.warn(aMarker, "No records retrieved for query at index {}. Skipping comparison.", queryIndex.get());
            return;
          }

          for (KafkaOutboundComparisonInput input : inputs) {
            try {
              log.debug(aMarker, "ProductResponse for processId {}: {}", input.getProcessId(), input.getProductResponse().toString());
              log.debug(aMarker, "CustomResponse for processId {}: {}", input.getProcessId(), input.getCustomResponse().toString());
              if (input.getProductResponse() == null || isEmptyJsonNode(input.getProductResponse())) {
                log.warn(aMarker, "ProductResponse is null or empty for processId: {}. Skipping comparison.", input.getProcessId());
                saveEmptyResult(handle, outputTableName, input, "ProductResponse is null or empty");
                continue;
              }
              if (input.getCustomResponse() == null || isEmptyJsonNode(input.getCustomResponse())) {
                log.warn(aMarker, "CustomResponse is null or empty for processId: {}. Skipping comparison.", input.getProcessId());
                saveEmptyResult(handle, outputTableName, input, "CustomResponse is null or empty");
                continue;
              }

              ComparisonResult comparisonResult = compareFieldsMapped(input, fieldConfigs, encryption, pipelineEndToEndEncryptionActivator);
              saveComparisonResult(handle, outputTableName, comparisonResult);
            } catch (Exception e) {
              log.error(aMarker, "Error processing record for processId: {}", input.getProcessId(), e);
              saveEmptyResult(handle, outputTableName, input, "Error processing record: " + e.getMessage());
            }
          }
        }
      });
    } catch (Exception e) {
      log.error(aMarker, "Error executing KafkaOutboundComparisonAction", e);
      throw new HandymanException("Execution failed", e);
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return kafkaOutboundComparison.getCondition();
  }

  private boolean isEmptyJsonNode(JsonNode node) {
    return node == null ||
            (node.isObject() && !node.fields().hasNext()) ||
            (node.isArray() && node.size() == 0);
  }

  private Map<Long, FieldConfig> fetchFieldConfigs(Jdbi jdbi) {
    String sql = "SELECT foc.sor_item_id, foc.sor_item_name, foc.json_path, foc.json_property, " +
            "si.encryption_policy_id, si.is_encrypted " +
            "FROM sor_meta.field_wise_outbound_config foc " +
            "JOIN sor_meta.sor_item si ON foc.sor_item_id = si.sor_item_id";
    try {
      Map<Long, FieldConfig> fieldConfigs = jdbi.withHandle(handle -> handle.createQuery(sql)
              .mapToBean(FieldConfig.class)
              .stream()
              .collect(Collectors.toMap(FieldConfig::getSorItemId, config -> config)));
      if (fieldConfigs.isEmpty()) {
        log.warn(aMarker, "No field configurations found in sor_meta.field_wise_outbound_config");
      } else {
        log.info(aMarker, "Field configurations loaded: {}", fieldConfigs.values());
      }
      return fieldConfigs;
    } catch (Exception e) {
      log.error(aMarker, "Failed to fetch field configurations", e);
      return new HashMap<>();
    }
  }


  private ComparisonResult compareFieldsMapped(KafkaOutboundComparisonInput input, Map<Long, FieldConfig> fieldConfigs,
                                               InticsIntegrity encryption, boolean pipelineEndToEndEncryptionActivator) {
    ComparisonResult result = new ComparisonResult();
    result.setProcessId(input.getProcessId());
    result.setGroupId(input.getGroupId());
    result.setBatchId(input.getBatchId());
    result.setInboundTransactionId(input.getInboundTransactionId());

    List<ComparisonDetail> details = new ArrayList<>();
    for (FieldConfig config : fieldConfigs.values()) {
      try {
        String jsonPath = config.getJsonPath();
        String sorItemName = config.getSorItemName();
        boolean isEncrypted = "t".equalsIgnoreCase(config.getIsEncrypted());
        String encryptionPolicy = config.getEncryptionPolicy();
        Long sorItemId = config.getSorItemId();

        String productValue = extractValueFromJson(input.getProductResponse(), jsonPath, sorItemName);
        String customValue = extractValueFromJson(input.getCustomResponse(), jsonPath, sorItemName);

        if (productValue == null) {
          log.warn(aMarker, "No product value found for jsonPath: {} (sorItem: {})", jsonPath, sorItemName);
        }
        if (customValue == null) {
          log.warn(aMarker, "No custom value found for jsonPath: {} (sorItem: {})", jsonPath, sorItemName);
        }

        if (pipelineEndToEndEncryptionActivator && isEncrypted && encryptionPolicy != null) {
          if (productValue != null) {
            log.info(aMarker, "Decrypting productValue for sorItem {}: {}", sorItemName, productValue);
            productValue = encryption.decrypt(productValue, encryptionPolicy, sorItemName);
            log.info(aMarker, "Decrypted productValue for sorItem {}: {}", sorItemName, productValue);
          }
          if (customValue != null) {
            log.info(aMarker, "Decrypting customValue for sorItem {}: {}", sorItemName, customValue);
            customValue = encryption.decrypt(customValue, encryptionPolicy, sorItemName);
            log.info(aMarker, "Decrypted customValue for sorItem {}: {}", sorItemName, customValue);
          }
        }

        Long mismatchCount = (productValue == null && customValue == null) ||
                (productValue != null && productValue.equals(customValue)) ? 0L : 1L;
        String matchStatus = calculateValidationScores(mismatchCount);

        if (pipelineEndToEndEncryptionActivator && isEncrypted && encryptionPolicy != null) {
          if (productValue != null) {
            log.info(aMarker, "Encrypting productValue for sorItem {}: {}", sorItemName, productValue);
            productValue = encryption.encrypt(productValue, encryptionPolicy, sorItemName);
            log.info(aMarker, "Encrypted productValue for sorItem {}: {}", sorItemName, productValue);
          }
          if (customValue != null) {
            log.info(aMarker, "Encrypting customValue for sorItem {}: {}", sorItemName, customValue);
            customValue = encryption.encrypt(customValue, encryptionPolicy, sorItemName);
            log.info(aMarker, "Encrypted customValue for sorItem {}: {}", sorItemName, customValue);
          }
        }

        ComparisonDetail detail = ComparisonDetail.builder()
                .fieldName(sorItemName)
                .productValue(productValue)
                .customValue(customValue)
                .matches(mismatchCount == 0)
                .sorItemId(sorItemId)
                .sorItemName(sorItemName)
                .matchStatus(matchStatus)
                .mismatchCount(mismatchCount)
                .mapped(true)
                .build();
        details.add(detail);
      } catch (Exception e) {
        log.error(aMarker, "Error processing field {} for processId: {}", config.getSorItemName(), input.getProcessId(), e);
        ComparisonDetail detail = ComparisonDetail.builder()
                .fieldName(config.getSorItemName())
                .productValue(null)
                .customValue(null)
                .matches(false)
                .sorItemId(config.getSorItemId())
                .sorItemName(config.getSorItemName())
                .matchStatus("ERROR")
                .mismatchCount(-1L)
                .mapped(true)
                .build();
        details.add(detail);
      }
    }

    result.setDetails(details);
    result.setAllMatch(details.stream().allMatch(ComparisonDetail::isMatches));
    return result;
  }

  private String extractValueFromJson(JsonNode node, String jsonPath, String sorItemName) {
    try {
      log.debug(aMarker, "Extracting value for jsonPath: {} (sorItem: {})", jsonPath, sorItemName);

      // Try the provided jsonPath
      Object result = JsonPath.using(jsonPathConfig).parse(node.toString()).read(jsonPath);
      String value = parseJsonPathResult(result, jsonPath, sorItemName);
      if (value != null) {
        log.debug(aMarker, "Extracted value for jsonPath {}: {}", jsonPath, value);
        return value;
      }

      // Fallback: Try appending .value if the path doesn't already end with it
      if (!jsonPath.endsWith(".value")) {
        String fallbackPath = jsonPath + ".value";
        log.debug(aMarker, "Trying fallback jsonPath: {} (sorItem: {})", fallbackPath, sorItemName);
        result = JsonPath.using(jsonPathConfig).parse(node.toString()).read(fallbackPath);
        value = parseJsonPathResult(result, fallbackPath, sorItemName);
        if (value != null) {
          log.debug(aMarker, "Extracted fallback value for jsonPath {}: {}", fallbackPath, value);
          return value;
        }
      }

      log.debug(aMarker, "No value found for jsonPath: {} (sorItem: {})", jsonPath, sorItemName);
      return null;
    } catch (Exception e) {
      log.warn(aMarker, "Error extracting value for jsonPath: {} (sorItem: {})", jsonPath, sorItemName, e);
      return null;
    }
  }

  private String parseJsonPathResult(Object result, String jsonPath, String sorItemName) {
    if (result instanceof List) {
      List<?> resultList = (List<?>) result;
      List<String> values = new ArrayList<>();
      for (Object item : resultList) {
        if (item instanceof String) {
          values.add((String) item);
        } else if (item instanceof Map) {
          Map<?, ?> resultMap = (Map<?, ?>) item;
          if (resultMap.containsKey("value")) {
            Object value = resultMap.get("value");
            if (value != null) {
              values.add(value.toString());
            }
          }
        }
      }
      if (!values.isEmpty()) {
        String joinedValue = String.join(",", values);
        log.debug(aMarker, "Joined array values for jsonPath {}: {}", jsonPath, joinedValue);
        return joinedValue;
      }
    } else if (result instanceof String) {
      return (String) result;
    } else if (result instanceof Map) {
      Map<?, ?> resultMap = (Map<?, ?>) result;
      if (resultMap.containsKey("value")) {
        Object value = resultMap.get("value");
        if (value != null) {
          return value.toString();
        }
      }
    }
    return null;
  }

  private String calculateValidationScores(Long mismatchCount) {
    String lowTouch = action.getContext().get("control.data.low.touch.threshold");
    String oneTouch = action.getContext().get("control.data.one.touch.threshold");
    if (mismatchCount == null || mismatchCount == 0) {
      return "NO TOUCH";
    } else if (mismatchCount <= Long.parseLong(oneTouch)) {
      return "ONE TOUCH";
    } else if (mismatchCount <= Long.parseLong(lowTouch)) {
      return "LOW TOUCH";
    } else {
      return "HIGH TOUCH";
    }
  }

  private void saveComparisonResult(org.jdbi.v3.core.Handle handle, String outputTableName, ComparisonResult result) {
    if (outputTableName == null || outputTableName.trim().isEmpty()) {
      log.error(aMarker, "Output table name is empty or null, cannot save comparison result");
      throw new HandymanException("Output table name is required for saving comparison result");
    }

    String insertSummarySql = "INSERT INTO " + outputTableName + " (process_id, group_id, batch_id, inbound_transaction_id, all_match) " +
            "VALUES (:processId, :groupId, :batchId, :inboundTransactionId, :allMatch)";
    handle.createUpdate(insertSummarySql)
            .bind("processId", result.getProcessId())
            .bind("groupId", result.getGroupId())
            .bind("batchId", result.getBatchId())
            .bind("inboundTransactionId", result.getInboundTransactionId())
            .bind("allMatch", result.isAllMatch())
            .execute();

    String insertDetailSql = "INSERT INTO " + outputTableName + "_details (process_id, field_name, product_value, custom_value, matches, sor_item_id, sor_item_name, match_status, mismatch_count, mapped) " +
            "VALUES (:processId, :fieldName, :productValue, :customValue, :matches, :sorItemId, :sorItemName, :matchStatus, :mismatchCount, :mapped)";
    for (ComparisonDetail detail : result.getDetails()) {
      handle.createUpdate(insertDetailSql)
              .bind("processId", result.getProcessId())
              .bind("fieldName", detail.getFieldName())
              .bind("productValue", detail.getProductValue())
              .bind("customValue", detail.getCustomValue())
              .bind("matches", detail.isMatches())
              .bind("sorItemId", detail.getSorItemId())
              .bind("sorItemName", detail.getSorItemName())
              .bind("matchStatus", detail.getMatchStatus())
              .bind("mismatchCount", detail.getMismatchCount())
              .bind("mapped", detail.isMapped())
              .execute();
    }
  }

  private void saveEmptyResult(org.jdbi.v3.core.Handle handle, String outputTableName,
                               KafkaOutboundComparisonInput input, String errorMessage) {
    if (outputTableName == null || outputTableName.trim().isEmpty()) {
      log.error(aMarker, "Output table name is empty or null, cannot save empty result");
      throw new HandymanException("Output table name is required for saving empty result");
    }

    String insertSummarySql = "INSERT INTO " + outputTableName + " (process_id, group_id, batch_id, inbound_transaction_id, all_match, error_message) " +
            "VALUES (:processId, :groupId, :batchId, :inboundTransactionId, :allMatch, :errorMessage)";
    handle.createUpdate(insertSummarySql)
            .bind("processId", input.getProcessId())
            .bind("groupId", input.getGroupId())
            .bind("batchId", input.getBatchId())
            .bind("inboundTransactionId", input.getInboundTransactionId())
            .bind("allMatch", false)
            .bind("errorMessage", errorMessage)
            .execute();
  }

  @Data
  @Builder
  @NoArgsConstructor
  @AllArgsConstructor
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class ComparisonResult {
    private Integer processId;
    private Long groupId;
    private String batchId;
    private String inboundTransactionId;
    private boolean allMatch;
    private List<ComparisonDetail> details;
  }

  @Data
  @Builder
  @NoArgsConstructor
  @AllArgsConstructor
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class ComparisonDetail {
    private String fieldName;
    private String productValue;
    private String customValue;
    private boolean matches;
    private Long sorItemId;
    private String sorItemName;
    private String matchStatus;
    private Long mismatchCount;
    private boolean mapped;
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class KafkaOutboundComparisonInput {
    private Integer processId;
    private Long groupId;
    private JsonNode productResponse;
    private JsonNode customResponse;
    private String originId;
    private Long tenantId;
    private Long rootPipelineId;
    private String status;
    private String stage;
    private String message;
    private String triggeredUrl;
    private String feature;
    private String batchId;
    private String inboundTransactionId;
  }

  @Data
  @Builder
  @NoArgsConstructor
  @AllArgsConstructor
  public static class FieldConfig {
    private Long sorItemId;
    private String sorItemName;
    private String jsonPath;
    private String jsonProperty;
    private String encryptionPolicy;
    private String isEncrypted;
  }

  public static class JsonNodeColumnMapper implements ColumnMapper<JsonNode> {
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public JsonNode map(ResultSet rs, int columnNumber, StatementContext ctx) throws SQLException {
      String json = rs.getString(columnNumber);
      try {
        return json != null ? objectMapper.readTree(json) : null;
      } catch (Exception e) {
        throw new SQLException("Failed to parse JSON for column " + columnNumber, e);
      }
    }
  }
}