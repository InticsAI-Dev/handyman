package in.handyman.raven.lib;

import in.handyman.raven.core.config.ConfigurationService;
import in.handyman.raven.core.context.ActionContext;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.LambdaAutowire;
import in.handyman.raven.lambda.LambdaExecution;
import in.handyman.raven.lib.model.CopyData;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.MarkerManager;

import java.util.Optional;

/**
 * Auto Generated By Raven
 */
@LambdaAutowire(
        lambdaName = "CopyData"
)
@Log4j2
public class CopyDataAction implements LambdaExecution {
    private final ActionContext actionContext;

    private final CopyData context;

    private final MarkerManager.Log4jMarker aMarker;

    public CopyDataAction(final ActionContext actionContext, final Object context) {
        this.context = (CopyData) context;
        this.actionContext = actionContext;
        this.aMarker = new MarkerManager.Log4jMarker("CopyData");
        this.actionContext.getDetailMap().putPOJO("context", context);
    }

    @Override
    public void execute() throws Exception {
        //Retrieving the global config map for default value
        var configMap = ConfigurationService.getGlobalConfig();
        var instanceId = actionContext.getProcessId();
        var name = actionContext.getName();
        var source = Optional.ofNullable(context.getSource()).map(String::trim)
                .filter(s -> !s.isEmpty() && !s.isBlank())
                .orElseThrow(() -> new HandymanException("source data source cannot be empty for copyData for " + name));
        var target = Optional.ofNullable(context.getTo()).map(String::trim)
                .filter(s -> !s.isEmpty() && !s.isBlank())
                .orElseThrow(() -> new HandymanException("target data source cannot be empty for copyData for " + name));
        var fetchSize = Optional.ofNullable(context.getFetchBatchSize())
                .map(String::trim)
                .map(Integer::valueOf)
                .filter(integer -> integer > 0)
                .orElseGet(() -> Integer.valueOf(configMap.getOrDefault(Constants.READ_SIZE, Constants.DEFAULT_READ_SIZE).trim()));
        var writeSize = Optional.ofNullable(context.getWriteBatchSize())
                .map(String::trim)
                .map(Integer::valueOf)
                .filter(integer -> integer > 0)
                .orElseGet(() -> Integer.valueOf(configMap.getOrDefault(Constants.WRITE_SIZE, Constants.DEFAULT_WRITE_SIZE).trim()));
        var upperThreadCount = Optional.ofNullable(context.getWriteThreadCount())
                .map(String::trim)
                .map(Integer::valueOf)
                .filter(integer -> integer > 0)
                .orElseGet(() -> Integer.valueOf(configMap.getOrDefault(Constants.WRITER_THREAD, Constants.DEFAULT_WRITER_COUNT).trim()));
        var lowerThreadCount = 1;
        //retrieving the insert into sql statement
        var insertStatement = Optional.ofNullable(context.getValue()).map(String::trim)
                .map(s -> s.replaceAll("\"", ""))
                .filter(s -> !s.isEmpty() && !s.isBlank())
                .orElseThrow(() -> new HandymanException("INSERT INTO SELECT .... cannot be empty for copyData for " + name));
//
//        val insert = CCJSqlParserUtil.parse(insertStatement).asInstanceOf[Insert]
//        val select = insert.getSelect
//
//        val targetTable = insert.getTable

    }

    @Override
    public boolean executeIf() throws Exception {
        return false;
    }
}
