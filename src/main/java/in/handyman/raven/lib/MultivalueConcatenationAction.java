package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.MultivalueConcatenation;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "MultivalueConcatenation"
)
public class MultivalueConcatenationAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final MultivalueConcatenation multivalueConcatenation;

  private final Marker aMarker;

  public MultivalueConcatenationAction(final ActionExecutionAudit action, final Logger log,
                                       final Object multivalueConcatenation) {
    this.multivalueConcatenation = (MultivalueConcatenation) multivalueConcatenation;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" MultivalueConcatenation:" + this.multivalueConcatenation.getName());
  }

  private List<MultivalueConcatenationInput> multivalueConcatenationInputs = new ArrayList<>();

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(multivalueConcatenation.getResourceConn());
      InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action);

      String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
      boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

      Long groupId = Long.valueOf(multivalueConcatenation.getGroupId());
      String batchId = multivalueConcatenation.getBatchId();

      String outputTableName = multivalueConcatenation.getOutputTable();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(multivalueConcatenation.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        for (String sqlToExecute : formattedQuery) {
          log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<MultivalueConcatenationInput> resultIterable = query.mapToBean(MultivalueConcatenationInput.class);
          List<MultivalueConcatenationInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
          multivalueConcatenationInputs.addAll(processingExecutorInputs);
          log.info(aMarker, "executed query from index {}", i.get());
        }
      });

      log.info("Multi value concatenation action total rows returned from the query {}", multivalueConcatenationInputs.size());

      multivalueConcatenationInputs.forEach(controlDataComparisonQueryInput -> {
        try {
          doMultiValueConcatenation(controlDataComparisonQueryInput, jdbi, outputTableName, pipelineEndToEndEncryptionActivator);
        } catch (JsonProcessingException e) {
          HandymanException handymanException = new HandymanException(e);
          HandymanException.insertException("Control data comparison Input table failed :", handymanException, action);
        }
      });

      log.info(aMarker, "Multi value concatenation Action has been completed {}  ", multivalueConcatenation.getName());

    } catch (Exception e) {
      action.getContext().put(multivalueConcatenation.getName() + ".isSuccessful", "false");
      log.error(aMarker, "Error in execute method for Multi value concatenation ", e);
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("Multi value concatenation failed ", handymanException, action);
    }

  }

  private void doMultiValueConcatenation(MultivalueConcatenationInput multivalueConcatenationInput, Jdbi jdbi, String outputTable, Boolean pipelineEndToEndEncryptionActivator) throws JsonProcessingException {
    String originId = multivalueConcatenationInput.getOriginId();
    String predictedValue = multivalueConcatenationInput.getPredictedValue();

    String batchId = multivalueConcatenationInput.getBatchId();
    Integer groupId = multivalueConcatenationInput.getGroupId();
    Integer paperNo = multivalueConcatenationInput.getPaperNo();

    Long tenantId = multivalueConcatenationInput.getTenantId();

    List<MultivalueConcatenationInput> filteredInputs = multivalueConcatenationInputs.stream()
            .filter(input -> Objects.equals(input.getGroupId(), groupId))
            .filter(input -> Objects.equals(input.getTenantId(), tenantId))
            .filter(input -> Objects.equals(input.getBatchId(), batchId))
            .filter(input -> Objects.equals(input.getRank(), 1L))
            .collect(Collectors.toList());

    Map<String, MultivalueConcatenationInput> groupedMap = new HashMap<>();

    InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action);
    for (MultivalueConcatenationInput input : filteredInputs) {
      String key = input.getOriginId() + "|" + input.getSorItemName();

      if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(input.getIsEncrypted())) {
        predictedValue = encryption.decrypt(predictedValue, input.getEncryptionPolicy(), input.getSorItemName());
      }

      // Clean predicted value
      predictedValue = predictedValue == null ? "" :
              predictedValue.trim().replaceAll("(^,+|,+$)", "").replaceAll(",{2,}", ",");

      try {
        if (groupedMap.containsKey(key)) {
          MultivalueConcatenationInput existing = groupedMap.get(key);
          String combined = existing.getPredictedValue() + "," + predictedValue;
          combined = combined.replaceAll("(^,+|,+$)", "").replaceAll(",{2,}", ",");
          existing.setPredictedValue(combined);
        } else {
          if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(input.getIsEncrypted())) {
            predictedValue = encryption.encrypt(predictedValue, input.getEncryptionPolicy(), input.getSorItemName());
          }
        }
        insertExecutionInfo(jdbi, outputTable, input.getOriginId(), input.getSorItemName(), input.getTenantId(), input.getBatchId(), predictedValue, input.getGroupId(), input.getPaperNo(), input.getVqaScore(), input.getQuestionId(), input.getSynonymId(), input.getModelRegistry(), input.getDocumentId(), input.getBBox(), input.getRootPipelineId(), input.getAggregatedScore(), input.getMaskedScore(), input.getRank(), input.getSorItemAttributionId(), input.getFrequency());
      } catch (HandymanException e) {
        HandymanException handymanException = new HandymanException(e);
        HandymanException.insertException("Error while inserting gender type data validation origin Id " + originId + " paper No " + paperNo, handymanException, action);
      }
    }
  }

  private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, String sorItemName, Long tenantId, String batchId, String predictedValue, Integer groupId, Integer paperNo, Double vqaScore, Long questionId, Long synonymId, String modelRegistry, String documentId, String bBox, Long rootPipelineId, Long aggregatedScore, Long maskedScore, Long rank, Long sorItemAttributionId, Long frequency) {
    jdbi.useHandle(handle -> handle.createUpdate(
                    "INSERT INTO " + outputTable + " (" +
                            "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                            "aggregated_score, masked_score, origin_id, paper_no, predicted_value, rank, sor_item_attribution_id, sor_item_name, " +
                            "document_id, b_box, group_id, root_pipeline_id, vqa_score, question_id, synonym_id, model_registry, batch_id, frequency" +
                            ") VALUES (" +
                            ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                            ":aggregatedScore, :maskedScore, :originId, :paperNo, :predictedValue, :rank, :sorItemAttributionId, :sorItemName, " +
                            ":documentId, :bBox, :groupId, :rootPipelineId, :vqaScore, :questionId, :synonymId, :modelRegistry, :batchId, :frequency" +
                            ");")
            .bind("createdOn", LocalDate.now())
            .bind("createdUserId", tenantId)
            .bind("lastUpdatedOn", LocalDate.now())
            .bind("lastUpdatedUserId", tenantId)
            .bind("tenantId", tenantId)
            .bind("aggregatedScore", aggregatedScore)
            .bind("maskedScore", maskedScore)
            .bind("originId", originId)
            .bind("paperNo", paperNo)
            .bind("predictedValue", predictedValue)
            .bind("rank", rank)
            .bind("sorItemAttributionId", sorItemAttributionId)
            .bind("sorItemName", sorItemName)
            .bind("documentId", documentId)
            .bind("bBox", bBox)
            .bind("groupId", groupId)
            .bind("rootPipelineId", rootPipelineId)
            .bind("vqaScore", vqaScore)
            .bind("questionId", questionId)
            .bind("synonymId", synonymId)
            .bind("modelRegistry", modelRegistry)
            .bind("batchId", batchId)
            .bind("frequency", frequency)
            .execute());
  }


  @Override
  public boolean executeIf() throws Exception {
    return multivalueConcatenation.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class MultivalueConcatenationInput {
    private String originId;
    private String sorItemName;
    private String question;
    private Float votingOut;
    private Long tenantId;
    private String batchId;
    private String predictedValue;
    private Integer groupId;
    private Integer paperNo;
    private Double vqaScore;
    private Long questionId;
    private Long synonymId;
    private String modelRegistry;
    private Integer weight;
    private Double score;
    private String documentId;
    private String validationName;
    private String bBox;
    private Long rootPipelineId;
    private Long aggregatedScore;
    private Long maskedScore;
    private Long rank;
    private Long sorItemAttributionId;
    private Long frequency;
    private String encryptionPolicy;
    private String isEncrypted;

  }

}
