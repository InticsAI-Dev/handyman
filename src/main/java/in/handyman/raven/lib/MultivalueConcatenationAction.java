package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.MultivalueConcatenation;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import static in.handyman.raven.core.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "MultivalueConcatenation"
)
public class MultivalueConcatenationAction implements IActionExecution {
  public static final String AES_256 = "AES256";
  private final ActionExecutionAudit action;

  private final Logger log;

  private final MultivalueConcatenation multivalueConcatenation;

  private final Marker aMarker;

  public MultivalueConcatenationAction(final ActionExecutionAudit action, final Logger log,
                                       final Object multivalueConcatenation) {
    this.multivalueConcatenation = (MultivalueConcatenation) multivalueConcatenation;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" MultivalueConcatenation:" + this.multivalueConcatenation.getName());
  }

  private final List<MultivalueConcatenationInput> multivalueConcatenationInputs = new ArrayList<>();

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(multivalueConcatenation.getResourceConn());
      InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action,log);

      String pipelineEndToEndEncryptionActivatorStr = action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION);
      boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(pipelineEndToEndEncryptionActivatorStr);

      Integer groupId = Integer.valueOf(multivalueConcatenation.getGroupId());
      String batchId = multivalueConcatenation.getBatchId();

      String outputTableName = multivalueConcatenation.getOutputTable();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(multivalueConcatenation.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        for (String sqlToExecute : formattedQuery) {
          log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<MultivalueConcatenationInput> resultIterable = query.mapToBean(MultivalueConcatenationInput.class);
          List<MultivalueConcatenationInput> processingExecutorInputs = resultIterable.stream().collect(Collectors.toList());
          multivalueConcatenationInputs.addAll(processingExecutorInputs);
          log.info(aMarker, "executed query from index {}", i.get());
        }
      });

      log.info("Multi value concatenation action total rows returned from the query {}", multivalueConcatenationInputs.size());

        try {
          doMultiValueConcatenation(multivalueConcatenationInputs, jdbi, outputTableName, pipelineEndToEndEncryptionActivator, groupId, batchId, encryption);
        } catch (JsonProcessingException e) {
          HandymanException handymanException = new HandymanException(e);
          HandymanException.insertException("Control data comparison Input table failed :", handymanException, action);
        }

      log.info(aMarker, "Multi value concatenation Action has been completed {}  ", multivalueConcatenation.getName());

    } catch (Exception e) {
      action.getContext().put(multivalueConcatenation.getName() + ".isSuccessful", "false");
      log.error(aMarker, "Error in execute method for Multi value concatenation ", e);
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("Multi value concatenation failed ", handymanException, action);
    }

  }

  private void doMultiValueConcatenation(List<MultivalueConcatenationInput> multivalueConcatenationInputs,
                                         Jdbi jdbi,
                                         String outputTable,
                                         Boolean pipelineEndToEndEncryptionActivator,
                                         Integer groupId,
                                         String batchId,
                                         InticsIntegrity encryption) throws JsonProcessingException {

    log.info("Starting multi-value concatenation process for batchId: {}, groupId: {}, totalInputs: {}",
            batchId, groupId, multivalueConcatenationInputs.size());

    Map<String, List<MultivalueConcatenationInput>> groupedInputs = multivalueConcatenationInputs.stream()
            .collect(Collectors.groupingBy(input -> input.getOriginId() + "|" + input.getSorItemName()));

    for (Map.Entry<String, List<MultivalueConcatenationInput>> entry : groupedInputs.entrySet()) {
      List<MultivalueConcatenationInput> groupList = entry.getValue();
      if (groupList.isEmpty()) continue;

      Integer fallbackPageNo = groupList.stream()
              .map(MultivalueConcatenationInput::getPaperNo)
              .filter(Objects::nonNull)
              .min(Integer::compareTo)
              .orElse(null);

      Integer selectedPageNoFromValue = null;

      MultivalueConcatenationInput firstInput = groupList.get(0);
      log.debug("Processing group: originId={}, sorItemName={}, inputCount={}",
              firstInput.getOriginId(), firstInput.getSorItemName(), groupList.size());

      List<String> valuesToConcat = new ArrayList<>();

      String scalarAdapterActivator = action.getContext().getOrDefault("scalar.adapter.activator", "false");
      for (MultivalueConcatenationInput input : groupList) {
        String originalValue = input.getPredictedValue();
        String value = originalValue;

        if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(input.getIsEncrypted())) {
          try {
            if("false".equalsIgnoreCase(scalarAdapterActivator)){
              log.info("Scalar activator is disabled, running decryption in AES256 mode when decrypting");
              value = encryption.decrypt(value, AES_256, input.getSorItemName());
            }else {
              log.info("Scalar activator is enabled, running decryption in policy mode when decrypting");
              value = encryption.decrypt(value, input.getEncryptionPolicy(), input.getSorItemName());
            }
            log.debug("Decrypted value for originId={}, sorItemName={}", input.getOriginId(), input.getSorItemName());
          } catch (Exception e) {
            log.error("Decryption failed for originId={}, sorItemName={}: {}", input.getOriginId(), input.getSorItemName(), e.getMessage(), e);
            throw e;
          }
        }

        value = (value == null) ? "" : value.trim().replaceAll("(^,+|,+$)", "").replaceAll(",{2,}", ",");

        if (!value.isEmpty() && value.matches(".*\\w.*") && selectedPageNoFromValue == null) {
          selectedPageNoFromValue = input.getPaperNo();
        }

        valuesToConcat.add(value);
      }

      String concatenatedValue = String.join(",", valuesToConcat)
              .replaceAll("(^,+|,+$)", "")
              .replaceAll(",{2,}", ",");

      Integer selectedPageNo = selectedPageNoFromValue != null ? selectedPageNoFromValue : fallbackPageNo;

      log.debug("Concatenated value before encryption for originId={}, sorItemName={}", firstInput.getOriginId(), firstInput.getSorItemName());

      if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(firstInput.getIsEncrypted())) {
        try {
          if("false".equalsIgnoreCase(scalarAdapterActivator)){
            log.info("Scalar activator is disabled, running decryption in AES256 mode when encrypting");
            concatenatedValue = encryption.encrypt(concatenatedValue, AES_256, firstInput.getSorItemName());
          }else {
            log.info("Scalar activator is enabled, running decryption in policy mode when encrypting");
            concatenatedValue = encryption.encrypt(concatenatedValue, firstInput.getEncryptionPolicy(), firstInput.getSorItemName());
          }
          log.info("Encrypted concatenated value for originId={}, sorItemName={}", firstInput.getOriginId(), firstInput.getSorItemName());
        } catch (Exception e) {
          log.error("Encryption failed for originId={}, sorItemName={}: {}", firstInput.getOriginId(), firstInput.getSorItemName(), e.getMessage(), e);
          throw e;
        }
      }

      try {
        insertExecutionInfo(
                jdbi, outputTable,
                firstInput.getOriginId(), firstInput.getSorItemName(), firstInput.getSorItemId(), firstInput.getTenantId(), batchId, concatenatedValue,
                groupId, selectedPageNo, firstInput.getVqaScore(), firstInput.getQuestionId(), firstInput.getSynonymId(),
                firstInput.getModelRegistry(), firstInput.getDocumentId(), firstInput.getBBox(), firstInput.getRootPipelineId(),
                firstInput.getAggregatedScore(), firstInput.getMaskedScore(), firstInput.getRank(),
                firstInput.getSorItemAttributionId(), firstInput.getFrequency()
        );

        log.info("Inserted concatenated value for originId={}, sorItemName={}, paperNo={}", firstInput.getOriginId(), firstInput.getSorItemName(), selectedPageNo);
      } catch (HandymanException e) {
        HandymanException handymanException = new HandymanException(e);
        log.error("Insert failed for originId={}, paperNo={}: {}", firstInput.getOriginId(), selectedPageNo, e.getMessage(), e);
        HandymanException.insertException("Error inserting for originId " +
                firstInput.getOriginId() + ", paperNo " + selectedPageNo, handymanException, null);
      }
    }
    log.info("Completed multi-value concatenation for batchId: {}", batchId);
  }

    private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, String sorItemName, Long sorItemId, Long tenantId, String batchId, String predictedValue, Integer groupId, Integer paperNo, Double vqaScore, Long questionId, Long synonymId, String modelRegistry, String documentId, String bBox, Long rootPipelineId, Long aggregatedScore, Long maskedScore, Long rank, Long sorItemAttributionId, Long frequency) {
        jdbi.useHandle(handle -> handle.createUpdate(
                        "INSERT INTO " + outputTable + " (" +
                                "created_on, created_user_id, last_updated_on, last_updated_user_id, tenant_id, " +
                                "aggregated_score, masked_score, origin_id, paper_no, predicted_value, rank, sor_item_attribution_id, sor_item_name, sor_item_id, " +
                                "document_id, b_box, group_id, root_pipeline_id, vqa_score, question_id, synonym_id, model_registry, batch_id, frequency" +
                                ") VALUES (" +
                                ":createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :tenantId, " +
                                ":aggregatedScore, :maskedScore, :originId, :paperNo, :predictedValue, :rank, :sorItemAttributionId, :sorItemName, :sorItemId, " +
                                ":documentId, :bBox, :groupId, :rootPipelineId, :vqaScore, :questionId, :synonymId, :modelRegistry, :batchId, :frequency" +
                                ");")
                .bind("createdOn", LocalDate.now())
                .bind("createdUserId", tenantId)
                .bind("lastUpdatedOn", LocalDate.now())
                .bind("lastUpdatedUserId", tenantId)
                .bind("tenantId", tenantId)
                .bind("aggregatedScore", aggregatedScore)
                .bind("maskedScore", maskedScore)
                .bind("originId", originId)
                .bind("paperNo", paperNo)
                .bind("predictedValue", predictedValue)
                .bind("rank", rank)
                .bind("sorItemAttributionId", sorItemAttributionId)
                .bind("sorItemName", sorItemName)
                .bind("sorItemId", sorItemId)
                .bind("documentId", documentId)
                .bind("bBox", bBox)
                .bind("groupId", groupId)
                .bind("rootPipelineId", rootPipelineId)
                .bind("vqaScore", vqaScore)
                .bind("questionId", questionId)
                .bind("synonymId", synonymId)
                .bind("modelRegistry", modelRegistry)
                .bind("batchId", batchId)
                .bind("frequency", frequency)
                .execute());
        log.info("Predicted value has been done for the multivalue concatenating logic.");
    }


  @Override
  public boolean executeIf() throws Exception {
    return multivalueConcatenation.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class MultivalueConcatenationInput {
    private String originId;
    private String sorItemName;
    private Long sorItemId;
    private String question;
    private Float votingOut;
    private Long tenantId;
    private String batchId;
    private String predictedValue;
    private Integer groupId;
    private Integer paperNo;
    private Double vqaScore;
    private Long questionId;
    private Long synonymId;
    private String modelRegistry;
    private Integer weight;
    private Double score;
    private String documentId;
    private String validationName;
    private String bBox;
    private Long rootPipelineId;
    private Long aggregatedScore;
    private Long maskedScore;
    private Long rank;
    private Long sorItemAttributionId;
    private Long frequency;
    private String encryptionPolicy;
    private String isEncrypted;

  }

}
