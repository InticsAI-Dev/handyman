package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.encryption.SecurityEngine;
import in.handyman.raven.lib.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.lib.model.AgenticFilterDataDecryption;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.lib.model.kvp.llm.radon.processor.RadonKvpLineItem;
import in.handyman.raven.lib.model.textextraction.DataExtractionConsumerProcess;
import in.handyman.raven.lib.model.textextraction.DataExtractionInputTable;
import in.handyman.raven.lib.model.textextraction.DataExtractionOutputTable;
import in.handyman.raven.lib.utils.FileProcessingUtils;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "AgenticFilterDataDecryption"
)
public class AgenticFilterDataDecryptionAction implements IActionExecution {

  private final ActionExecutionAudit action;

  private final Logger log;

  private final AgenticFilterDataDecryption agenticFilterDataDecryption;

  private final Marker aMarker;

  public AgenticFilterDataDecryptionAction(final ActionExecutionAudit action, final Logger log,
      final Object agenticFilterDataDecryption) {
    this.agenticFilterDataDecryption = (AgenticFilterDataDecryption) agenticFilterDataDecryption;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" AgenticFilterDataDecryption:"+this.agenticFilterDataDecryption.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(agenticFilterDataDecryption.getResourceConn());
      log.info(aMarker, "Agentic Filter DataDecryption Action for {} has been started", agenticFilterDataDecryption.getName());

      String outputTable = agenticFilterDataDecryption.getOutputTable();
      final List<DataExtractionOutputTable> dataExtractionOutputTable = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(agenticFilterDataDecryption.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "executing query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<DataExtractionOutputTable> resultIterable = query.mapToBean(DataExtractionOutputTable.class);
          List<DataExtractionOutputTable> publishQueryInputs = resultIterable.stream().collect(Collectors.toList());
          dataExtractionOutputTable.addAll(publishQueryInputs);
          log.info(aMarker, "executed query from index {}", i.get());
        });
      });

      dataExtractionOutputTable.forEach(dataExtractionOutputTable1 -> {
        try {
          doAgenticFilterDataDecryption(dataExtractionOutputTable1, jdbi, outputTable);
        } catch (JsonProcessingException e) {
          HandymanException handymanException = new HandymanException(e);
          HandymanException.insertException("Agentic Filter DataDecryption Input table failed {}:", handymanException, action);
        }
      });

      log.info(aMarker, "Agentic Filter DataDecryption Action has been completed {}  ", agenticFilterDataDecryption.getName());
    } catch (Exception e) {
      action.getContext().put(agenticFilterDataDecryption.getName() + ".isSuccessful", "false");
      log.error(aMarker, "Error in execute method for Agentic Filter DataDecryption ", e);
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("Agentic Filter DataDecryption comparison failed {}:", handymanException, action);
    }
  }

  private void doAgenticFilterDataDecryption(DataExtractionOutputTable dataExtractionOutputTable, Jdbi jdbi, String outputTable) throws JsonProcessingException {
    log.info("Processing the Agentic Filter DataDecryption input data AgenticFilterDataDecryptionInputTable: {}", dataExtractionOutputTable);

    String originId = dataExtractionOutputTable.getOriginId();
    Integer groupId = dataExtractionOutputTable.getGroupId();
    Long tenantId = dataExtractionOutputTable.getTenantId();
    String templateId = dataExtractionOutputTable.getTemplateId();
    Long processId = dataExtractionOutputTable.getProcessId();
    String filePath = dataExtractionOutputTable.getFilePath();
    String fileName = dataExtractionOutputTable.getFileName();
    Integer paperNo = dataExtractionOutputTable.getPaperNo();
    String status = dataExtractionOutputTable.getStatus();
    String stage = dataExtractionOutputTable.getStage();
    String message = dataExtractionOutputTable.getMessage();
    String isBlankPage = dataExtractionOutputTable.getIsBlankPage();
    Long rootPipelineId = dataExtractionOutputTable.getRootPipelineId();
    String templateName = dataExtractionOutputTable.getTemplateName();
    String modelVersion = dataExtractionOutputTable.getModelVersion();
    String batchId = dataExtractionOutputTable.getBatchId();
    String request = dataExtractionOutputTable.getRequest();
    String response = dataExtractionOutputTable.getResponse();
    String endpoint = dataExtractionOutputTable.getEndpoint();

    String extractedText;

    String modelName = "AGENTIC_PAPER_FILTER";

    InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action);
    String encryptData = action.getContext().getOrDefault("pipeline.end.to.end.encryption","false");
    if (Objects.equals(encryptData, "true")) {
        log.info("Decryption started for the Agentic paper filter output JSON");
        extractedText = encryption.decrypt(dataExtractionOutputTable.getExtractedText(), "AES256", "TEXT_DATA");
        log.info("Decryption completed for the Agentic paper filter output JSON");
        insertExecutionInfo(jdbi, outputTable, originId,groupId,tenantId,templateId,processId,filePath,fileName,paperNo,status,stage,message,isBlankPage,rootPipelineId,templateName,modelVersion,batchId, request, response,endpoint, extractedText, modelName);
    }
  }

  private void insertExecutionInfo(Jdbi jdbi, String outputTable, String originId, Integer groupId, Long tenantId, String templateId, Long processId, String filePath, String fileName, Integer paperNo, String status, String stage, String message, String isBlankPage, Long rootPipelineId, String templateName, String modelVersion, String batchId, String request, String response, String endpoint, String extractedText, String modelName) {
    jdbi.useHandle(handle -> handle.createUpdate("INSERT INTO " + outputTable +"(process_id, tenant_id, template_id, group_id, origin_id, paper_no, file_path, file_name, extracted_text, status, stage, message, template_name, is_blank_page, created_on, root_pipeline_id, model_name, model_version, endpoint, request, response, batch_id, last_updated_on)" +
            "VALUES(:processId, :tenantId, :templateId, :groupId, :originId, :paperNo, :filePath, :fileName, :extractedText, :status, :stage, :message, :templateName, :isBlankPage, :createdOn, :rootPipelineId, :modelName, :modelVersion, :endpoint, :request, :response, :batchId, :lastUpdatedOn")
            .bind("processId", processId)
            .bind("tenantId", tenantId)
            .bind("templateId",templateId)
            .bind("groupId", groupId)
            .bind("originId", originId)
            .bind("paperNo", paperNo)
            .bind("fileName", filePath)
            .bind("fileName", fileName)
            .bind("extractedText", extractedText)
            .bind("status", status)
            .bind("stage", stage)
            .bind("message", message)
            .bind("templateName", templateName)
            .bind("isBlankPage", isBlankPage)
            .bind("createdOn", LocalDate.now())
            .bind("rootPipelineId", rootPipelineId)
            .bind("modelName", modelName)
            .bind("modelVersion", modelVersion)
            .bind("endpoint", endpoint)
            .bind("request", request)
            .bind("response", response)
            .bind("batchId", batchId)
            .bind("lastUpdatedOn", LocalDate.now())
            .execute());
  }


  @Override
  public boolean executeIf() throws Exception {
    return agenticFilterDataDecryption.getCondition();
  }
}
