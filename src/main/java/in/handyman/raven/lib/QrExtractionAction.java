package in.handyman.raven.lib;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.QrExtraction;
import in.handyman.raven.lib.model.qrExtraction.*;
import in.handyman.raven.lib.model.triton.TritonInputRequest;
import in.handyman.raven.lib.model.triton.TritonRequest;
import in.handyman.raven.util.ExceptionUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "QrExtraction"
)
public class QrExtractionAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final QrExtraction qrExtraction;
  private static String httpClientTimeout = new String();
    private final Marker aMarker;

    public QrExtractionAction(final ActionExecutionAudit action, final Logger log,
                              final Object qrExtraction) {
        this.qrExtraction = (QrExtraction) qrExtraction;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" QrExtraction:" + this.qrExtraction.getName());
      this.httpClientTimeout = action.getContext().get("okhttp.client.timeout");
    }

    @Override
    public void execute() throws Exception {
        try {
            log.info(aMarker, "Qr extraction Action for {} with group by eoc-id has started", qrExtraction.getName());
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(qrExtraction.getResourceConn());

            //3. initiate copro processor and copro urls
            final List<URL> urls = Optional.ofNullable(action.getContext().get("copro.qr-attribution.url")).map(s -> Arrays.stream(s.split(",")).map(s1 -> {
                try {
                    return new URL(s1);
                } catch (MalformedURLException e) {
                    log.error("Error in processing the URL {}", s1, e);
                    throw new HandymanException("Error in processing the URL", e, action);
                }
            }).collect(Collectors.toList())).orElse(Collections.emptyList());

            log.info("Urls for the qr attribution for sor grouping {}", urls);

            //5. build insert prepare statement with output table columns
            final String insertQuery = "INSERT INTO " + qrExtraction.getOutputTable() +
                    "            (origin_id, group_id, paper_no, created_on,   qr_format, qr_format_id, extracted_value,   file_id, b_box, angle, confidence_score, status, stage, message,decode_type, model_name, model_version,root_pipeline_id)" +
                    "VALUES(?,?,?,?,  ?,?,? ,?,?,  ?,?,?, ?,?  ,?, ?,? , ?)";
            final CoproProcessor<QrInputEntity, QrOutputEntity> coproProcessor =
                    new CoproProcessor<>(new LinkedBlockingQueue<>(),
                            QrOutputEntity.class,
                            QrInputEntity.class,
                            jdbi, log,
                            new QrInputEntity(), urls, action);
            //4. call the method start producer from coproprocessor
            coproProcessor.startProducer(qrExtraction.getQuerySet(), Integer.valueOf(action.getContext().get("read.batch.size")));
            log.info("start producer method from copro processor ");
            Thread.sleep(1000);
            //8. call the method start consumer from coproprocessor
            coproProcessor.startConsumer(insertQuery, Integer.valueOf(action.getContext().get("qr.consumer.API.count")), Integer.valueOf(action.getContext().get("write.batch.size")), new QrConsumerProcess(log, aMarker, action));
            log.info("start consumer method from copro processor ");

        } catch (Exception e) {
            log.error("Error in the Qr extraction action {}", ExceptionUtil.toString(e));
            throw new HandymanException("QR extraction action failed ", e, action);

        }

    }


    //6. write consumer process class which implements CoproProcessor.ConsumerProcess

    @Override
    public boolean executeIf() throws Exception {
        return qrExtraction.getCondition();
    }
}
