package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.opencsv.CSVWriter;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.encryption.protegrity.api.ProtegrityApiRequest;

import java.io.FileWriter;
import java.io.IOException;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.DecryptInticsEnc;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import org.jdbi.v3.core.statement.Query;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "DecryptInticsEnc"
)
public class DecryptInticsEncAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final DecryptInticsEnc decryptInticsEnc;
  private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();
  private static final String CSV_HEADER[] = {"RootPipelineId", "GroupId", "TenantId", "SorContainerName", "FileName", "OriginId", "PaperNo", "SorItemName", "ExtractedValue", "PolicyName"};
  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

  private final Marker aMarker;


  public DecryptInticsEncAction(final ActionExecutionAudit action, final Logger log,
                                final Object decryptInticsEnc) {
    this.decryptInticsEnc = (DecryptInticsEnc) decryptInticsEnc;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" DecryptInticsEnc:"+this.decryptInticsEnc.getName());
  }

  @Override
  public void execute() throws Exception {

    try {
      log.info(aMarker, "Starting decryption API caller: {}", decryptInticsEnc.getName());
      String headersListStr = action.getContext().get("csv.headers.list");

      List<String> headersList = Arrays.asList(headersListStr.split(","));

      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(decryptInticsEnc.getSource());
      List<QueryOutput> queryResults = fetchQueryResults(jdbi);
      List<DecryptedCsvData> decryptedData = processDecryption(queryResults);


        writeToCsv5(decryptedData, headersList, decryptInticsEnc.getOutputPath());


    } catch (Exception e) {
      log.error(aMarker, "Error executing DecryptInticsEncAction: {}", e.getMessage(), e);
      throw e;
    }
  }


  private List<QueryOutput> fetchQueryResults(Jdbi jdbi) {
    List<QueryOutput> results = new ArrayList<>();
    jdbi.useTransaction(handle -> {
      List<String> formattedQueries = CommonQueryUtil.getFormattedQuery(decryptInticsEnc.getQuerySet());
      AtomicInteger queryIndex = new AtomicInteger(0);
      formattedQueries.forEach(sql -> {
        log.info(aMarker, "Executing query [{}]: {}", queryIndex.getAndIncrement(), sql);
        Query query = handle.createQuery(sql);
        results.addAll(query.mapToBean(QueryOutput.class).stream().collect(Collectors.toList()));
      });
    });
    return results;

  }



  @Override
  public boolean executeIf() throws Exception {
    return decryptInticsEnc.getCondition();
  }

  private List<DecryptedCsvData> processDecryption(List<QueryOutput> queryResults) {
    List<DecryptedCsvData> outputData = new ArrayList<>();

    for (QueryOutput queryOutput : queryResults) {
      try {

        List<extractedMetaDetail> apiRequests = OBJECT_MAPPER.readValue(queryOutput.getExtractedMetaDetail(), new TypeReference<>() {});
        List<extractedMetaDetail> encryptedList = apiRequests.stream()
                .filter(extractedMetaDetail::getIsEncrypted)
                .collect(Collectors.toList());

        List<extractedMetaDetail> nonEncryptedList = apiRequests.stream()
                .filter(request -> Boolean.FALSE.equals(request.getIsEncrypted()))
                .collect(Collectors.toList());

        String jsonPayload = OBJECT_MAPPER.writeValueAsString(encryptedList);
        RequestBody body = RequestBody.create(jsonPayload, MediaType.get("application/json"));


        Request request = new Request.Builder().url(decryptInticsEnc.getEndpoint()).post(body).build();

        try (Response response = HTTP_CLIENT.newCall(request).execute()) {
          if (!response.isSuccessful()) {
            throw new HandymanException("Protegrity API error: " + response.message());
          }
          List<ProtegrityApiRequest> apiResponses = OBJECT_MAPPER.readValue(response.body().string(), new TypeReference<>() {});

          apiResponses.forEach(apiResponse -> outputData.add(
                  DecryptedCsvData.builder()
                          .rootPipelineId(queryOutput.getRootPipelineId())
                          .groupId(queryOutput.getGroupId())
                          .tenantId(queryOutput.getTenantId())
                          .sorContainerName(queryOutput.getSorContainerName())
                          .fileName(queryOutput.getFileName())
                          .originId(queryOutput.getOriginId())
                          .documentId(queryOutput.getDocumentId())
                          .paperNo(queryOutput.getPaperNo())
                          .sorItemName(apiResponse.getKey())
                          .extractedValue(apiResponse.getValue())
                          .policyName(apiResponse.getPolicy())
                          .build()
          ));

          nonEncryptedList.forEach(extractedMetaDetail -> {
            outputData.add(DecryptedCsvData.builder()
                    .rootPipelineId(queryOutput.getRootPipelineId())
                    .groupId(queryOutput.getGroupId())
                    .tenantId(queryOutput.getTenantId())
                    .sorContainerName(queryOutput.getSorContainerName())
                    .fileName(queryOutput.getFileName())
                    .originId(queryOutput.getOriginId())
                    .documentId(queryOutput.getDocumentId())
                    .paperNo(queryOutput.getPaperNo())
                    .sorItemName(extractedMetaDetail.getKey())
                    .extractedValue(extractedMetaDetail.getValue())
                    .policyName(extractedMetaDetail.getPolicy())
                    .build());
          });
        }


      } catch (IOException e) {
        log.error("Error calling Protegrity API for container {}: {}", queryOutput.getSorContainerName(), e.getMessage(), e);
        throw new HandymanException("Error calling Protegrity API: " + e.getMessage(), e);
      }


    }
    return outputData;
  }

  private static void writeToCsv(List<DecryptedCsvData> dataList, String filePath) {
    try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
      writer.writeNext(CSV_HEADER);
      dataList.forEach(data -> writer.writeNext(new String[]{
              data.getRootPipelineId(),
              data.getGroupId() != null ? data.getGroupId().toString() : "",
              data.getTenantId() != null ? data.getTenantId().toString() : "",
              data.getSorContainerName(),
              data.getFileName(),
              data.getOriginId(),
              data.getPaperNo() != null ? data.getPaperNo().toString() : "",
              data.getSorItemName(),
              data.getExtractedValue(),
              data.getPolicyName()
      }));
    } catch (IOException e) {
      throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e);
    }
  }


  public static void writeCsv(List<Map<String, String>> dataList, String filePath) {
    if (dataList.isEmpty()) {
      System.out.println("No data to write!");
      return;
    }

    // Extract headers (unique keys from all maps)
    Set<String> headersSet = new LinkedHashSet<>();
    for (Map<String, String> data : dataList) {
      headersSet.addAll(data.keySet()); // Collect all keys
    }
    List<String> headers = new ArrayList<>(headersSet); // Convert to ordered list

    try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
      // Write headers
      writer.writeNext(headers.toArray(new String[0]));

      // Write rows
      for (Map<String, String> data : dataList) {
        String[] row = headers.stream()
                .map(header -> data.getOrDefault(header, "")) // Get value or empty string
                .toArray(String[]::new);
        writer.writeNext(row);
      }

      System.out.println("CSV successfully written to: " + filePath);

    } catch (IOException e) {
      e.printStackTrace();
    }
  }
  private static void writeToCsvWithHeaders(List<DecryptedCsvData> dataList, String filePath) {
    try {
      // Step 1: Extract unique sorItemNames (these will be dynamic headers)
      Set<String> dynamicHeaders = dataList.stream()
              .map(DecryptedCsvData::getSorItemName)
              .collect(Collectors.toSet());

      // Step 2: Sort headers for consistency
      List<String> sortedDynamicHeaders = new ArrayList<>(dynamicHeaders);
      Collections.sort(sortedDynamicHeaders);

      // Step 3: Define static headers (RootPipelineId, FileName)
      List<String> csvHeaders = new ArrayList<>();
      csvHeaders.add("RootPipelineId");
      csvHeaders.add("FileName");
      csvHeaders.addAll(sortedDynamicHeaders); // Add dynamic headers

      try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
        // Step 4: Write the header row (first row)
        writer.writeNext(csvHeaders.toArray(new String[0]));

        // Step 5: Prepare the data row (second row)
        List<String> row = new ArrayList<>();

        // Assume all records belong to the same RootPipelineId and FileName
        if (!dataList.isEmpty()) {
          DecryptedCsvData firstRecord = dataList.get(0);
          row.add(firstRecord.getRootPipelineId());
          row.add(firstRecord.getFileName());
        } else {
          row.add(""); // Empty RootPipelineId if no data
          row.add(""); // Empty FileName if no data
        }

        // Create a map of sorItemName -> extractedValue for quick lookup
        Map<String, String> valueMap = dataList.stream()
                .collect(Collectors.toMap(DecryptedCsvData::getSorItemName, DecryptedCsvData::getExtractedValue, (v1, v2) -> v1));

        // Fill the row with extracted values matching the dynamic headers
        for (String header : sortedDynamicHeaders) {
          row.add(valueMap.getOrDefault(header, "")); // Fill missing values with empty string
        }

        // Step 6: Write the single row of data
        writer.writeNext(row.toArray(new String[0]));
      }
    } catch (IOException e) {
      throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e);
    }
  }

  private static void writeToCsv5(List<DecryptedCsvData> dataList, List<String> headers, String filePath) {

    try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
      // Write headers
      writer.writeNext(headers.toArray(new String[0]));

      // Group data by filename to create one row per file
      Map<String, Map<String, String>> groupedData = new HashMap<>();

      for (DecryptedCsvData data : dataList) {
        // Create a unique key for each record
        String recordKey = data.getFileName();

        // Get or create the map for this record
        Map<String, String> record = groupedData.computeIfAbsent(recordKey, k -> new HashMap<>());

        // Set the filename field for each record
        record.put("file_name", data.getFileName());
        record.put("document_id", data.getDocumentId());

        // Map the sorItemName directly to the matching header
        String sorItemName = data.getSorItemName();
        String extractedValue = data.getExtractedValue();

        // Only set the value if the sorItemName matches one of our headers
        if (headers.contains(sorItemName)) {
          record.put(sorItemName, extractedValue);
        }
      }

      // Write each record to the CSV
      for (Map<String, String> record : groupedData.values()) {
        String[] row = new String[headers.size()];

        // For each header, get the corresponding value from the record map
        for (int i = 0; i < headers.size(); i++) {
          String header = headers.get(i);
          row[i] = record.getOrDefault(header, ""); // Use empty string if value not found
        }

        writer.writeNext(row);
      }
    } catch (IOException e) {
      throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e);
    }
  }
  public static void writeToCsvWithHeaders(List<DecryptedCsvData> dataList, List<String> headers, String filePath) {
    try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
      // Write headers
      writer.writeNext(headers.toArray(new String[0]));

      // Create a map of filename -> (sorItemName -> extractedValue)
      Map<String, Map<String, String>> fileDataMap = dataList.stream()
              .collect(Collectors.groupingBy(
                      DecryptedCsvData::getFileName,
                      Collectors.toMap(DecryptedCsvData::getSorItemName, DecryptedCsvData::getExtractedValue, (v1, v2) -> v1)
              ));

      // Iterate over fileDataMap and write to CSV
      for (Map.Entry<String, Map<String, String>> fileEntry : fileDataMap.entrySet()) {
        String fileName = fileEntry.getKey();
        Map<String, String> sorItemMap = fileEntry.getValue();

        int headersListSize = headers.size()+1;
        String[] row = new String[headersListSize];
        row[0] = fileName; // Set the file name

        // Match headers with sorItemName and fetch values
        for (int i = 2; i < headersListSize; i++) {
          row[i] = sorItemMap.getOrDefault(headers.get(i), "");
        }

        writer.writeNext(row);
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void writeToCsv1(List<DecryptedCsvData> dataList, String filePath) {
    // Extract unique sorItemNames for headers and include "fileName" as the first column
    Set<String> sorItemNames = dataList.stream()
            .map(DecryptedCsvData::getSorItemName)
            .collect(Collectors.toSet());

    List<String> headers = List.of("fileName");
    headers.addAll(sorItemNames);

    try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
      // Write headers
      writer.writeNext(headers.toArray(new String[0]));

      // Group data by fileName
      Map<String, Map<String, String>> fileDataMap = dataList.stream()
              .collect(Collectors.groupingBy(
                      DecryptedCsvData::getFileName,
                      Collectors.toMap(DecryptedCsvData::getSorItemName, DecryptedCsvData::getExtractedValue, (v1, v2) -> v1)
              ));

      // Iterate over fileDataMap and write rows
      for (Map.Entry<String, Map<String, String>> fileEntry : fileDataMap.entrySet()) {
        String fileName = fileEntry.getKey();
        Map<String, String> sorItemMap = fileEntry.getValue();

        String[] row = new String[headers.size()];
        row[0] = fileName; // Set the file name

        // Match headers with sorItemName and fetch values
        for (int i = 1; i < headers.size(); i++) {
          row[i] = sorItemMap.getOrDefault(headers.get(i), "");
        }

        writer.writeNext(row);
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }


  @Data @Builder @NoArgsConstructor @AllArgsConstructor @JsonIgnoreProperties(ignoreUnknown = true)
  public static class QueryOutput {
    private String rootPipelineId;
    private Integer groupId;
    private Integer tenantId;
    private String sorContainerName;
    private String documentId;
    private String fileName;
    private String originId;
    private Integer paperNo;
    private String extractedMetaDetail;
  }

  @Data  @Builder  @NoArgsConstructor  @AllArgsConstructor  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class DecryptedCsvData {
    private String rootPipelineId;
    private Integer groupId;
    private Integer tenantId;
    private String sorContainerName;
    private String fileName;
    private String originId;
    private Integer paperNo;
    private String sorItemName;
    private String documentId;
    private String extractedValue;
    private String policyName;
  }


  @Data  @Builder  @NoArgsConstructor  @AllArgsConstructor  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class extractedMetaDetail {

    String value;
    String policy;
    String key;
    Boolean isEncrypted;
  }
}
