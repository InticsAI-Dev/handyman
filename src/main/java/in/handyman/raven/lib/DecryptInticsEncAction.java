package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.opencsv.CSVWriter;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.encryption.protegrity.api.ProtegrityApiRequest;

import java.io.FileWriter;
import java.io.IOException;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.DecryptInticsEnc;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import org.jdbi.v3.core.statement.Query;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "DecryptInticsEnc"
)
public class DecryptInticsEncAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final DecryptInticsEnc decryptInticsEnc;
  private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();
  private static final String CSV_HEADER[] = {"RootPipelineId", "GroupId", "TenantId", "SorContainerName", "FileName", "OriginId", "PaperNo", "SorItemName", "ExtractedValue", "PolicyName"};
  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

  private final Marker aMarker;


  public DecryptInticsEncAction(final ActionExecutionAudit action, final Logger log,
                                final Object decryptInticsEnc) {
    this.decryptInticsEnc = (DecryptInticsEnc) decryptInticsEnc;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" DecryptInticsEnc:"+this.decryptInticsEnc.getName());
  }

  @Override
  public void execute() throws Exception {

    try {
      log.info(aMarker, "Starting decryption API caller: {}", decryptInticsEnc.getName());

      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(decryptInticsEnc.getSource());
      List<QueryOutput> queryResults = fetchQueryResults(jdbi);
      List<DecryptedCsvData> decryptedData = processDecryption(queryResults);

      writeToCsv(decryptedData, decryptInticsEnc.getOutputPath());

    } catch (Exception e) {
      log.error(aMarker, "Error executing DecryptInticsEncAction: {}", e.getMessage(), e);
      throw e;
    }
  }


  private List<QueryOutput> fetchQueryResults(Jdbi jdbi) {
    List<QueryOutput> results = new ArrayList<>();
    jdbi.useTransaction(handle -> {
      List<String> formattedQueries = CommonQueryUtil.getFormattedQuery(decryptInticsEnc.getQuerySet());
      AtomicInteger queryIndex = new AtomicInteger(0);
      formattedQueries.forEach(sql -> {
        log.info(aMarker, "Executing query [{}]: {}", queryIndex.getAndIncrement(), sql);
        Query query = handle.createQuery(sql);
        results.addAll(query.mapToBean(QueryOutput.class).stream().collect(Collectors.toList()));
      });
    });
    return results;

  }



  @Override
  public boolean executeIf() throws Exception {
    return decryptInticsEnc.getCondition();
  }

  private List<DecryptedCsvData> processDecryption(List<QueryOutput> queryResults) {
    List<DecryptedCsvData> outputData = new ArrayList<>();

    for (QueryOutput queryOutput : queryResults) {
      try {

        List<extractedMetaDetail> apiRequests = OBJECT_MAPPER.readValue(queryOutput.getExtractedMetaDetail(), new TypeReference<>() {});
        List<extractedMetaDetail> encryptedList = apiRequests.stream()
                .filter(extractedMetaDetail::getIsEncrypted)
                .collect(Collectors.toList());

        List<extractedMetaDetail> nonEncryptedList = apiRequests.stream()
                .filter(request -> Boolean.FALSE.equals(request.getIsEncrypted()))
                .collect(Collectors.toList());

        String jsonPayload = OBJECT_MAPPER.writeValueAsString(encryptedList);
        RequestBody body = RequestBody.create(jsonPayload, MediaType.get("application/json"));


        Request request = new Request.Builder().url(decryptInticsEnc.getEndpoint()).post(body).build();

        try (Response response = HTTP_CLIENT.newCall(request).execute()) {
          if (!response.isSuccessful()) {
            throw new HandymanException("Protegrity API error: " + response.message());
          }
          List<ProtegrityApiRequest> apiResponses = OBJECT_MAPPER.readValue(response.body().string(), new TypeReference<>() {});

          apiResponses.forEach(apiResponse -> outputData.add(
                  DecryptedCsvData.builder()
                          .rootPipelineId(queryOutput.getRootPipelineId())
                          .groupId(queryOutput.getGroupId())
                          .tenantId(queryOutput.getTenantId())
                          .sorContainerName(queryOutput.getSorContainerName())
                          .fileName(queryOutput.getFileName())
                          .originId(queryOutput.getOriginId())
                          .paperNo(queryOutput.getPaperNo())
                          .sorItemName(apiResponse.getKey())
                          .extractedValue(apiResponse.getValue())
                          .policyName(apiResponse.getPolicy())
                          .build()
          ));

          nonEncryptedList.forEach(extractedMetaDetail -> {
            DecryptedCsvData.builder()
                    .rootPipelineId(queryOutput.getRootPipelineId())
                    .groupId(queryOutput.getGroupId())
                    .tenantId(queryOutput.getTenantId())
                    .sorContainerName(queryOutput.getSorContainerName())
                    .fileName(queryOutput.getFileName())
                    .originId(queryOutput.getOriginId())
                    .paperNo(queryOutput.getPaperNo())
                    .sorItemName(extractedMetaDetail.getKey())
                    .extractedValue(extractedMetaDetail.getValue())
                    .policyName(extractedMetaDetail.getPolicy())
                    .build();
          });
        }


      } catch (IOException e) {
        log.error("Error calling Protegrity API for container {}: {}", queryOutput.getSorContainerName(), e.getMessage(), e);
        throw new HandymanException("Error calling Protegrity API: " + e.getMessage(), e);
      }


    }
    return outputData;
  }

  private static void writeToCsv(List<DecryptedCsvData> dataList, String filePath) {
    try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
      writer.writeNext(CSV_HEADER);
      dataList.forEach(data -> writer.writeNext(new String[]{
              data.getRootPipelineId(),
              data.getGroupId() != null ? data.getGroupId().toString() : "",
              data.getTenantId() != null ? data.getTenantId().toString() : "",
              data.getSorContainerName(),
              data.getFileName(),
              data.getOriginId(),
              data.getPaperNo() != null ? data.getPaperNo().toString() : "",
              data.getSorItemName(),
              data.getExtractedValue(),
              data.getPolicyName()
      }));
    } catch (IOException e) {
      throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e);
    }
  }

  @Data @Builder @NoArgsConstructor @AllArgsConstructor @JsonIgnoreProperties(ignoreUnknown = true)
  public static class QueryOutput {
    private String rootPipelineId;
    private Integer groupId;
    private Integer tenantId;
    private String sorContainerName;
    private String fileName;
    private String originId;
    private Integer paperNo;
    private String extractedMetaDetail;
  }

  @Data  @Builder  @NoArgsConstructor  @AllArgsConstructor  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class DecryptedCsvData {
    private String rootPipelineId;
    private Integer groupId;
    private Integer tenantId;
    private String sorContainerName;
    private String fileName;
    private String originId;
    private Integer paperNo;
    private String sorItemName;
    private String extractedValue;
    private String policyName;
  }


  @Data  @Builder  @NoArgsConstructor  @AllArgsConstructor  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class extractedMetaDetail {

    String value;
    String policy;
    String key;
    Boolean isEncrypted;
  }
}
