package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.opencsv.CSVWriter;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.encryption.protegrity.api.ProtegrityApiRequest;
import in.handyman.raven.lib.model.DecryptInticsEnc;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static in.handyman.raven.lib.encryption.EncryptionConstants.ENCRYPT_ITEM_WISE_ENCRYPTION;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "DecryptInticsEnc"
)
public class DecryptInticsEncAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final DecryptInticsEnc decryptInticsEnc;
    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private final Marker aMarker;


    public DecryptInticsEncAction(final ActionExecutionAudit action, final Logger log,
                                  final Object decryptInticsEnc) {
        this.decryptInticsEnc = (DecryptInticsEnc) decryptInticsEnc;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" DecryptInticsEnc:" + this.decryptInticsEnc.getName());
    }

    @Override
    public void execute() throws Exception {

        try {
            log.info(aMarker, "Starting decryption API caller: {}", decryptInticsEnc.getName());
            String headersListStr = action.getContext().get("csv.headers.list");

            Path outputFilePath = createOutputFilePath();

            List<String> headersList = Arrays.asList(headersListStr.split(","));

            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(decryptInticsEnc.getSource());
            List<QueryOutput> queryResults = fetchQueryResults(jdbi);

            List<DecryptedCsvData> csvInputData = new ArrayList<>();
            if ("true".equals(action.getContext().get(ENCRYPT_ITEM_WISE_ENCRYPTION))) {
                List<DecryptedCsvData> decryptedData = processDecryption(queryResults);
                csvInputData.addAll(decryptedData);
            } else {
                List<DecryptedCsvData> decryptedData = processWithoutDecryption(queryResults);
                csvInputData.addAll(decryptedData);
            }


            writeToCsv5(csvInputData, headersList, outputFilePath.toString());


        } catch (Exception e) {
            log.error(aMarker, "Error executing DecryptInticsEncAction: {}", e.getMessage(), e);
            throw new HandymanException("Error executing DecryptInticsEncAction ", e, action);
        }
    }


    public Path createOutputFilePath() {
        try {
            // Get base directory path
            String targetDirectoryPath = action.getContext().get("target_directory_path");

            // Define the decrypted CSV directory path
            Path folderPath = Paths.get(targetDirectoryPath, "decrypted-csv");

            // Create directory if it does not exist
            Files.createDirectories(folderPath);

            // Get the CSV file name from decryptInticsEnc
            String fileName = decryptInticsEnc.getOutputPath();

            // Combine directory with the CSV file name
            Path filePath = folderPath.resolve(fileName);

            return filePath; // Return the full file path
        } catch (IOException e) {
            throw new HandymanException("Failed to create directory or file path: " + e.getMessage(), e, action);
        }
    }


    private List<QueryOutput> fetchQueryResults(Jdbi jdbi) {
        List<QueryOutput> results = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            List<String> formattedQueries = CommonQueryUtil.getFormattedQuery(decryptInticsEnc.getQuerySet());
            AtomicInteger queryIndex = new AtomicInteger(0);
            formattedQueries.forEach(sql -> {
                log.info(aMarker, "Executing query [{}]: {}", queryIndex.getAndIncrement(), sql);
                Query query = handle.createQuery(sql);
                results.addAll(query.mapToBean(QueryOutput.class).stream().collect(Collectors.toList()));
            });
        });
        return results;

    }


    @Override
    public boolean executeIf() throws Exception {
        return decryptInticsEnc.getCondition();
    }

    private List<DecryptedCsvData> processWithoutDecryption(List<QueryOutput> queryResults) {
        List<DecryptedCsvData> outputData = new ArrayList<>();
        queryResults.forEach(queryOutput -> {
            try {
                List<extractedMetaDetail> apiRequests = OBJECT_MAPPER.readValue(queryOutput.getExtractedMetaDetail(), new TypeReference<>() {
                });
                apiRequests.forEach(extractedMetaDetail -> outputData.add(DecryptedCsvData.builder()
                        .groupId(queryOutput.getGroupId())
                        .paperNo(queryOutput.getPaperNo())
                        .tenantId(queryOutput.getTenantId())
                        .rootPipelineId(queryOutput.getRootPipelineId())
                        .extractedValue(extractedMetaDetail.getValue())
                        .fileName(queryOutput.getFileName())
                        .policyName(extractedMetaDetail.getPolicy())
                        .sorContainerName(queryOutput.getSorContainerName())
                        .sorItemName(extractedMetaDetail.getKey())
                        .documentId(queryOutput.getDocumentId())
                        .originId(queryOutput.getOriginId())
                        .build()
                ));
            } catch (JsonProcessingException e) {
                throw new HandymanException("Json processing of the meta details got error ", e, action);
            }
        });
        return outputData;
    }

    private List<DecryptedCsvData> processDecryption(List<QueryOutput> queryResults) {
        List<DecryptedCsvData> outputData = new ArrayList<>();

        for (QueryOutput queryOutput : queryResults) {
            try {

                List<extractedMetaDetail> apiRequests = OBJECT_MAPPER.readValue(queryOutput.getExtractedMetaDetail(), new TypeReference<>() {
                });
                List<extractedMetaDetail> encryptedList = apiRequests.stream()
                        .filter(extractedMetaDetail::getIsEncrypted)
                        .collect(Collectors.toList());

                List<extractedMetaDetail> nonEncryptedList = apiRequests.stream()
                        .filter(request -> Boolean.FALSE.equals(request.getIsEncrypted()))
                        .collect(Collectors.toList());

                String jsonPayload = OBJECT_MAPPER.writeValueAsString(encryptedList);
                RequestBody body = RequestBody.create(jsonPayload, MediaType.get("application/json"));


                Request request = new Request.Builder().url(decryptInticsEnc.getEndpoint()).post(body).build();

                try (Response response = HTTP_CLIENT.newCall(request).execute()) {
                    if (!response.isSuccessful()) {
                        throw new HandymanException("Protegrity API error: " + response.message(), new HandymanException(response.message()), action);
                    }
                    List<ProtegrityApiRequest> apiResponses = OBJECT_MAPPER.readValue(response.body().string(), new TypeReference<>() {
                    });

                    apiResponses.forEach(apiResponse -> outputData.add(
                            DecryptedCsvData.builder()
                                    .rootPipelineId(queryOutput.getRootPipelineId())
                                    .groupId(queryOutput.getGroupId())
                                    .tenantId(queryOutput.getTenantId())
                                    .sorContainerName(queryOutput.getSorContainerName())
                                    .fileName(queryOutput.getFileName())
                                    .originId(queryOutput.getOriginId())
                                    .documentId(queryOutput.getDocumentId())
                                    .paperNo(queryOutput.getPaperNo())
                                    .sorItemName(apiResponse.getKey())
                                    .extractedValue(apiResponse.getValue())
                                    .policyName(apiResponse.getPolicy())
                                    .build()
                    ));

                    nonEncryptedList.forEach(extractedMetaDetail -> {
                        outputData.add(DecryptedCsvData.builder()
                                .rootPipelineId(queryOutput.getRootPipelineId())
                                .groupId(queryOutput.getGroupId())
                                .tenantId(queryOutput.getTenantId())
                                .sorContainerName(queryOutput.getSorContainerName())
                                .fileName(queryOutput.getFileName())
                                .originId(queryOutput.getOriginId())
                                .documentId(queryOutput.getDocumentId())
                                .paperNo(queryOutput.getPaperNo())
                                .sorItemName(extractedMetaDetail.getKey())
                                .extractedValue(extractedMetaDetail.getValue())
                                .policyName(extractedMetaDetail.getPolicy())
                                .build());
                    });
                }


            } catch (IOException e) {
                log.error("Error calling Protegrity API for container {}: {}", queryOutput.getSorContainerName(), e.getMessage(), e);
                throw new HandymanException("Error calling Protegrity API: " + e.getMessage(), e);
            }


        }
        return outputData;
    }


    private void writeToCsv5(List<DecryptedCsvData> dataList, List<String> headers, String filePath) {

        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            log.info("File will be stored in this path {}", filePath);
            // Write headers
            writer.writeNext(headers.toArray(new String[0]));

            // Group data by filename to create one row per file
            Map<String, Map<String, String>> groupedData = new HashMap<>();

            for (DecryptedCsvData data : dataList) {
                // Create a unique key for each record
                String recordKey = data.getFileName();

                // Get or create the map for this record
                Map<String, String> record = groupedData.computeIfAbsent(recordKey, k -> new HashMap<>());

                // Set the filename field for each record
                record.put("file_name", data.getFileName());
                record.put("document_id", data.getDocumentId());

                // Map the sorItemName directly to the matching header
                String sorItemName = data.getSorItemName();
                String extractedValue = data.getExtractedValue();

                // Only set the value if the sorItemName matches one of our headers
                if (headers.contains(sorItemName)) {
                    record.put(sorItemName, extractedValue);
                }
            }

            // Write each record to the CSV
            for (Map<String, String> record : groupedData.values()) {
                String[] row = new String[headers.size()];

                // For each header, get the corresponding value from the record map
                for (int i = 0; i < headers.size(); i++) {
                    String header = headers.get(i);
                    row[i] = record.getOrDefault(header, ""); // Use empty string if value not found
                }

                writer.writeNext(row);
            }
        } catch (IOException e) {
            throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e, this.action);
        }
    }


    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class QueryOutput {
        private String rootPipelineId;
        private Integer groupId;
        private Integer tenantId;
        private String sorContainerName;
        private String documentId;
        private String fileName;
        private String originId;
        private Integer paperNo;
        private String extractedMetaDetail;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class DecryptedCsvData {
        private String rootPipelineId;
        private Integer groupId;
        private Integer tenantId;
        private String sorContainerName;
        private String fileName;
        private String originId;
        private Integer paperNo;
        private String sorItemName;
        private String documentId;
        private String extractedValue;
        private String policyName;
    }


    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class extractedMetaDetail {

        String value;
        String policy;
        String key;
        Boolean isEncrypted;
    }
}
