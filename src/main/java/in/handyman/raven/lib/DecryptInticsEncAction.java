package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.opencsv.CSVWriter;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.encryption.protegrity.api.ProtegrityApiRequest;
import in.handyman.raven.lib.model.DecryptInticsEnc;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "DecryptInticsEnc"
)
public class DecryptInticsEncAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final DecryptInticsEnc decryptInticsEnc;
    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();
    private static final String CSV_HEADER[] = {"RootPipelineId", "GroupId", "TenantId", "SorContainerName", "FileName", "OriginId", "PaperNo", "SorItemName", "ExtractedValue", "PolicyName"};
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private final Marker aMarker;


    public DecryptInticsEncAction(final ActionExecutionAudit action, final Logger log,
                                  final Object decryptInticsEnc) {
        this.decryptInticsEnc = (DecryptInticsEnc) decryptInticsEnc;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" DecryptInticsEnc:" + this.decryptInticsEnc.getName());
    }

    @Override
    public void execute() throws Exception {

        try {
            log.info(aMarker, "Starting decryption API caller: {}", decryptInticsEnc.getName());
          String headersListStr = action.getContext().get("csv.headers.list");

            Path outputFilePath = createOutputFilePath();

            List<String> headersList = Arrays.asList(headersListStr.split(","));

            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(decryptInticsEnc.getSource());
            List<QueryOutput> queryResults = fetchQueryResults(jdbi);

            List<DecryptedCsvData> csvInputData = new ArrayList<>();
            if ("true".equals(action.getContext().get("pipeline.end.to.end.encryption"))) {
                List<DecryptedCsvData> decryptedData = processDecryption(queryResults);
                csvInputData.addAll(decryptedData);
            } else {
                List<DecryptedCsvData> decryptedData = processWithoutDecryption(queryResults);
                csvInputData.addAll(decryptedData);
            }


            writeToCsv5(csvInputData, headersList, outputFilePath.toString());


        } catch (Exception e) {
            log.error(aMarker, "Error executing DecryptInticsEncAction: {}", e.getMessage(), e);
            throw new HandymanException("Error executing DecryptInticsEncAction ", e,action);
        }
    }


    public Path createOutputFilePath() {
        try {
            // Get base directory path
            String targetDirectoryPath = action.getContext().get("target_directory_path");

            // Define the decrypted CSV directory path
            Path folderPath = Paths.get(targetDirectoryPath, "decrypted-csv");

            // Create directory if it does not exist
            Files.createDirectories(folderPath);

            // Get the CSV file name from decryptInticsEnc
            String fileName = decryptInticsEnc.getOutputPath();

            // Combine directory with the CSV file name
            Path filePath = folderPath.resolve(fileName);

            return filePath; // Return the full file path
        } catch (IOException e) {
            throw new HandymanException("Failed to create directory or file path: " + e.getMessage(), e,action);
        }
    }


    private List<QueryOutput> fetchQueryResults(Jdbi jdbi) {
        List<QueryOutput> results = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            List<String> formattedQueries = CommonQueryUtil.getFormattedQuery(decryptInticsEnc.getQuerySet());
            AtomicInteger queryIndex = new AtomicInteger(0);
            formattedQueries.forEach(sql -> {
                log.info(aMarker, "Executing query [{}]: {}", queryIndex.getAndIncrement(), sql);
                Query query = handle.createQuery(sql);
                results.addAll(query.mapToBean(QueryOutput.class).stream().collect(Collectors.toList()));
            });
        });
        return results;

    }


    @Override
    public boolean executeIf() throws Exception {
        return decryptInticsEnc.getCondition();
    }

    private List<DecryptedCsvData> processWithoutDecryption(List<QueryOutput> queryResults) {
        List<DecryptedCsvData> outputData = new ArrayList<>();
        queryResults.forEach(queryOutput -> {
            try {
                List<extractedMetaDetail> apiRequests = OBJECT_MAPPER.readValue(queryOutput.getExtractedMetaDetail(), new TypeReference<>() {
                });
                apiRequests.forEach(extractedMetaDetail -> outputData.add(DecryptedCsvData.builder()
                        .groupId(queryOutput.getGroupId())
                        .paperNo(queryOutput.getPaperNo())
                        .tenantId(queryOutput.getTenantId())
                        .rootPipelineId(queryOutput.getRootPipelineId())
                        .extractedValue(extractedMetaDetail.getValue())
                        .fileName(queryOutput.getFileName())
                        .policyName(extractedMetaDetail.getPolicy())
                        .sorContainerName(queryOutput.getSorContainerName())
                        .sorItemName(extractedMetaDetail.getKey())
                        .documentId(queryOutput.getDocumentId())
                        .originId(queryOutput.getOriginId())
                        .build()
                ));
            } catch (JsonProcessingException e) {
                throw new HandymanException("Json processing of the meta details got error ",e,action);
            }
        });
        return outputData;
    }

    private List<DecryptedCsvData> processDecryption(List<QueryOutput> queryResults) {
        List<DecryptedCsvData> outputData = new ArrayList<>();

        for (QueryOutput queryOutput : queryResults) {
            try {

                List<extractedMetaDetail> apiRequests = OBJECT_MAPPER.readValue(queryOutput.getExtractedMetaDetail(), new TypeReference<>() {
                });
                List<extractedMetaDetail> encryptedList = apiRequests.stream()
                        .filter(extractedMetaDetail::getIsEncrypted)
                        .collect(Collectors.toList());

                List<extractedMetaDetail> nonEncryptedList = apiRequests.stream()
                        .filter(request -> Boolean.FALSE.equals(request.getIsEncrypted()))
                        .collect(Collectors.toList());

                String jsonPayload = OBJECT_MAPPER.writeValueAsString(encryptedList);
                RequestBody body = RequestBody.create(jsonPayload, MediaType.get("application/json"));


                Request request = new Request.Builder().url(decryptInticsEnc.getEndpoint()).post(body).build();

                try (Response response = HTTP_CLIENT.newCall(request).execute()) {
                    if (!response.isSuccessful()) {
                        throw new HandymanException("Protegrity API error: " + response.message(),new HandymanException(response.message()),action);
                    }
                    List<ProtegrityApiRequest> apiResponses = OBJECT_MAPPER.readValue(response.body().string(), new TypeReference<>() {
                    });

                    apiResponses.forEach(apiResponse -> outputData.add(
                            DecryptedCsvData.builder()
                                    .rootPipelineId(queryOutput.getRootPipelineId())
                                    .groupId(queryOutput.getGroupId())
                                    .tenantId(queryOutput.getTenantId())
                                    .sorContainerName(queryOutput.getSorContainerName())
                                    .fileName(queryOutput.getFileName())
                                    .originId(queryOutput.getOriginId())
                                    .documentId(queryOutput.getDocumentId())
                                    .paperNo(queryOutput.getPaperNo())
                                    .sorItemName(apiResponse.getKey())
                                    .extractedValue(apiResponse.getValue())
                                    .policyName(apiResponse.getPolicy())
                                    .build()
                    ));

                    nonEncryptedList.forEach(extractedMetaDetail -> {
                        outputData.add(DecryptedCsvData.builder()
                                .rootPipelineId(queryOutput.getRootPipelineId())
                                .groupId(queryOutput.getGroupId())
                                .tenantId(queryOutput.getTenantId())
                                .sorContainerName(queryOutput.getSorContainerName())
                                .fileName(queryOutput.getFileName())
                                .originId(queryOutput.getOriginId())
                                .documentId(queryOutput.getDocumentId())
                                .paperNo(queryOutput.getPaperNo())
                                .sorItemName(extractedMetaDetail.getKey())
                                .extractedValue(extractedMetaDetail.getValue())
                                .policyName(extractedMetaDetail.getPolicy())
                                .build());
                    });
                }


            } catch (IOException e) {
                log.error("Error calling Protegrity API for container {}: {}", queryOutput.getSorContainerName(), e.getMessage(), e);
                throw new HandymanException("Error calling Protegrity API: " + e.getMessage(), e);
            }


        }
        return outputData;
    }

    private static void writeToCsv(List<DecryptedCsvData> dataList, String filePath) {
        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            writer.writeNext(CSV_HEADER);
            dataList.forEach(data -> writer.writeNext(new String[]{
                    data.getRootPipelineId(),
                    data.getGroupId() != null ? data.getGroupId().toString() : "",
                    data.getTenantId() != null ? data.getTenantId().toString() : "",
                    data.getSorContainerName(),
                    data.getFileName(),
                    data.getOriginId(),
                    data.getPaperNo() != null ? data.getPaperNo().toString() : "",
                    data.getSorItemName(),
                    data.getExtractedValue(),
                    data.getPolicyName()
            }));
        } catch (IOException e) {
            throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e);
        }
    }


    public static void writeCsv(List<Map<String, String>> dataList, String filePath) {
        if (dataList.isEmpty()) {
            return;
        }

        // Extract headers (unique keys from all maps)
        Set<String> headersSet = new LinkedHashSet<>();
        for (Map<String, String> data : dataList) {
            headersSet.addAll(data.keySet()); // Collect all keys
        }
        List<String> headers = new ArrayList<>(headersSet); // Convert to ordered list

        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            // Write headers
            writer.writeNext(headers.toArray(new String[0]));

            // Write rows
            for (Map<String, String> data : dataList) {
                String[] row = headers.stream()
                        .map(header -> data.getOrDefault(header, "")) // Get value or empty string
                        .toArray(String[]::new);
                writer.writeNext(row);
            }


        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void writeToCsvWithHeaders(List<DecryptedCsvData> dataList, String filePath) {
        try {
            // Step 1: Extract unique sorItemNames (these will be dynamic headers)
            Set<String> dynamicHeaders = dataList.stream()
                    .map(DecryptedCsvData::getSorItemName)
                    .collect(Collectors.toSet());

            // Step 2: Sort headers for consistency
            List<String> sortedDynamicHeaders = new ArrayList<>(dynamicHeaders);
            Collections.sort(sortedDynamicHeaders);

            // Step 3: Define static headers (RootPipelineId, FileName)
            List<String> csvHeaders = new ArrayList<>();
            csvHeaders.add("RootPipelineId");
            csvHeaders.add("FileName");
            csvHeaders.addAll(sortedDynamicHeaders); // Add dynamic headers

            try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
                // Step 4: Write the header row (first row)
                writer.writeNext(csvHeaders.toArray(new String[0]));

                // Step 5: Prepare the data row (second row)
                List<String> row = new ArrayList<>();

                // Assume all records belong to the same RootPipelineId and FileName
                if (!dataList.isEmpty()) {
                    DecryptedCsvData firstRecord = dataList.get(0);
                    row.add(firstRecord.getRootPipelineId());
                    row.add(firstRecord.getFileName());
                } else {
                    row.add(""); // Empty RootPipelineId if no data
                    row.add(""); // Empty FileName if no data
                }

                // Create a map of sorItemName -> extractedValue for quick lookup
                Map<String, String> valueMap = dataList.stream()
                        .collect(Collectors.toMap(DecryptedCsvData::getSorItemName, DecryptedCsvData::getExtractedValue, (v1, v2) -> v1));

                // Fill the row with extracted values matching the dynamic headers
                for (String header : sortedDynamicHeaders) {
                    row.add(valueMap.getOrDefault(header, "")); // Fill missing values with empty string
                }

                // Step 6: Write the single row of data
                writer.writeNext(row.toArray(new String[0]));
            }
        } catch (IOException e) {
            throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e, this.action);
        }
    }

    private void writeToCsv5(List<DecryptedCsvData> dataList, List<String> headers, String filePath) {

        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            log.info("File will be stored in this path {}", filePath);
            // Write headers
            writer.writeNext(headers.toArray(new String[0]));

            // Group data by filename to create one row per file
            Map<String, Map<String, String>> groupedData = new HashMap<>();

            for (DecryptedCsvData data : dataList) {
                // Create a unique key for each record
                String recordKey = data.getFileName();

                // Get or create the map for this record
                Map<String, String> record = groupedData.computeIfAbsent(recordKey, k -> new HashMap<>());

                // Set the filename field for each record
                record.put("file_name", data.getFileName());
                record.put("document_id", data.getDocumentId());

                // Map the sorItemName directly to the matching header
                String sorItemName = data.getSorItemName();
                String extractedValue = data.getExtractedValue();

                // Only set the value if the sorItemName matches one of our headers
                if (headers.contains(sorItemName)) {
                    record.put(sorItemName, extractedValue);
                }
            }

            // Write each record to the CSV
            for (Map<String, String> record : groupedData.values()) {
                String[] row = new String[headers.size()];

                // For each header, get the corresponding value from the record map
                for (int i = 0; i < headers.size(); i++) {
                    String header = headers.get(i);
                    row[i] = record.getOrDefault(header, ""); // Use empty string if value not found
                }

                writer.writeNext(row);
            }
        } catch (IOException e) {
            throw new HandymanException("Error writing to CSV file: " + e.getMessage(), e, this.action);
        }
    }

    public static void writeToCsvWithHeaders(List<DecryptedCsvData> dataList, List<String> headers, String filePath) {
        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            // Write headers
            writer.writeNext(headers.toArray(new String[0]));

            // Create a map of filename -> (sorItemName -> extractedValue)
            Map<String, Map<String, String>> fileDataMap = dataList.stream()
                    .collect(Collectors.groupingBy(
                            DecryptedCsvData::getFileName,
                            Collectors.toMap(DecryptedCsvData::getSorItemName, DecryptedCsvData::getExtractedValue, (v1, v2) -> v1)
                    ));

            // Iterate over fileDataMap and write to CSV
            for (Map.Entry<String, Map<String, String>> fileEntry : fileDataMap.entrySet()) {
                String fileName = fileEntry.getKey();
                Map<String, String> sorItemMap = fileEntry.getValue();

                int headersListSize = headers.size() + 1;
                String[] row = new String[headersListSize];
                row[0] = fileName; // Set the file name

                // Match headers with sorItemName and fetch values
                for (int i = 2; i < headersListSize; i++) {
                    row[i] = sorItemMap.getOrDefault(headers.get(i), "");
                }

                writer.writeNext(row);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void writeToCsv1(List<DecryptedCsvData> dataList, String filePath) {
        // Extract unique sorItemNames for headers and include "fileName" as the first column
        Set<String> sorItemNames = dataList.stream()
                .map(DecryptedCsvData::getSorItemName)
                .collect(Collectors.toSet());

        List<String> headers = List.of("fileName");
        headers.addAll(sorItemNames);

        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            // Write headers
            writer.writeNext(headers.toArray(new String[0]));

            // Group data by fileName
            Map<String, Map<String, String>> fileDataMap = dataList.stream()
                    .collect(Collectors.groupingBy(
                            DecryptedCsvData::getFileName,
                            Collectors.toMap(DecryptedCsvData::getSorItemName, DecryptedCsvData::getExtractedValue, (v1, v2) -> v1)
                    ));

            // Iterate over fileDataMap and write rows
            for (Map.Entry<String, Map<String, String>> fileEntry : fileDataMap.entrySet()) {
                String fileName = fileEntry.getKey();
                Map<String, String> sorItemMap = fileEntry.getValue();

                String[] row = new String[headers.size()];
                row[0] = fileName; // Set the file name

                // Match headers with sorItemName and fetch values
                for (int i = 1; i < headers.size(); i++) {
                    row[i] = sorItemMap.getOrDefault(headers.get(i), "");
                }

                writer.writeNext(row);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class QueryOutput {
        private String rootPipelineId;
        private Integer groupId;
        private Integer tenantId;
        private String sorContainerName;
        private String documentId;
        private String fileName;
        private String originId;
        private Integer paperNo;
        private String extractedMetaDetail;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class DecryptedCsvData {
        private String rootPipelineId;
        private Integer groupId;
        private Integer tenantId;
        private String sorContainerName;
        private String fileName;
        private String originId;
        private Integer paperNo;
        private String sorItemName;
        private String documentId;
        private String extractedValue;
        private String policyName;
    }


    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class extractedMetaDetail {

        String value;
        String policy;
        String key;
        Boolean isEncrypted;
    }
}
