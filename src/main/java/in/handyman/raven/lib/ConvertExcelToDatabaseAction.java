package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ConvertExcelToDatabase;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.ExceptionUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.io.FilenameUtils;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import static java.lang.Math.random;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ConvertExcelToDatabase"
)
public class ConvertExcelToDatabaseAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final ConvertExcelToDatabase convertExcelToDatabase;

  private final Marker aMarker;

  private final String SCHEMA_NAME="meta_bootstraping";

  public ConvertExcelToDatabaseAction(final ActionExecutionAudit action, final Logger log,
                                      final Object convertExcelToDatabase) {
    this.convertExcelToDatabase = (ConvertExcelToDatabase) convertExcelToDatabase;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" ConvertExcelToDatabase:"+this.convertExcelToDatabase.getName());
  }

  @Override
  public void execute() throws Exception {


    log.info(aMarker, "Convert excel to database Action for {} has been started", convertExcelToDatabase.getName());

    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(convertExcelToDatabase.getResourceConn());
    final Jdbi targetJdbi = ResourceAccess.rdbmsJDBIConn(convertExcelToDatabase.getTargetConn());

    final List<QueryResult> tableInfos = new ArrayList<>();

    jdbi.useTransaction(handle -> {
      final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(convertExcelToDatabase.getQuerySet());
      AtomicInteger i = new AtomicInteger(0);
      formattedQuery.forEach(sqlToExecute -> {
        log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
        Query query = handle.createQuery(sqlToExecute);
        ResultIterable<QueryResult> resultIterable = query.mapToBean(QueryResult.class);
        List<QueryResult> detailList = resultIterable.stream().collect(Collectors.toList());
        tableInfos.addAll(detailList);
        log.info(aMarker, "executed query from index {}", i.get());
      });
    });

    log.info("number of rows returned from query set {}",tableInfos.size());

    tableInfos.forEach(queryResult -> {
      List<Path> pathList=readExcelFolder(queryResult.getFilePath());
      pathList.forEach(path -> {
        excelToDatabase(targetJdbi,path.toString(),generateTableName(path.toFile(),queryResult.getRootPipelineId()));
      });
    });


  }


  public List<Path> readExcelFolder(String filePathString){
    List<Path> pathList = new ArrayList<>();

    try (var files = Files.walk(Path.of(filePathString)).filter(Files::isRegularFile)) {
      log.info(aMarker, "Iterating each file in directory {}", files);
      files.forEach(pathList::add);
    } catch (IOException e) {
      log.error(aMarker, "Exception occurred in directory iteration {}", ExceptionUtil.toString(e));
      throw new HandymanException("Exception occurred in directory iteration", e, action);
    }

    return pathList;
  }

  public String generateTableName(File file,String rootPipelineId){
    String fileName= FilenameUtils.removeExtension(file.getName().replace("-","_")) + "_" + rootPipelineId;
    String schemaName =SCHEMA_NAME+"."+fileName;

    return schemaName;
  }
  public void excelToDatabase(Jdbi targetJdbi,String excelFilePath,String tableName){
//    // Excel file path
//    String excelFilePath = "/home/anandh.andrews@zucisystems.com/Documents/import_csv_data_qn_202403211218.xlsx";
//    String tableName = "excel_data";
//    String targetDatabase="intics_zio_db_conn";

    try {
      // Load Excel workbook
      FileInputStream fis = new FileInputStream(excelFilePath);
      Workbook workbook = new XSSFWorkbook(fis);
      Sheet sheet = workbook.getSheetAt(0); // Assuming data is in the first sheet

      // Database connection details
//      Jdbi targetJdbi =  ResourceAccess.rdbmsJDBIConn(targetDatabase);

      StringBuilder createTableQuery = new StringBuilder("CREATE TABLE IF NOT EXISTS ")
              .append(tableName)
              .append(" (");

      Row headerRow = sheet.getRow(0);
      for (int i = 0; i < headerRow.getLastCellNum(); i++) {
        String columnName = headerRow.getCell(i).getStringCellValue();
        createTableQuery.append(columnName).append(" TEXT");
        if (i < headerRow.getLastCellNum() - 1) {
          createTableQuery.append(", ");
        }
      }
      createTableQuery.append(")");

      targetJdbi.useHandle(handle -> handle.execute(createTableQuery.toString()));

      // Insert data into the database table
      String insertQuery = "INSERT INTO " + tableName + " VALUES (";

      for (Row row : sheet) {
        if (row.getRowNum() == 0) continue; // Skip header row

        StringBuilder values = new StringBuilder();
        for (int i = 0; i < row.getLastCellNum(); i++) {
          Cell cell = row.getCell(i);
          String cellValue = (cell == null) ? "" : cell.toString();
          values.append("'").append(cellValue).append("'");
          if (i < row.getLastCellNum() - 1) {
            values.append(", ");
          }
        }

        String fullInsertQuery = insertQuery + values + ")";
        targetJdbi.useHandle(handle -> {
          int i=handle.execute(fullInsertQuery);

          log.info("handle executor i {}",i);
        });

        log.info("insert into the database insert query {}",fullInsertQuery);
      }

      log.info("Excel data imported into PostgreSQL table successfully.");
    } catch (IOException e) {
      HandymanException.insertException("Error in file reading for load the excel",new HandymanException(e),action);

    }

  }



  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class QueryResult {
    private int migrationId;
    private Long tenantId;
    private Long groupId;
    private String filePath;
    private String rootPipelineId;
  }

  @Override
  public boolean executeIf() throws Exception {
    return convertExcelToDatabase.getCondition();
  }
}
