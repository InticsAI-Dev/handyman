package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.Intellimatch;

import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.ExceptionUtil;
import in.handyman.raven.util.InstanceUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.*;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "Intellimatch"
)
public class IntellimatchAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final Intellimatch intellimatch;
    final String URI;
    private final Marker aMarker;
    final ObjectMapper MAPPER;
    final OkHttpClient httpclient;
    private static final MediaType MediaTypeJSON = MediaType.parse("application/json; charset=utf-8");

    private final Integer writeBatchSize = 1000;

    public IntellimatchAction(final ActionExecutionAudit action, final Logger log,
                              final Object intellimatch) {
        this.intellimatch = (Intellimatch) intellimatch;
        this.action = action;
        this.log = log;
        this.URI = action.getContext().get("copro.intelli-match.url");
        this.MAPPER = new ObjectMapper();
        this.httpclient = InstanceUtil.createOkHttpClient();
        this.aMarker = MarkerFactory.getMarker(" Intellimatch:" + this.intellimatch.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            log.info(aMarker, "intelli match process for {} has been started", intellimatch.getName());
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(intellimatch.getResourceConn());

            final List<MatchResultSet> inputResult = new ArrayList<>();
            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(intellimatch.getInputSet());
                AtomicInteger i = new AtomicInteger(0);
                formattedQuery.forEach(sqlToExecute -> {
                    log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                    Query query = handle.createQuery(sqlToExecute);
                    ResultIterable<MatchResultSet> resultIterable = query.mapToBean(MatchResultSet.class);
                    List<MatchResultSet> detailList = resultIterable.stream().collect(Collectors.toList());
                    inputResult.addAll(detailList);
                    log.info(aMarker, "executed query from index {}", i.get());
                });
            });

            List<MatchResultSet> resultQueue = new ArrayList<>();
            inputResult.forEach(result -> {
                if (result.getActualValue() != null) {
                    final ObjectNode objectNode = MAPPER.createObjectNode();
                    List<String> comparableSentence = Collections.singletonList(result.getExtractedValue());
                    objectNode.put("inputSentence", result.getActualValue());
                    objectNode.putPOJO("sentences", comparableSentence);
                    final Request request = new Request.Builder().url(URI)
                            .post(RequestBody.create(objectNode.toString(), MediaTypeJSON)).build();
                    try (Response response = httpclient.newCall(request).execute()) {
                        String responseBody = Objects.requireNonNull(response.body()).string();
                        if (response.isSuccessful()) {
                            List<IntelliMatchCopro> output = MAPPER.readValue(responseBody, new TypeReference<>() {
                            });
                            double matchPercent = output.get(0) != null ? Math.round(output.get(0).getSimilarityPercent() * 100.0) / 100.0 : 0.0;
                            result.setIntelliMatch(matchPercent);
                            resultQueue.add(result);

                        } else {
                            insertSummaryAudit(jdbi, 0, 0, 1, "failed on" + result.getFileName());
                            log.error(aMarker, "Error in response {}", responseBody);
                            throw new HandymanException(responseBody);
                        }
                    } catch (Exception exception) {
                        log.error(aMarker, "error inserting row {}", result, exception);
                        HandymanException handymanException = new HandymanException(exception);
                        HandymanException.insertException("Intelli match consumer failed", handymanException, this.action);
                    }
                } else {
                    result.setIntelliMatch(0);
                    resultQueue.add(result);
                }
                if (resultQueue.size() == this.writeBatchSize) {
                    log.info(aMarker, "executing  batch {}", resultQueue.size());
                    consumerBatch(jdbi, resultQueue);
                    log.info(aMarker, "executed  batch {}", resultQueue.size());
                    insertSummaryAudit(jdbi, inputResult.size(), resultQueue.size(), 0, "batch inserted");
                    resultQueue.clear();
                    log.info(aMarker, "cleared batch {}", resultQueue.size());
                }
            });

            if (!resultQueue.isEmpty()) {
                log.info(aMarker, "executing final batch {}", resultQueue.size());
                consumerBatch(jdbi, resultQueue);
                log.info(aMarker, "executed final batch {}", resultQueue.size());
                insertSummaryAudit(jdbi, inputResult.size(), resultQueue.size(), 0, "final batch inserted");
                resultQueue.clear();
                log.info(aMarker, "cleared final batch {}", resultQueue.size());
            }
        } catch (Exception exception) {
            log.error(aMarker, "Error in intellimatch action", ExceptionUtil.toString(exception));
            throw new HandymanException("Error in intellimatch action", exception, action);
        }
    }


    void consumerBatch(final Jdbi jdbi, List<MatchResultSet> resultQueue) {
        try {
            resultQueue.forEach(insert -> {
                        jdbi.useTransaction(handle -> {
                            try {
                                Update update = handle.createUpdate(" INSERT INTO " + intellimatch.getMatchResult() +
                                        " ( file_name, created_on, actual_value, extracted_value, similarity, levenshtein, perfect_match, text_match, intelli_match)" +
                                        " VALUES( :fileName, NOW(), :actualValue, :extractedValue,  " +
                                        " similarity(lower(:actualValue),:extractedValue), " +
                                        " levenshtein(:actualValue,:extractedValue), " +
                                        " (CASE WHEN lower(:actualValue)=:extractedValue THEN 'yes' ELSE 'no' end ), " +
                                        " (CASE WHEN lower(:actualValue) like concat('%',:extractedValue,'%') THEN 'yes'" +
                                        "                       WHEN lower(:actualValue) = :extractedValue THEN 'yes' ELSE 'no' end)," +
                                        "  :intelliMatch )");
                                Update bindBean = update.bindBean(insert);
                                bindBean.execute();
                            } catch (Exception exception) {
                                insertSummaryAudit(jdbi, 0, 0, 1, "failed in bactch for " + insert.getFileName());
                                log.error(aMarker, "error inserting result {}", resultQueue, exception);
                                HandymanException handymanException = new HandymanException(exception);
                                HandymanException.insertException("Intellimatch consumer failed", handymanException, this.action);
                            }
                        });
                    }
            );
        } catch (Exception exception) {
            insertSummaryAudit(jdbi, 0, 0, resultQueue.size(), "failed in batch insert");
            log.error(aMarker, "error inserting result {}", resultQueue, exception);
            HandymanException handymanException = new HandymanException(exception);
            HandymanException.insertException("Error in inserting Intellimatch result table", handymanException, this.action);
        }
    }

    void insertSummaryAudit(final Jdbi jdbi, int rowCount, int executeCount, int errorCount, String comments) {
        SanitarySummary summary = new SanitarySummary().builder()
                .rowCount(rowCount)
                .correctRowCount(executeCount)
                .errorRowCount(errorCount)
                .comments(comments)
                .build();
        jdbi.useTransaction(handle -> {
            Update update = handle.createUpdate("  INSERT INTO " + intellimatch.getAuditTable() +
                    " ( row_count, correct_row_count, error_row_count,comments, created_at) " +
                    " VALUES(:rowCount, :correctRowCount, :errorRowCount, :comments, NOW());");
            Update bindBean = update.bindBean(summary);
            bindBean.execute();
        });
    }

    @Override
    public boolean executeIf() throws Exception {
        return intellimatch.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class SanitarySummary {
        int rowCount;
        int correctRowCount;
        int errorRowCount;
        String comments;

    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class IntelliMatchCopro {
        String sentence;
        double similarityPercent;
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class MatchResultSet {

        String fileName;
        String actualValue;
        String extractedValue;
        double similarity;
        double levenshtein;
        String perfectMatch;
        String textMatch;
        double intelliMatch;
    }
}
