package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.TableExtraction;
import in.handyman.raven.lib.model.tableextraction.coproprocessor.TableExtractionConsumerProcess;
import in.handyman.raven.lib.model.tableextraction.coproprocessor.TableExtractionInputTable;
import in.handyman.raven.lib.model.tableextraction.coproprocessor.TableExtractionOutputTable;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Types;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "TableExtraction"
)
public class TableExtractionAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final TableExtraction tableExtraction;

    private final Marker aMarker;

    public TableExtractionAction(final ActionExecutionAudit action, final Logger log,
                                 final Object tableExtraction) {
        this.tableExtraction = (TableExtraction) tableExtraction;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" TableExtraction:" + this.tableExtraction.getName());
    }

    @Override
    public void execute() {
        try {
            log.info(aMarker, "Table Extraction Action has been started {}", tableExtraction);

            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(tableExtraction.getResourceConn());
            jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
            final String outputDir = Optional.ofNullable(tableExtraction.getOutputDir()).map(String::valueOf).orElse(null);
            log.info(aMarker, "Table Extraction Action output directory {}", outputDir);
            //5. build insert prepare statement with output table columns
            final String insertQuery = "INSERT INTO " + tableExtraction.getResultTable() +
                    "(origin_id,group_id,tenant_id,template_id,processed_file_path,paper_no, status,stage,message,created_on,process_id,root_pipeline_id,table_response, bboxes, croppedImage, model_name,batch_id) " +
                    " VALUES(?,?, ?,?, ?,?, ?,?,?,? ,?,  ?, ? , ?, ?,   ?,?)";
            log.info(aMarker, "table extraction Insert query {}", insertQuery);

            //3. initiate copro processor and copro urls
            final List<URL> urls = Optional.ofNullable(tableExtraction.getEndpoint()).map(s -> Arrays.stream(s.split(",")).map(s1 -> {
                try {
                    return new URL(s1);
                } catch (MalformedURLException e) {
                    log.error("Error in processing the URL ", e);
                    throw new HandymanException("Error in processing the URL", e, action);
                }
            }).collect(Collectors.toList())).orElse(Collections.emptyList());
            log.info(aMarker, "table extraction copro urls {}", urls);

            final CoproProcessor<TableExtractionInputTable, TableExtractionOutputTable> coproProcessor =
                    new CoproProcessor<>(new LinkedBlockingQueue<>(),
                            TableExtractionOutputTable.class,
                            TableExtractionInputTable.class,
                            tableExtraction.getResourceConn(), log,
                            new TableExtractionInputTable(), urls, action);

            log.info(aMarker, "table extraction copro coproProcessor initialization  {}", coproProcessor);

            //4. call the method start producer from coproprocessor
            coproProcessor.startProducer(tableExtraction.getQuerySet(), Integer.valueOf(action.getContext().get("read.batch.size")));
            log.info(aMarker, "table extraction copro coproProcessor startProducer called read batch size {}", action.getContext().get("read.batch.size"));
            Thread.sleep(1000);
            coproProcessor.startConsumer(insertQuery, Integer.valueOf(action.getContext().get("table.extraction.consumer.API.count")), Integer.valueOf(action.getContext().get("write.batch.size")), new TableExtractionConsumerProcess(log, aMarker, outputDir, action), true);
            log.info(aMarker, "table extraction copro coproProcessor startConsumer called consumer count {} write batch count {} ", Integer.valueOf(action.getContext().get("table.extraction.consumer.API.count")), Integer.valueOf(action.getContext().get("write.batch.size")));


        } catch (Exception ex) {
            log.error(aMarker, "error in execute method for table extraction  ", ex);
            throw new HandymanException("error in execute method for table extraction", ex, action);
        }
    }


//    private static void extractedOutputResponse(String responseParse, List<TableExtractionOutputTable> parentObj, String originId, Integer groupId, String templateId, Long tenantId, Long processId, String tableExtractionProcessName, Long rootPipelineId) {
//        JSONObject parentResponse = new JSONObject(responseParse);
//        JSONArray filePathArray = new JSONArray(parentResponse.get("csvTablesPath").toString());
//
//        //JSONArray tableResponseArray = new JSONArray(parentResponse.get("table_response").toString());
//        log.info(aMarker, "coproProcessor consumer process response body filePathArray {}", filePathArray);
//        filePathArray.forEach(s -> {
//            Map<String, Object> processedJsonNode;
//            try {
//                processedJsonNode = mapper.readValue(s.toString(), Map.class);
//            } catch (IOException e) {
//                throw new RuntimeException(e);
//            }
//            log.info(aMarker, "coproProcessor consumer process response body processedJsonNode {}", processedJsonNode);
//
//            processedJsonNode.forEach((schemaName, csvFilePathNode) -> {
//                try {
//                    log.info(aMarker, "coproProcessor consumer process response body scheme {} and csv file path {}", schemaName, csvFilePathNode);
//
//                    String csvJsonObject = tableDataJson(String.valueOf(csvFilePathNode),action);
//                    Long paperNo = getPaperNobyFileName(String.valueOf(csvFilePathNode));
//
//                    parentObj.add(
//                            TableExtractionOutputTable
//                                    .builder()
//                                    .processedFilePath(String.valueOf(s))
//                                    .originId(Optional.ofNullable(originId).map(String::valueOf).orElse(null))
//                                    .groupId(groupId)
//                                    .templateId(templateId)
//                                    .tenantId(tenantId)
//                                    .processId(processId)
//                                    .paperNo(paperNo)
//                                    .status("COMPLETED")
//                                    .stage(tableExtractionProcessName)
//                                    .tableResponse(csvJsonObject)
//                                    .message("Table Extraction macro completed")
//                                    .createdOn(Timestamp.valueOf(LocalDateTime.now()))
//                                    .rootPipelineId(rootPipelineId)
//                                    .build());
//                } catch (JsonProcessingException e) {
//                    throw new RuntimeException(e);
//                }
//            });
//        });
//    }

    @Override
    public boolean executeIf() throws Exception {
        return tableExtraction.getCondition();
    }


}
