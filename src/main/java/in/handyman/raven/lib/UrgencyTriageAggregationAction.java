package in.handyman.raven.lib;

import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.UrgencyTriageAggregation;

import java.io.*;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.File;
import org.apache.commons.io.FilenameUtils;

import org.apache.xmlbeans.impl.xb.xsdschema.Public;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "UrgencyTriageAggregation"
)
public class UrgencyTriageAggregationAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final UrgencyTriageAggregation urgencyTriageAggregation;

  private final Marker aMarker;

  public UrgencyTriageAggregationAction(final ActionExecutionAudit action, final Logger log,
      final Object urgencyTriageAggregation) {
    this.urgencyTriageAggregation = (UrgencyTriageAggregation) urgencyTriageAggregation;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" UrgencyTriageAggregation:"+this.urgencyTriageAggregation.getName());
  }

  @Override
  public void execute() throws Exception {
    String inputFilePath = urgencyTriageAggregation.getInputDir();
    String outputFilePath = urgencyTriageAggregation.getOutputDir();
    Float ratio = java.lang.Float.valueOf(action.getContext().get("ratio"));

    File file = new File(inputFilePath);
    if (file.isDirectory() && !inputFilePath.isEmpty()){
      List<String> csvFilePaths = getAllCSVPaths(inputFilePath);

      for (String input: csvFilePaths) {
        List<Map<String, String>> paperResults = readCSV(input);
        Map<String, List<Map<String, String>>> groupedResults = groupByFileName(paperResults);
        Map<String, Map<String, String>> urgencyConfidence = calculateUrgencyConfidence(groupedResults, ratio);

        String fileNameWithoutExtension = FilenameUtils.getBaseName(input);
        String outputFile = outputFilePath+fileNameWithoutExtension;
        writeCSV(outputFile, urgencyConfidence);

        System.out.println("Updated CSV file saved to: " + outputFilePath);
    }
      } else if (file.isFile() && !inputFilePath.isEmpty()) {
      List<Map<String, String>> paperResults = readCSV(inputFilePath);
      Map<String, List<Map<String, String>>> groupedResults = groupByFileName(paperResults);
      Map<String, Map<String, String>> urgencyConfidence = calculateUrgencyConfidence(groupedResults, ratio);
      String fileNameWithoutExtension = FilenameUtils.getBaseName(inputFilePath);
      String outputFile = outputFilePath+fileNameWithoutExtension;
      writeCSV(outputFile, urgencyConfidence);
      System.out.println("Updated CSV file saved to: " + outputFilePath);


    }

  }


  public static List<String> getAllCSVPaths(String directoryPath) {
    List<String> csvPaths = new ArrayList<>();
    File directory = new File(directoryPath);

    if (directory.isDirectory()) {
      File[] files = directory.listFiles();
      if (files != null) {
        for (File file : files) {
          if (file.isDirectory()) {
            csvPaths.addAll(getAllCSVPaths(file.getAbsolutePath()));  // Recursively add CSV paths from subdirectories
          } else if (file.isFile() && file.getName().toLowerCase().endsWith(".csv")) {
            csvPaths.add(file.getAbsolutePath());  // Add CSV file path
          }
        }
      }
    } else {
      System.out.println(directoryPath + " is not a directory.");
    }

    return csvPaths;
  }
  public static List<Map<String, String>> readCSV(String filePath) {
    List<Map<String, String>> paperResults = new ArrayList<>();
    try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
      String line = br.readLine(); // Skip the header
      while ((line = br.readLine()) != null) {
        String[] values = line.split(",");
        Map<String, String> paper = new HashMap<>();
        paper.put("file_name", values[0]);
        paper.put("paper_no", values[2]);
        paper.put("urgency_result", values[4]);
        paper.put("truth", values[6]);
        paperResults.add(paper);
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
      return paperResults;
  }

  public static Map<String, List<Map<String, String>>> groupByFileName(List<Map<String, String>> paperResults) {
    Map<String, List<Map<String, String>>> groupedResults = new HashMap<>();
    for (Map<String, String> item : paperResults) {
      String fileName = item.get("file_name");
      if (!groupedResults.containsKey(fileName)) {
        groupedResults.put(fileName, new ArrayList<>());
      }
      groupedResults.get(fileName).add(item);
    }
    return groupedResults;
  }

  public static Map<String, Map<String, String>> calculateUrgencyConfidence(Map<String, List<Map<String, String>>> groupedResults, Float ratio) {
    Map<String, Map<String, String>> urgencyConfidence = new HashMap<>();
    for (String fileName : groupedResults.keySet()) {
      List<Map<String, String>> paperResults = groupedResults.get(fileName);
      Map<String, String> result = determineDocumentUrgency(paperResults, ratio);
      urgencyConfidence.put(fileName, result);
    }
    return urgencyConfidence;
  }

  public static Map<String, String> determineDocumentUrgency(List<Map<String, String>> paperResults, Float ratio) {
    int paperCount = paperResults.size();
    String urgency = "NON-URGENT";
    Double confidence = null;

    if (paperCount <= 5) {
      for (Map<String, String> paper : paperResults) {
        if (paper.get("urgency_result").equalsIgnoreCase("URGENT")) {
          urgency = "URGENT";
          confidence = 90.00;
          break;
        }
      }
    } else {
//      double ratio = 0.40;
      int numPapers = paperResults.size();
      int numToSelect = Math.max(1, (int) (numPapers * ratio));
      List<Map<String, String>> firstRatioPapers = paperResults.subList(0, numToSelect);
      List<Map<String, String>> lastRatioPapers = paperResults.subList(firstRatioPapers.size(), numPapers);
      int lastRatio = (int) Math.round((double) lastRatioPapers.size() / 2);

      for (Map<String, String> paper : paperResults) {
        if (paper.get("truth").equalsIgnoreCase("yes") && paper.get("urgency_result").equalsIgnoreCase("URGENT")) {
          urgency = "URGENT";
          confidence = 99.00;
          return createUrgencyResult(urgency, confidence);
        }
      }

      if (!firstRatioPapers.isEmpty() && firstRatioPapers.get(0).get("urgency_result").equalsIgnoreCase("URGENT")) {
        confidence = calculateConfidence(1, firstRatioPapers.size());
        urgency = "URGENT";
        return createUrgencyResult(urgency, confidence);
      }

      for (int i = 0; i < firstRatioPapers.size(); i++) {
        Map<String, String> paper = firstRatioPapers.get(i);
        if (paper.get("urgency_result").equalsIgnoreCase("URGENT")) {
          confidence = calculateConfidence(i + 1, firstRatioPapers.size());
          urgency = "URGENT";
          return createUrgencyResult(urgency, confidence);
        }
      }

      long urgentCount = lastRatioPapers.stream().filter(paper -> paper.get("urgency_result").equalsIgnoreCase("URGENT")).count();
      if (urgentCount > lastRatio) {
        confidence = Math.min(70.0, 50.0 + ((double) urgentCount / numToSelect) * 20);
        urgency = "URGENT";
      }
    }

    return createUrgencyResult(urgency, confidence);
  }

  public static Map<String, String> createUrgencyResult(String urgency, Double confidence) {
    Map<String, String> result = new HashMap<>();
    result.put("final_urgency_result", urgency.toLowerCase());
    result.put("confidence", confidence != null ? String.format("%.2f", confidence) : null);
    return result;
  }

  public static double calculateConfidence(int index, int total) {
    return Math.max(50.0, 80.0 - ((double) index / total * 30));
  }

  public static void writeCSV(String filePath, Map<String, Map<String, String>> urgencyConfidence) {
    try (FileWriter writer = new FileWriter(filePath)) {
      writer.append("file_name,final_urgency_result,confidence\n");
      for (String fileName : urgencyConfidence.keySet()) {
        Map<String, String> result = urgencyConfidence.get(fileName);
        writer.append(fileName).append(",")
                .append(result.get("final_urgency_result")).append(",")
                .append(result.get("confidence") != null ? result.get("confidence") : "")
                .append("\n");
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }


  @Override
  public boolean executeIf() throws Exception {
    return urgencyTriageAggregation.getCondition();
  }
}
