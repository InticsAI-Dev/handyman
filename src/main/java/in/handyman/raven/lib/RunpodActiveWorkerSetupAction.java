package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.RunpodActiveWorkerSetup;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.*;

import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "RunpodActiveWorkerSetup"
)
public class RunpodActiveWorkerSetupAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final RunpodActiveWorkerSetup runpodActiveWorkerSetup;

  private final Marker aMarker;


//  private static final String BASE_URL = "https://rest.runpod.io/v1/endpoints";
  private static final String API_TOKEN = "runpod.bearer.token";
  private static final String TARGET_ENDPOINT_ID = "target.server.id";

  private static final String HTTP_GET = "GET";
  private static final String HTTP_POST = "POST";
  private static final String HTTP_PUT = "PUT";

  private static final String HEADER_AUTHORIZATION = "Authorization";
  private static final String HEADER_CONTENT_TYPE = "Content-Type";
  private static final String CONTENT_TYPE_JSON = "application/json";
  private static final String AUTH_BEARER_PREFIX = "Bearer ";

  private static final int REQUESTS_PER_WORKER = 8;

  private static final ObjectMapper objectMapper = new ObjectMapper();

  public RunpodActiveWorkerSetupAction(final ActionExecutionAudit action, final Logger log,
      final Object runpodActiveWorkerSetup) {
    this.runpodActiveWorkerSetup = (RunpodActiveWorkerSetup) runpodActiveWorkerSetup;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" RunpodActiveWorkerSetup:"+this.runpodActiveWorkerSetup.getName());
  }

  @Override
  public void execute() throws Exception {

    RunpodActiveWorkerSetupAction worker = new RunpodActiveWorkerSetupAction(action, log, runpodActiveWorkerSetup);
    String updateMethodName = "update";
    String updateUrl = runpodActiveWorkerSetup.getEndpoint() + "/" + action.getContext().get(TARGET_ENDPOINT_ID) + "/" + updateMethodName;
    Integer PAGE_COUNT = Integer.valueOf(runpodActiveWorkerSetup.getPapercount());
    try {
      ObjectNode endpointDetails = worker.getEndpointDetails(runpodActiveWorkerSetup.getEndpoint(), action.getContext().get(API_TOKEN), action.getContext().get(TARGET_ENDPOINT_ID));

      if (endpointDetails != null) {
        List<Integer> optimalWorkers = worker.calculateOptimalWorkers(endpointDetails, PAGE_COUNT);
        int workersMin = optimalWorkers.get(0);
        int workersMax = optimalWorkers.get(1);

        log.info("Calculated workersMin: " + workersMin + ", workersMax: " + workersMax);

        HttpURLConnection connection = prepApiRequest(updateUrl, HTTP_POST, action.getContext().get(API_TOKEN));
        Map<String, Object> payload = new HashMap<String, Object>();
        payload.put("workersMin", workersMin);
        payload.put("workersMax", workersMax);

        String jsonPayload = objectMapper.writeValueAsString(payload);
        StringBuilder response = worker.doApiCall(connection, jsonPayload);

        int responseCode = connection.getResponseCode();
        if (responseCode >= 200 && responseCode < 300) {
          log.info("Update successful: " + response);
        } else {
          log.info("Update failed with response code: " + responseCode + ". Response: " + response);
        }

      } else {
        log.info("Endpoint not found.");
      }

    } catch (Exception e) {
      log.info("Error during execution: " + e.getMessage());
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return runpodActiveWorkerSetup.getCondition();
  }


  public static HttpURLConnection prepApiRequest(String urlString, String method, String token) throws IOException, IOException {
    URL url = new URL(urlString);
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();

    connection.setRequestMethod(method);
    connection.setDoOutput(HTTP_POST.equalsIgnoreCase(method) || HTTP_PUT.equalsIgnoreCase(method));
    connection.setRequestProperty(HEADER_AUTHORIZATION, AUTH_BEARER_PREFIX + token);
    connection.setRequestProperty(HEADER_CONTENT_TYPE, CONTENT_TYPE_JSON);

    return connection;
  }

  public StringBuilder doApiCall(HttpURLConnection connection, String jsonPayload) throws IOException {
    if (jsonPayload != null && !jsonPayload.isEmpty()) {
      try (OutputStream os = connection.getOutputStream()) {
        byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
        os.write(input, 0, input.length);
      }
    }

    int responseCode = connection.getResponseCode();
    Scanner scanner = new Scanner(
            responseCode >= 200 && responseCode < 300 ?
                    connection.getInputStream() :
                    connection.getErrorStream(),
            StandardCharsets.UTF_8.name()
    );

    StringBuilder response = new StringBuilder();
    while (scanner.hasNextLine()) {
      response.append(scanner.nextLine());
    }
    scanner.close();

    log.info("HTTP Response Code: " + responseCode);
    return response;
  }


  public ObjectNode getEndpointDetails(String endpointsUrl, String token, String targetEndpointId) {
    try {
      HttpURLConnection connection = prepApiRequest(endpointsUrl, HTTP_GET, token);
      StringBuilder response = doApiCall(connection, null);

      JsonNode endpointsArray = objectMapper.readTree(response.toString());

      for (JsonNode endpoint : endpointsArray) {
        if (endpoint.get("id").asText().equals(targetEndpointId)) {
          return (ObjectNode) endpoint;
        }
      }
    } catch (Exception e) {
      log.info("Error fetching endpoint details: " + e.getMessage());
    }
    return null;
  }


  public List<Integer> calculateOptimalWorkers(ObjectNode endpointDetails, int pageCount) {
    if (endpointDetails == null) {
      log.info("No endpoint details provided");
      return Arrays.asList(0, 0);
    }

    int workersMax = endpointDetails.get("workersMax").asInt();
    int neededWorkers = (int) Math.ceil((double) pageCount / REQUESTS_PER_WORKER);
    int adjustedMaxWorkers = Math.max(neededWorkers, workersMax);

    return Arrays.asList(neededWorkers, adjustedMaxWorkers);
  }




}

