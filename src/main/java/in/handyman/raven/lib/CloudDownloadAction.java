package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.CloudDownload;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;

import in.handyman.raven.lib.model.cloudDownload.CloudDownloadInputTable;
import in.handyman.raven.lib.model.cloudDownload.CloudDownloadOutputTable;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.awscore.exception.AwsServiceException;
import software.amazon.awssdk.core.ResponseInputStream;
import software.amazon.awssdk.core.exception.SdkClientException;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.*;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.Objects;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "CloudDownload"
)
public class CloudDownloadAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final CloudDownload cloudDownload;

    private final Marker aMarker;

    public CloudDownloadAction(final ActionExecutionAudit action, final Logger log,
                               final Object cloudDownload) {
        this.cloudDownload = (CloudDownload) cloudDownload;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" CloudDownload:" + this.cloudDownload.getName());
    }

    @Override
    public void execute() throws Exception {

        log.info(aMarker, "cloud Action for {} has started", cloudDownload.getName());
        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(cloudDownload.getResourceConn());
        jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));

        CloudDownloadInputTable cloudDownloadInputTable = getInputTableFromQuerySet(cloudDownload.getQuerySet(), jdbi);
        String bucketName = cloudDownloadInputTable.getBucketName();
        ObjectMapper objectMapper = new ObjectMapper();
        String cloudDownloadRequestJson = objectMapper.writeValueAsString(cloudDownloadInputTable);
        final String localFilePath = action.getContext().get("localFilePath");
        final String tenantId = action.getContext().get("tenant_id");
        final Long rootPipelineId = Long.valueOf(action.getContext().get("rootPipelineId"));
        final String cloud = "CLOUD";
        final String active = "ACTIVE";
        final String completed = "COMPLETED";
        final String uploadTime = action.getContext().get("uploadTime");
        S3Client s3Client = null;
        try {
            Region region = Region.US_EAST_1; // Change to your desired region
            s3Client = S3Client.builder().region(region).build();

            ListObjectsV2Response listResponse = s3Client.listObjectsV2(ListObjectsV2Request.builder().bucket(bucketName).build());
            if (Objects.equals(uploadTime, "null")) {
                for (S3Object s3Object : listResponse.contents()) {
                    String objectKey = s3Object.key();

                    downloadFile(s3Client, bucketName, objectKey, Paths.get(localFilePath, objectKey));
                    CloudDownloadOutputTable cloudDownloadOutputTable = CloudDownloadOutputTable.builder()
                            .tenantId(Long.valueOf(tenantId))
                            .rootPipelineId(rootPipelineId) // Adjust as needed
                            .createdOn(LocalDateTime.now())
                            .createdUserId(Long.valueOf(tenantId)) // Set as needed
                            .lastUpdatedUserId(Long.valueOf(tenantId)) // Set as needed
                            .lastUpdatedOn(LocalDateTime.now())
                            .status(active) // Set the status as needed
                            .message("cloud download completed")
                            .type(cloud)
                            .info(cloudDownloadRequestJson)// Set as needed
                            .lastProcessedOn(LocalDateTime.now())
                            .localFilePath(localFilePath) // Set the https folder path
                            .version(1)
                            .executionStatus(completed)
                            .build();
                    insertIntoOutputTable(jdbi, cloudDownloadOutputTable);
                }

            } else {
                if (!Objects.equals(uploadTime, "null")) ;
                for (S3Object s3Object : listResponse.contents()) {
                    String objectKey = s3Object.key();
                    downloadFile(s3Client, bucketName, objectKey, Paths.get(localFilePath, objectKey));

                    CloudDownloadOutputTable cloudDownloadOutputTable = CloudDownloadOutputTable.builder()
                            .tenantId(Long.valueOf(tenantId))
                            .rootPipelineId(rootPipelineId) // Adjust as needed
                            .createdOn(LocalDateTime.now())
                            .createdUserId(Long.valueOf(tenantId)) // Set as needed
                            .lastUpdatedUserId(Long.valueOf(tenantId)) // Set as needed
                            .lastUpdatedOn(LocalDateTime.now())
                            .status(active) // Set the status as needed
                            .message("cloud download completed")
                            .type(cloud)
                            .info(cloudDownloadRequestJson)// Set as needed
                            .lastProcessedOn(LocalDateTime.now())
                            .localFilePath(localFilePath) // Set the https folder path
                            .version(1)
                            .executionStatus(completed)
                            .build();
                    insertIntoOutputTable(jdbi, cloudDownloadOutputTable);
                }
            }

        } catch (Exception e) {
            log.error("An error occurred while interacting with AWS S3", e);
            CloudDownloadOutputTable cloudDownloadOutputTable = CloudDownloadOutputTable.builder()
                    .tenantId(Long.valueOf(tenantId))
                    .rootPipelineId(rootPipelineId) // Adjust as needed
                    .createdOn(LocalDateTime.now())
                    .createdUserId(Long.valueOf(tenantId)) // Set as needed
                    .lastUpdatedUserId(Long.valueOf(tenantId)) // Set as needed
                    .lastUpdatedOn(LocalDateTime.now())
                    .status(active) // Set the status as needed
                    .message(String.valueOf(e))
                    .type(cloud)
                    .info(cloudDownloadRequestJson)// Set as needed
                    .lastProcessedOn(LocalDateTime.now())
                    .localFilePath(localFilePath) // Set the https folder path
                    .version(1)
                    .executionStatus(completed)
                    .build();
            insertIntoOutputTable(jdbi, cloudDownloadOutputTable);
        }
        finally {
            if (s3Client != null) {
                s3Client.close();
            }
        }
    }


    private void downloadFile(S3Client s3Client, String bucketName, String objectKey, Path targetPath) throws IOException {
        GetObjectRequest getObjectRequest = GetObjectRequest.builder().bucket(bucketName).key(objectKey).build();

        try (ResponseInputStream<GetObjectResponse> objectResponse = s3Client.getObject(getObjectRequest);
             FileOutputStream fileOutputStream = new FileOutputStream(targetPath.toFile())) {

            byte[] buffer = new byte[1024];
            int bytesRead;

            while ((bytesRead = objectResponse.read(buffer)) != -1) {
                fileOutputStream.write(buffer, 0, bytesRead);
            }
            log.info("Downloaded files successfully");

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    private CloudDownloadInputTable getInputTableFromQuerySet(String querySet, Jdbi jdbi) {
        try (Handle handle = jdbi.open()) {
            return handle.createQuery(querySet)
                    .mapToBean(CloudDownloadInputTable.class)
                    .one();
        }
    }


    private void insertIntoOutputTable(Jdbi jdbi, CloudDownloadOutputTable cloudDownloadOutputTable) {
        jdbi.useTransaction(handle -> {
            handle.createUpdate("INSERT INTO onboard_wizard_info.cloud_download_info\n" +
                            "                (created_on, created_user_id, last_updated_on, last_updated_user_id, status, version, local_directory_folder_path, execution_status, ftp_destination_file_Path, ftp_destination_base_path, info, last_processed_on, message, root_pipeline_id, tenant_id, type) " +
                            "VALUES( :createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :status, :version, :localDirectoryFolderPath, :executionStatus, :ftpDestinationFilePath::jsonb, :ftpDestinationBasePath, :info, :lastProcessedOn, :message, :rootPipelineId, :tenantId, :type);")
                    .bindBean(cloudDownloadOutputTable).execute();
            log.debug(aMarker, "inserted {} into cloud download info details", cloudDownloadOutputTable);
        });
    }



    @Override
  public boolean executeIf() throws Exception {
    return cloudDownload.getCondition();
  }
}
