package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.MultiValueMemberMapper;
import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.controldatacomaprison.ControlDataComparisonQueryInputTable;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "MultiValueMemberMapper"
)
public class MultiValueMemberMapperAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final MultiValueMemberMapper multiValueMemberMapper;

  private final Marker aMarker;

  private final String PROCESSING_SOR_ITEM_NAME = "multi.member.indicator.fields";

  private final String PIPELINE_END_TO_END_ENCRYPTION = "pipeline.end.to.end.encryption";

  public MultiValueMemberMapperAction(final ActionExecutionAudit action, final Logger log,
      final Object multiValueMemberMapper) {
    this.multiValueMemberMapper = (MultiValueMemberMapper) multiValueMemberMapper;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" MultiValueMemberMapper:"+this.multiValueMemberMapper.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(multiValueMemberMapper.getResourceConn());
      log.info(aMarker, "Control Data Comparison Action for {} has been started", multiValueMemberMapper.getName());

      String outputTable = multiValueMemberMapper.getOutputTable();
      final List<MultiValueMemberQueryInputTable> multiValueMemberQueryInputTables = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(multiValueMemberMapper.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          List<MultiValueMemberQueryInputTable> results = query
                  .mapToBean(MultiValueMemberQueryInputTable.class)
                  .list();
          multiValueMemberQueryInputTables.addAll(results);
          log.info(aMarker, "Executed query from index {}", i.get());
        });
      });
      log.info(aMarker, "Total rows returned from the query: {}", multiValueMemberQueryInputTables.size());

      String encryptData = action.getContext().getOrDefault(PIPELINE_END_TO_END_ENCRYPTION,"false");

      boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(encryptData);

      InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

      String processingSorItemName = action.getContext().get(PROCESSING_SOR_ITEM_NAME);

      String[] fields = processingSorItemName.split("\\s*,\\s*");

      Set<String> validSorItems = new HashSet<>(Arrays.asList(fields));

      for (MultiValueMemberQueryInputTable row : multiValueMemberQueryInputTables) {
        try {
          String extractedValue = row.getPredictedValue();
          String encryptionPolicy = row.getEncryptionPolicy();
          String sorItemName = row.getSorItemName();

          if (validSorItems.contains(sorItemName)) {
            log.debug("Processing multi_value lineItemType for SOR item: {}", sorItemName);

            if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(row.getIsEncrypted())) {
              log.info("Decryption and re-encryption enabled for multi_value item: {}", sorItemName);

              String[] multivalue = extractedValue.split(",");
              List<String> encryptMultiValue = new ArrayList<>();

              for (String value : multivalue) {
                String trimmedValue = value.trim();
                String encryptedValue = encryption.encrypt(trimmedValue, encryptionPolicy, sorItemName);
                encryptMultiValue.add(encryptedValue);
              }

              String finalOutput = String.join(",", encryptMultiValue);
              log.debug("Final re-encrypted multi_value string for {}", sorItemName);
              row.setPredictedValue(finalOutput);
            } else {
              log.info("Encryption not required for multi_value item: {}. Setting original extracted value.", sorItemName);
              row.setPredictedValue(extractedValue);
            }
          }
        } catch (Exception e) {
          HandymanException handymanException = new HandymanException(e);
          HandymanException.insertException("Control data comparison Input table failed {}:", handymanException, action);
        }
      }
      // Group rows by originId
      Map<String, List<MultiValueMemberQueryInputTable>> groupedByOriginId =
              multiValueMemberQueryInputTables.stream()
                      .collect(Collectors.groupingBy(MultiValueMemberQueryInputTable::getOriginId));

      for (Map.Entry<String, List<MultiValueMemberQueryInputTable>> entry : groupedByOriginId.entrySet()) {
        String originId = entry.getKey();
        List<MultiValueMemberQueryInputTable> groupRows = entry.getValue();

        // Per-group evaluation
        String result = evaluateMultivaluePresenceAndUniqueness(groupRows, validSorItems, log, aMarker);
        log.info(aMarker, "Multivalue result for originId {}: {}", originId, result);

        // Insert into output table
        bulkInsertOutputTable(jdbi, outputTable, groupRows, result);
      }

      log.info(aMarker, "Control Data Comparison Action has been completed {}", multiValueMemberMapper.getName());
  } catch (Exception e) {
    action.getContext().put(multiValueMemberMapper.getName() + ".isSuccessful", "false");
    log.error(aMarker, "Error in execute method for Control Data Comparison ", e);
    HandymanException handymanException = new HandymanException(e);
    HandymanException.insertException("Control data comparison failed {}:", handymanException, action);
  }
  }

  public static String evaluateMultivaluePresenceAndUniqueness(
          List<MultiValueMemberQueryInputTable> inputRows,
          Set<String> targetSorItems,
          Logger log,
          Marker marker
  ) {
    Map<String, Set<String>> valuesPerSorItem = new HashMap<>();
    Set<String> presentSorItems = new HashSet<>();

    for (MultiValueMemberQueryInputTable row : inputRows) {
      String sorItemName = row.getSorItemName();
      String predictedValue = row.getPredictedValue();

      if (sorItemName != null && predictedValue != null && targetSorItems.contains(sorItemName)) {
        presentSorItems.add(sorItemName);
        Set<String> values = valuesPerSorItem.computeIfAbsent(sorItemName, k -> new HashSet<>());

        Arrays.stream(predictedValue.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .forEach(values::add);
      }
    }

    if (!presentSorItems.containsAll(targetSorItems)) {
      log.info(marker, "Missing one or more target SOR items in input. Expected: {}, Found: {}", targetSorItems, presentSorItems);
      return "N";
    }

    // Commercial: requires all 3 (ID, Name, DOB) with more than 1 unique value each
    if (targetSorItems.containsAll(Set.of("member_id", "member_last_name", "member_date_of_birth"))) {
      boolean allHaveMultiple = true;
      for (String key : List.of("member_id", "member_last_name", "member_date_of_birth")) {
        int count = valuesPerSorItem.getOrDefault(key, Collections.emptySet()).size();
        log.info(marker, "Commercial - SOR item '{}' has {} unique values", key, count);
        if (count <= 1) {
          allHaveMultiple = false;
          break;
        }
      }
      return allHaveMultiple ? "Y" : "N";
    }

    // GBD: requires at least one of Member ID or Member Name to have >1 unique value (DOB is ignored)
    if (targetSorItems.contains("member_id") || targetSorItems.contains("member_last_name")) {
      int idCount = valuesPerSorItem.getOrDefault("member_id", Collections.emptySet()).size();
      int nameCount = valuesPerSorItem.getOrDefault("member_last_name", Collections.emptySet()).size();

      log.info(marker, "GBD - Member ID count: {}, Member Name count: {}", idCount, nameCount);

      return (idCount > 1 || nameCount > 1) ? "Y" : "N";
    }

    log.info(marker, "Unknown plan type. SOR items: {}", targetSorItems);
    return "N";
  }


  private void bulkInsertOutputTable(Jdbi jdbi, String outputTable,
                                     List<MultiValueMemberQueryInputTable> inputRows,
                                     String thresholdResult) {
    jdbi.useHandle(handle -> {
      var batch = handle.prepareBatch(
              "INSERT INTO " + outputTable + " (" +
                      "min_score_id, origin_id, paper_no, sor_item_name, weight_score, predicted_value, b_box, " +
                      "confidence_score, frequency, cummulative_score, question_id, synonym_id, tenant_id, " +
                      "model_registry, root_pipeline_id, batch_id" +
                      ") VALUES (" +
                      ":minScoreId, :originId, :paperNo, :sorItemName, :weightScore, :predictedValue, :bBox, " +
                      ":confidenceScore, :frequency, :cummulativeScore, :questionId, :synonymId, :tenantId, " +
                      ":modelRegistry, :rootPipelineId, :batchId" +
                      ")"
      );

      for (MultiValueMemberQueryInputTable row : inputRows) {
        batch
                .bind("minScoreId", row.getScoreId())
                .bind("originId", row.getOriginId())
                .bind("paperNo", row.getPaperNo())
                .bind("sorItemName", "multiple_member_indicator")
                .bind("weightScore", row.getWeightScore())
                .bind("predictedValue", thresholdResult)
                .bind("bBox", row.getBBox())
                .bind("confidenceScore", row.getVqaScore())
                .bind("frequency", row.getFrequency())
                .bind("cummulativeScore", row.getCummulativeScore())
                .bind("questionId", row.getQuestionId())
                .bind("synonymId", row.getSynonymId())
                .bind("tenantId", row.getTenantId())
                .bind("modelRegistry", row.getModelRegistry())
                .bind("rootPipelineId", row.getRootPipelineId())
                .bind("batchId", row.getBatchId());
      }

      batch.execute();
    });
  }


  @Override
  public boolean executeIf() throws Exception {
    return multiValueMemberMapper.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  public static class MultiValueMemberQueryInputTable {

    private Long rootPipelineId;
    private String batchId;
    private Long groupId;
    private String originId;
    private String sorContainerName;
    private String sorItemName;
    private String predictedValue;
    private Long paperNo;
    private Long tenantId;
    private String encryptionPolicy;
    private String isEncrypted;
    private String lineItemType;
    private Long synonymId;
    private Long questionId;
    private Long frequency;
    private double vqaScore;
    private String bBox;
    private String modelRegistry;
    private Long scoreId;
    private Long cummulativeScore;
    private Long weightScore;
  }
}