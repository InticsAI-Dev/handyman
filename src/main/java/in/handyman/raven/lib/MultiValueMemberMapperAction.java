package in.handyman.raven.lib;

import in.handyman.raven.core.encryption.SecurityEngine;
import in.handyman.raven.core.encryption.inticsgrity.InticsIntegrity;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.*;

import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import in.handyman.raven.lib.model.multi.member.indicator.MultiValueMemberMapperInputTable;
import in.handyman.raven.lib.model.multi.member.indicator.MultiValueMemberMapperOutputTable;
import in.handyman.raven.lib.model.multi.member.indicator.MultiValueMemberMapperTransformInputTable;
import in.handyman.raven.lib.model.multi.member.indicator.extractedSorItemList;
import in.handyman.raven.lib.model.scalar.ValidatorByBeanShellExecutor;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "MultiValueMemberMapper"
)
public class MultiValueMemberMapperAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final MultiValueMemberMapper multiValueMemberMapper;

  private final Marker aMarker;

  public static final String READ_BATCH_SIZE = "read.batch.size";
  public static final String WRITE_BATCH_SIZE = "write.batch.size";

  public static final String DUMMY_URL = "http://localhost:10181/copro/preprocess/autorotation";

  public static final String MULTI_MEMBER_CONSUMER_API_COUNT = "multi.member.consumer.API.count";

  public static final String INSERT_INTO = "INSERT INTO ";
  public static final String INSERT_INTO_VALUES_UPDATED = "VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  private List<MultiValueMemberMapperOutputTable> multiValueMemberMapperOutputTables;

  public static final String INSERT_COLUMNS_UPDATED = "min_score_id, origin_id, paper_no, sor_item_name, weight_score, predicted_value, b_box, confidence_score, frequency, cummulative_score, question_id, synonym_id, tenant_id, model_registry, root_pipeline_id, batch_id\n";

  private final String PIPELINE_END_TO_END_ENCRYPTION = "pipeline.end.to.end.encryption";

  public MultiValueMemberMapperAction(final ActionExecutionAudit action, final Logger log,
      final Object multiValueMemberMapper) {
    this.multiValueMemberMapper = (MultiValueMemberMapper) multiValueMemberMapper;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" MultiValueMemberMapper:"+this.multiValueMemberMapper.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(multiValueMemberMapper.getResourceConn());
      log.info(aMarker, "Multi Value Member Mapper Action for {} has been started", multiValueMemberMapper.getName());

      Long tenantId = Long.valueOf(action.getContext().get("tenant_id"));

      String outputTable = multiValueMemberMapper.getOutputTable();

      final List<MultiValueMemberMapperInputTable> multiValueMemberQueryInputTables = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(multiValueMemberMapper.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "Executing query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          List<MultiValueMemberMapperInputTable> results = query
                  .mapToBean(MultiValueMemberMapperInputTable.class)
                  .list();
          multiValueMemberQueryInputTables.addAll(results);
          log.info(aMarker, "Executed query from index {}", i.get());
        });
      });
      log.info(aMarker, "Total rows returned from the query: {}", multiValueMemberQueryInputTables.size());


      final List<URL> urls = Optional.of(DUMMY_URL).map(s -> Arrays.stream(s.split(",")).map(s1 -> {
        try {
          return new URL(s1);
        } catch (MalformedURLException e) {
          log.error("Error in processing the URL ", e);
          throw new HandymanException("Error in processing the URL", e, action);
        }
      }).collect(Collectors.toList())).orElse(Collections.emptyList());

      Integer readBatchSize = Integer.valueOf(action.getContext().get(READ_BATCH_SIZE));

      Integer consumerApiCount = Integer.valueOf(action.getContext().get(MULTI_MEMBER_CONSUMER_API_COUNT));

      Map<String, List<MultiValueMemberMapperInputTable>> groupedByOriginId =
              multiValueMemberQueryInputTables.stream()
                      .collect(Collectors.groupingBy(MultiValueMemberMapperInputTable::getOriginId));

      log.info(aMarker, "Grouped input rows by originId, total groups: {}", groupedByOriginId.size());

      String encryptData = action.getContext().getOrDefault(PIPELINE_END_TO_END_ENCRYPTION,"false");

      boolean pipelineEndToEndEncryptionActivator = Boolean.parseBoolean(encryptData);

      InticsIntegrity encryption = SecurityEngine.getInticsIntegrityMethod(action, log);

      List<MultiValueMemberMapperTransformInputTable> multiValueMemberMapperTransformInputTable = extractedValues(groupedByOriginId, pipelineEndToEndEncryptionActivator, encryption);

      multiValueMemberMapperOutputTables = new MultiValueMemberConsumerProcess(log, aMarker, action, multiValueMemberMapperTransformInputTable, tenantId, consumerApiCount).doMultiMemberValidation();

      log.info(aMarker, "Started batch insert into {}", outputTable);
      jdbi.useHandle(handle -> executeBatchInsert(handle, multiValueMemberMapperOutputTables));
      log.info(aMarker, "Batch insert completed into {}", outputTable);

      log.info(aMarker, "Multi Value Member Mapper Action has been completed {}", multiValueMemberMapper.getName());
  } catch (Exception e) {
    action.getContext().put(multiValueMemberMapper.getName() + ".isSuccessful", "false");
    log.error(aMarker, "Error in execute method for Multi Value Member Mapper ", e);
    HandymanException handymanException = new HandymanException(e);
    HandymanException.insertException("Multi Value Member Mapper failed {}:", handymanException, action);
  }
  }

  private List<MultiValueMemberMapperTransformInputTable> extractedValues(
          Map<String, List<MultiValueMemberMapperInputTable>> groupedByOriginId,
          boolean pipelineEndToEndEncryptionActivator,
          InticsIntegrity encryption) {

    List<MultiValueMemberMapperTransformInputTable> collect = groupedByOriginId.entrySet().stream()
            .map(entry -> {
              String originId = entry.getKey();
              List<MultiValueMemberMapperInputTable> inputRows = entry.getValue();

              List<extractedSorItemList> sorItems = inputRows.stream()
                      .map(row -> {
                        extractedSorItemList item = extractedSorItemList.builder()
                                .minScoreId(row.getScoreId())
                                .paperNo(row.getPaperNo())
                                .sorItemName(row.getSorItemName())
                                .weightScore(row.getWeightScore())
                                .predictedValue(processAndDecryptMultiValue(row, pipelineEndToEndEncryptionActivator, encryption))
                                .bBox(row.getBBox())
                                .confidenceScore(row.getScoreId())
                                .frequency(row.getFrequency())
                                .cummulativeScore(row.getCummulativeScore())
                                .questionId(row.getQuestionId())
                                .synonymId(row.getSynonymId())
                                .tenantId(row.getTenantId())
                                .modelRegistry(row.getModelRegistry())
                                .rootPipelineId(row.getRootPipelineId())
                                .batchId(row.getBatchId())
                                .build();

                        return item;
                      })
                      .collect(Collectors.toList());

              return MultiValueMemberMapperTransformInputTable.builder()
                      .originId(originId)
                      .sorItemList(sorItems)
                      .build();
            })
            .collect(Collectors.toList());
    return collect;
  }

  private String processAndDecryptMultiValue(MultiValueMemberMapperInputTable row, boolean pipelineEndToEndEncryptionActivator, InticsIntegrity encryption) {
    String extractedValue = row.getPredictedValue();
    String sorItemName = row.getSorItemName();
    String encryptionPolicy = row.getEncryptionPolicy();

    if (pipelineEndToEndEncryptionActivator && "t".equalsIgnoreCase(row.getIsEncrypted())) {
      log.info("Decryption the extracted value for the sor item:{} for the multi-member voting", sorItemName);
      String encryptedValue = encryption.decrypt(extractedValue, encryptionPolicy, sorItemName);
      row.setPredictedValue(encryptedValue);
    } else {
      log.info("Decryption not required for sor item: {}. Setting original extracted value.", sorItemName);
      row.setPredictedValue(extractedValue);
    }
    return extractedValue;
  }

  private void executeBatchInsert(Handle handle, List<MultiValueMemberMapperOutputTable> rows) {
    String sql = buildInsertSQL();
    try (PreparedBatch batch = handle.prepareBatch(sql)) {
      rows.forEach(row -> {
        batch.bind("createdUserId", action.getContext().get("created_user_id"));
        batch.bindBean(row);
        batch.bind("batchId", multiValueMemberMapper.getBatchId());
        batch.add();
      });
      int[] counts = batch.execute();
      log.info(aMarker, "Batch inserted {} records", counts.length);
    } catch (Exception e) {
      log.error(aMarker, "Batch insert failed", e);
      HandymanException.insertException("Error in batch insert into " + multiValueMemberMapper.getOutputTable(), new HandymanException(e), action);
    }
  }

  private String buildInsertSQL() {
    String insertQuery = INSERT_INTO + multiValueMemberMapper.getOutputTable() + " ( " + INSERT_COLUMNS_UPDATED + " ) " + INSERT_INTO_VALUES_UPDATED;
    return insertQuery;
  }

  @Override
  public boolean executeIf() throws Exception {
    return multiValueMemberMapper.getCondition();
  }
}