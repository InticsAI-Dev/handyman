package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.FtpDownload;
import in.handyman.raven.lib.model.ftpdownload.FtpDownloadInputTable;
import in.handyman.raven.lib.model.ftpdownload.FtpDownloadOutputTable;
import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.sql.Types;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "FtpDownload"
)
public class FtpDownloadAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final FtpDownload ftpDownload;

    private final Marker aMarker;

    public FtpDownloadAction(final ActionExecutionAudit action, final Logger log, final Object ftpDownload) {
        this.ftpDownload = (FtpDownload) ftpDownload;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" FtpDownload:" + this.ftpDownload.getName());
    }

    @Override
    public void execute() throws Exception {
        log.info(aMarker, "ftp download Action for {} has started", ftpDownload.getName());
        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(ftpDownload.getResourceConn());
        jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));

        List<String> downloadedFilePaths = new ArrayList<>();

        FtpDownloadInputTable ftpDownloadInputTable = getInputTableFromQuerySet(action.getContext().get("ftpDownloadQuerySet"), jdbi);
        String userName = ftpDownloadInputTable.getUsername();
        String password = ftpDownloadInputTable.getPassword();
        String remoteHost = ftpDownloadInputTable.getServerAddress();
        String sourceDir = ftpDownloadInputTable.getFolderPath();

        ObjectMapper objectMapper = new ObjectMapper();
        String ftpDownloadRequestJson = objectMapper.writeValueAsString(ftpDownloadInputTable);

        final long tenantId = Long.parseLong(action.getContext().get("tenant_id"));
        final Long rootPipelineId = action.getRootPipelineId();

        final String remotePort = action.getContext().get("ftpPort");
        final String DestDir = action.getContext().get("destinationPath");
        final String uploadTime = action.getContext().get("uploadTime");
        FTPClient ftpClient = new FTPClient();

        final String ftp = "FTP";
        final String active = "ACTIVE";
        try {
            int reply;
            ftpClient.connect(remoteHost, Integer.parseInt(remotePort));
            log.info(aMarker, "FTP URL HOST {} and port {} ", remoteHost, ftpClient.getDefaultPort());
            reply = ftpClient.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftpClient.disconnect();
                log.error("Exception in connecting to FTP Server");
                throw new RuntimeException();
            }
            ftpClient.login(userName, password);
            ftpClient.enterLocalPassiveMode();
            ftpClient.setUseEPSVwithIPv4(true);
            System.setProperty("https.protocols", "TLSv1,TLSv1.1,TLSv1.2");

            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            ftpClient.changeWorkingDirectory(sourceDir);
            FTPFile[] subFiles = ftpClient.listFiles();
            String completed = "COMPLETED";
            if (uploadTime.equals("null")) {
                if (subFiles != null) {
                    for (FTPFile aFile : subFiles) {

                        if (aFile.isFile()) {

                            String remoteFilePath = sourceDir + "/" + aFile.getName();
                            String savePath = DestDir + File.separator + aFile.getName();
                            downloadSingleFile(ftpClient, remoteFilePath, savePath);
                            downloadedFilePaths.add(savePath);// Add downloaded file path to the list
                        }
                    }
                    if (!downloadedFilePaths.isEmpty()) {

                        ObjectMapper mapper = new ObjectMapper();
                        String filePaths = mapper.writeValueAsString(downloadedFilePaths);

                        FtpDownloadOutputTable outputTable = FtpDownloadOutputTable.builder()
                                .tenantId(tenantId)
                                .rootPipelineId(rootPipelineId) // Adjust as needed
                                .createdOn(LocalDateTime.now())
                                .createdUserId(tenantId) // Set as needed
                                .lastUpdatedUserId(tenantId) // Set as needed
                                .lastUpdatedOn(LocalDateTime.now())
                                .status(active) // Set the status as needed
                                .message("FTP download completed")
                                .type(ftp)
                                .info(ftpDownloadRequestJson)// Set as needed
                                .lastProcessedOn(LocalDateTime.now())
                                .ftpFolderPath(sourceDir) // Set the FTP folder path
                                .destinationPath(DestDir) // Set the destination path
                                .filePath(filePaths)
                                .version(1)
                                .executionStatus(completed)
                                .build();
                        insertIntoOutputTable(jdbi, outputTable);
                    }
                }
            } else {

                if (subFiles != null) {
                    for (FTPFile aFile : subFiles) {

                        LocalDateTime lastModifiedTime = convertTimestampToLocalDateTime(aFile.getTimestamp().getTimeInMillis());
                        LocalDateTime uploadTimeDate = LocalDateTime.parse(uploadTime);

                        if (lastModifiedTime.isAfter(uploadTimeDate)) { // If uploadTime is specified and the file was uploaded after that time, download the file
                            String remoteFilePath = sourceDir + "/" + aFile.getName();
                            String savePath = DestDir + File.separator + aFile.getName();
                            downloadSingleFile(ftpClient, remoteFilePath, savePath);
                            downloadedFilePaths.add(savePath);
                        }
                    }
                    if (!downloadedFilePaths.isEmpty()) {
                        ObjectMapper mapper = new ObjectMapper();
                        String filePaths = mapper.writeValueAsString(downloadedFilePaths);
                        FtpDownloadOutputTable outputTable = FtpDownloadOutputTable.builder()
                                .tenantId(tenantId)
                                .rootPipelineId(rootPipelineId)
                                .createdOn(LocalDateTime.now())
                                .createdUserId(tenantId)
                                .lastUpdatedUserId(tenantId)
                                .lastUpdatedOn(LocalDateTime.now())
                                .status(active)
                                .message("FTP download completed")
                                .type(ftp)
                                .info(ftpDownloadRequestJson)
                                .lastProcessedOn(LocalDateTime.now())
                                .ftpFolderPath(sourceDir)
                                .destinationPath(DestDir)
                                .filePath(filePaths)
                                .version(1)
                                .executionStatus(completed)
                                .build();
                        insertIntoOutputTable(jdbi, outputTable);
                    }
                }
            }

        } catch (Exception e) {
            String executionStatus = "FAILED";
            FtpDownloadOutputTable outputTable = FtpDownloadOutputTable.builder()
                    .tenantId(tenantId)
                    .rootPipelineId(rootPipelineId)
                    .createdOn(LocalDateTime.now())
                    .createdUserId(tenantId)
                    .lastUpdatedUserId(tenantId)
                    .lastUpdatedOn(LocalDateTime.now())
                    .status(active)
                    .message(e.getMessage())
                    .type(ftp)
                    .lastProcessedOn(LocalDateTime.now())
                    .ftpFolderPath(sourceDir)
                    .destinationPath(DestDir)
                    .version(1)
                    .executionStatus(executionStatus)
                    .build();
            insertIntoOutputTable(jdbi, outputTable);
            log.error("Error during FTP download: {}", e.getMessage(), e);

        } finally {
            if (ftpClient.isConnected()) {
                ftpClient.logout();
                ftpClient.disconnect();
                log.info("FTP Client is disconnected");
            } else {
                log.info("Nothing to disconnect in ftp Client ");
            }
        }
    }

    private FtpDownloadInputTable getInputTableFromQuerySet(String querySet, Jdbi jdbi) {
        try (Handle handle = jdbi.open()) {
            return handle.createQuery(querySet)
                    .mapToBean(FtpDownloadInputTable.class)
                    .one();
        }
    }

    public void downloadSingleFile(FTPClient ftpClient, String remoteFilePath, String savePath) throws IOException {
        File downloadFile = new File(savePath);
        File parentDir = downloadFile.getParentFile();
        if (!parentDir.exists()) {
            boolean createDirSuccessful = parentDir.mkdir();
            if (!createDirSuccessful) log.error("Problem in creating the directory {} ", parentDir);
        }
        try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(downloadFile))) {
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            log.info(aMarker, "Download file {} ", savePath);
            boolean success = ftpClient.retrieveFile(remoteFilePath, outputStream);

            if (success) {
                log.info(aMarker, "Download the file {} ", remoteFilePath);
            } else {
                log.error(aMarker, "Couldn't download the file: {} ", remoteFilePath);
            }
        }
    }

    private void insertIntoOutputTable(Jdbi jdbi, FtpDownloadOutputTable ftpDownloadOutputTable) {
        jdbi.useTransaction(handle -> {
            handle.createUpdate("INSERT INTO onboard_wizard_info.ftp_download_info\n" +
                            "                (created_on, created_user_id, last_updated_on, last_updated_user_id, status, version, destination_path, execution_status, file_path, ftp_folder_path, info, last_processed_on, message, root_pipeline_id, tenant_id, type) " +
                            "VALUES( :createdOn, :createdUserId, :lastUpdatedOn, :lastUpdatedUserId, :status, :version, :destinationPath, :executionStatus, :filePath::jsonb, :ftpFolderPath, :info, :lastProcessedOn, :message, :rootPipelineId, :tenantId, :type);")
                    .bindBean(ftpDownloadOutputTable).execute();
            log.debug(aMarker, "inserted {} into ftp download info details", ftpDownloadOutputTable);
        });
    }

    private LocalDateTime convertTimestampToLocalDateTime(long timestamp) {
        Instant instant = Instant.ofEpochMilli(timestamp);
        return LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
    }


    @Override
    public boolean executeIf() throws Exception {
        return ftpDownload.getCondition();
    }
}
