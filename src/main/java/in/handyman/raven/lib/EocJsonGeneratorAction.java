package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.EocJsonGenerator;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.InstanceUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "EocJsonGenerator"
)
public class EocJsonGeneratorAction implements IActionExecution {
  private static final MediaType MediaTypeJSON = MediaType
          .parse("application/json; charset=utf-8");
  private final ActionExecutionAudit action;

  private final Logger log;

  private final EocJsonGenerator eocJsonGenerator;

  private final Marker aMarker;
  private final ObjectMapper mapper = new ObjectMapper();
  private final String URI;

  public EocJsonGeneratorAction(final ActionExecutionAudit action, final Logger log,
                                final Object eocJsonGenerator) {
    this.eocJsonGenerator = (EocJsonGenerator) eocJsonGenerator;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" EocJsonGenerator:" + this.eocJsonGenerator.getName());
    this.URI = action.getContext().get("gatekeeper.url");
  }

  @Override
  public void execute() throws Exception {
    try{

      log.info(aMarker, "<-------Eoc Json Generation Action for {} has been started------->" + eocJsonGenerator.getName());

      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(eocJsonGenerator.getResourceConn());
      final OkHttpClient httpclient = InstanceUtil.createOkHttpClient();

      final List<EocJsonInput> tableInfos = new ArrayList<>();

      final List<EocResponse> outputJsonInsert = new ArrayList<>();

      final int writeBatchSize= Integer.parseInt(action.getContext().get("write.batch.size"));
      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(eocJsonGenerator.getQuerySet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<EocJsonInput> resultIterable = query.mapToBean(EocJsonInput.class);
          List<EocJsonInput> detailList = resultIterable.stream().collect(Collectors.toList());
          tableInfos.addAll(detailList);
          log.info(aMarker, "executed query from index {}", i.get());
        });
      });


      tableInfos.forEach(eocJsonInput -> {
        Request request = new Request.Builder().url(URI + "api/v1/" + eocJsonInput.getDocumentId() + "/docdetaillineitem/" + eocJsonInput.getEocId())
                .header("Authorization", "Bearer " + eocJsonInput.getAuthToken()).build();

        String name = eocJsonGenerator.getName();
        log.info(aMarker, "The Request Details : {}", request);
        try (Response response = httpclient.newCall(request).execute()) {
          assert response.body() != null;
          String responseBody = response.body().string();
          if (response.isSuccessful()) {
            log.info(aMarker, "The Successful Response for {} --> {}", name, responseBody);
            EocResponse eocResponse = EocResponse.builder()
                    .documentId(eocJsonInput.documentId)
                    .eocId(eocJsonInput.getEocId())
                    .originId(eocJsonInput.getOriginId())
                    .groupId(eocJsonInput.getGroupId())
                    .eocResponse(responseBody)
                    .build();
            outputJsonInsert.add(eocResponse);
            log.debug(aMarker, "inserted {} into eoc response details", eocResponse);

          } else {
            log.info(aMarker, "The Failure Response {} --> {}", name, responseBody);
          }
          if (outputJsonInsert.size() == writeBatchSize) {
            log.info(aMarker, "executing  batch {}", outputJsonInsert.size());
            consumerBatch(jdbi, outputJsonInsert);
            log.info(aMarker, "executed  batch {}", outputJsonInsert.size());
            insertSummaryAudit(jdbi, tableInfos.size(), outputJsonInsert.size(), 0, "batch inserted");
            outputJsonInsert.clear();
            log.info(aMarker, "cleared batch {}", outputJsonInsert.size());
          }
          action.getContext().put(name + ".isSuccessful", String.valueOf(response.isSuccessful()));
        } catch (Exception e) {
          log.error(aMarker, "The Exception occurred ", e);
        }
      });

      if (!outputJsonInsert.isEmpty()) {
        log.info(aMarker, "executing final batch {}", outputJsonInsert.size());
        consumerBatch(jdbi, outputJsonInsert);
        log.info(aMarker, "executed final batch {}", outputJsonInsert.size());
        insertSummaryAudit(jdbi, tableInfos.size(), outputJsonInsert.size(), 0, "final batch inserted");
        outputJsonInsert.clear();
        log.info(aMarker, "cleared final batch {}", outputJsonInsert.size());
      }

      log.info(aMarker, "<-------Eoc Json Generation Action for {} has been completed------->" + eocJsonGenerator.getName());

    }catch (Exception e){
      log.error(aMarker, "The Exception occurred ", e);
      throw new HandymanException("Failed to execute", e);
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return eocJsonGenerator.getCondition();
  }

  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public static class EocResponse {
    private String documentId;
    private String eocId;
    private String originId;
    private Integer groupId;
    private String eocResponse;
  }

  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public static class EocJsonInput {
    private String eocId;
    private String originId;
    private Integer groupId;
    private String documentId;
    private String authToken;
  }

  void consumerBatch(final Jdbi jdbi, List<EocResponse> resultQueue) {
    try {
      resultQueue.forEach(insert -> {
                jdbi.useTransaction(handle -> {
                  try {
                    handle.createUpdate("INSERT INTO outbound.eoc_response_details (document_id, eoc_id, origin_id, group_id, eoc_response) " +
                                    "VALUES( :documentId, :eocId, :originId, :groupId, :eocResponse::json);")
                            .bindBean(insert).execute();
                    log.info(aMarker, "inserted {} into eoc genration output table ", insert);
                  } catch (Throwable t) {
                    insertSummaryAudit(jdbi, 0, 0, 1, "failed in bactch for " + insert.eocId+"and originId"+insert.getOriginId());
                    log.error(aMarker, "error inserting result {}", resultQueue, t);
                  }

                });
              }
      );
    } catch (Throwable t) {
      insertSummaryAudit(jdbi, 0, 0, resultQueue.size(), "failed in batch insert");
      log.error(aMarker, "error inserting result {}", resultQueue, t);
    }
  }

  void insertSummaryAudit(final Jdbi jdbi, int rowCount, int executeCount, int errorCount, String comments) {
    try {
      SanitarySummary summary = new SanitarySummary().builder()
              .rowCount(rowCount)
              .correctRowCount(executeCount)
              .errorRowCount(errorCount)
              .comments(comments)
              .build();
      jdbi.useTransaction(handle -> {
        Update update = handle.createUpdate("  INSERT INTO macro.eoc_json_generator_summary_"+ action.getProcessId()+"( row_count, correct_row_count, error_row_count,comments, created_at) " +
                " VALUES(:rowCount, :correctRowCount, :errorRowCount, :comments, NOW());");
        Update bindBean = update.bindBean(summary);
        bindBean.execute();
      });
    } catch (Throwable t) {
      log.error(aMarker, "error inserting into batch insert audit  {}", t);
    }
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class SanitarySummary {
    private int rowCount;
    private int correctRowCount;
    private int errorRowCount;
    private String comments;

  }

}