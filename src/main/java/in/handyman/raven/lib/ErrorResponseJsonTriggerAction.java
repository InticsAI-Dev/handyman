package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ErrorResponseJsonTrigger;
import in.handyman.raven.lib.model.errorResponseJsonTrigger.*;


import java.lang.Exception;
import java.lang.Object;
import java.lang.Override;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;


import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
    actionName = "ErrorResponseJsonTrigger"
)
public class ErrorResponseJsonTriggerAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final ErrorResponseJsonTrigger errorResponseJsonTrigger;

  private final Marker aMarker;
  public static final String READ_BATCH_SIZE = "read.batch.size";
  private final Jdbi jdbi;
  public ErrorResponseJsonTriggerAction(final ActionExecutionAudit action, final Logger log,
      final Object errorResponseJsonTrigger) {
    this.errorResponseJsonTrigger = (ErrorResponseJsonTrigger) errorResponseJsonTrigger;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" ErrorResponseJsonTrigger:"+this.errorResponseJsonTrigger.getName());
    this.jdbi = ResourceAccess.rdbmsJDBIConn(this.errorResponseJsonTrigger.getResourceConn());
  }

  @Override
  public void execute() throws Exception {

    jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
    log.info(aMarker, "error response trigger and storing in alchemy {} has been started", errorResponseJsonTrigger.getName());
    Integer readBatchSize = Integer.valueOf(action.getContext().get(READ_BATCH_SIZE));

    String sqlQuery = errorResponseJsonTrigger.getQuerySet();
    Logger logger = LoggerFactory.getLogger(FetchingDbValues.class);
    Class<ErrorResponseJsonTriggerInputTable> inputTargetClass = ErrorResponseJsonTriggerInputTable.class;
    LinkedBlockingQueue<ErrorResponseJsonTriggerInputTable> queue = new LinkedBlockingQueue<>();
    ErrorResponseJsonTriggerInputTable stoppingSeed = new ErrorResponseJsonTriggerInputTable();
    ExecutorService executorService = java.util.concurrent.Executors.newFixedThreadPool(2);

    FetchingDbValues<ErrorResponseJsonTriggerInputTable> fetcher = new FetchingDbValues<>(logger,jdbi,executorService,inputTargetClass,queue,stoppingSeed,action);

     List<ErrorResponseJsonTriggerInputTable> errorResponseJsonTriggerInputTables = fetcher.fetch(sqlQuery, readBatchSize, log);
      errorResponseJsonTriggerInputTables.forEach(this::dbFetchedData);
  }

  private List<URL> getEndpoints() {
    return Optional.ofNullable(errorResponseJsonTrigger.getEndpoint()).map(s -> Arrays.stream(s.split(",")).map(urlItem -> {
      try {
        return new URL(urlItem);
      } catch (MalformedURLException e) {
        log.error("Error in processing the URL {}", urlItem, e);
        throw new HandymanException("Error in processing the URL", e, action);
      }
    }).collect(Collectors.toList())).orElse(Collections.emptyList());

  }

  private void dbFetchedData(ErrorResponseJsonTriggerInputTable items) {
    log.info("Fetched rows from DB for error response for originId={}, stage={}, status={}, documentId={}", items.getOriginId(), items.getStages(), items.getStatus(), items.getDocumentId());
    String documentId = items.getDocumentId();
    String batchId= items.getBatchId();
    String originId = items.getOriginId();
    Timestamp processFailedOn = items.getProcessFailedOn();
    String failedOnStage = items.getFailedOnStage();
//    String stage = "SOR_TRANSACTION".equals(failedOnStage) ? "KRYPTON KVP ACTION" : failedOnStage;
    String transactionId = items.getTransactionId();
    Long tenantId = items.getTenantId();
    String message = items.getMessage();
    String status = items.getPipelineStatus();

    if (!failedOnStage.isEmpty()) {
      String errorCode = getErrorCodeFromMessage(failedOnStage);
      String exceptionType = getExceptionTypeFromMessage(failedOnStage);
      log.info("Constructing error response for originId={}, stage={}, status={}, documentId={}", originId, failedOnStage, status, documentId);
      errorResponseJsonPayload(message, exceptionType, errorCode, originId, status, failedOnStage, documentId, processFailedOn, tenantId, transactionId, batchId);

    }
    else{
      log.warn("Stage is null or blank. Skipping error response construction for originId={}, transactionId={}", originId, transactionId);
    }





  }

  private void errorResponseJsonPayload(String message, String exceptionType, String errorCode, String originId, String status, String failedOnStage, String documentId, Timestamp processFailedOn, Long tenantId, String transactionId, String batchId) {
    try {
      /*  payload order outer to inner nested json ErrorResponseJsonPayload ErrorJson ErrorDetail ErrorDetailsStackTrace*/

      // Inner nested errorDetails
      ErrorDetailsStackTrace errorDetails = new ErrorDetailsStackTrace();
      errorDetails.setExceptionType(exceptionType);
      errorDetails.setStackTrace(failedOnStage);

      // Inner error object
      ErrorDetail error = new ErrorDetail();
      error.setErrorCode(errorCode);
      error.setErrorMessage(message);
      error.setErrorDetails(errorDetails);

      // Inner errorJson object
      ErrorJson errorJson = new ErrorJson();
      errorJson.setOriginId(originId);
      errorJson.setPipelineStatus(status);
      errorJson.setFailedStage(failedOnStage);
      errorJson.setDocumentId(documentId);
      errorJson.setTimestamp(processFailedOn);
      errorJson.setError(error);

      ErrorResponseJsonPayload response = new ErrorResponseJsonPayload();
      response.setOutboundStatus("FAILED");
      response.setErrorMessage(message);
      response.setErrorCode(errorCode);
      response.setErrorJson(errorJson);
      response.setDocumentId(documentId);
      response.setOriginId(originId);
      response.setTenantId(tenantId);
      response.setTransactionId(transactionId);
      response.setBatchId(batchId);

      // Set nested errorJson in response
      ObjectMapper objectMapper = new ObjectMapper();
      String requestJson = objectMapper.writeValueAsString(response);  // âœ… Proper JSON
      makeApi(requestJson);

    } catch (Exception e) {
      log.error("Error occurred in error json creation", e);
    }
  }

  public static String getErrorCodeFromMessage(String message) {

    if (message.contains("PREPROCESS")) {
      return "ERR_601";  // Internal Server Error
    } else if (message.contains("AGENTIC PAPER FILTER")) {
      return "ERR_602";  // Not Found
    } else if (message.contains("SOR_TRANSACTION") || message.contains("KRYPTON KVP ACTION")) {
      return "ERR_603";  // Unprocessable Entity (commonly used for parsing errors)
    } else {
      return "";  // Unknown Error (custom default)
    }
  }

  public static String getExceptionTypeFromMessage(String message) {

    if (message.contains("PREPROCESS")) {
      return "PREPROCESS EXCEPTION";  // Internal Server Error
    } else if (message.contains("AGENTIC PAPER FILTER")) {
      return "AGENTIC PAPER FILTER EXCEPTION";  // Not Found
    } else if (message.contains("SOR_TRANSACTION") || message.contains("KRYPTON KVP ACTION")) {
      return "KVP EXCEPTION";
    } else {
      return "";
    }
  }

  @Override
  public boolean executeIf() throws Exception {
    return errorResponseJsonTrigger.getCondition();
  }

  public void makeApi(String requestBody){
    log.info("Executing API calls to store the error json in alchemy");

    try {
      // calling function to parse endpoints
      List<URL> urls = getEndpoints();
      String url = String.valueOf(urls.get(0));
      HttpClient client = HttpClient.newHttpClient();
      String bearerToken = action.getContext().get("alchemyAuth.token");
      HttpRequest request = HttpRequest.newBuilder()
              .uri(URI.create(url))
              .header("Content-Type", "application/json")
              .header("Authorization", "Bearer "+ bearerToken)
              .header("accept", "*/*")
              .POST(HttpRequest.BodyPublishers.ofString(requestBody))
              .build();

      client.send(request, HttpResponse.BodyHandlers.ofString());
      log.info("Completed API calls to store the error json in alchemy");

    } catch (Exception e) {
      HandymanException handymanException = new HandymanException(e);
      HandymanException.insertException("Error post call for error json generation", handymanException, action);

    }

  }
}

