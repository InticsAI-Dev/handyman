package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.Alphanumericvalidator;
import in.handyman.raven.lib.model.Alphavalidator;
import in.handyman.raven.lib.model.Charactercount;
import in.handyman.raven.lib.model.Datevalidator;
import in.handyman.raven.lib.model.Nervalidator;
import in.handyman.raven.lib.model.Numericvalidator;
import in.handyman.raven.lib.model.ScalarAdapter;
import in.handyman.raven.lib.model.Validator;
import in.handyman.raven.lib.model.Wordcount;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ScalarAdapter"
)
public class ScalarAdapterAction implements IActionExecution {
  public static final String NER = "ner";
  private final ActionExecutionAudit action;

  private final Logger log;

  private final ScalarAdapter scalarAdapter;
  private final Marker aMarker;

  private final Integer writeBatchSize = 1000;

  private final AlphavalidatorAction alphaAction;
  private final NumericvalidatorAction numericAction;
  private final AlphanumericvalidatorAction alphaNumericAction;
  private final DatevalidatorAction dateAction;
  private final NervalidatorAction nerAction;
  private final WordcountAction wordcountAction;
  private final CharactercountAction charactercountAction;


  public ScalarAdapterAction(final ActionExecutionAudit action, final Logger log,
                             final Object scalarAdapter) {
    this.scalarAdapter = (ScalarAdapter) scalarAdapter;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" ScalarAdapter:" + this.scalarAdapter.getName());
    this.wordcountAction = new WordcountAction(action, log, Wordcount.builder().build());
    this.charactercountAction = new CharactercountAction(action, log, Charactercount.builder().build());
    this.alphaAction = new AlphavalidatorAction(action, log, Alphavalidator.builder().build());
    this.numericAction = new NumericvalidatorAction(action, log, Numericvalidator.builder().build());
    this.alphaNumericAction = new AlphanumericvalidatorAction(action, log, Alphanumericvalidator.builder().build());
    this.dateAction = new DatevalidatorAction(action, log, Datevalidator.builder().build());
    this.nerAction = new NervalidatorAction(action, log, Nervalidator.builder().build());
  }

  @Override
  public void execute() throws Exception {
    try {
      log.info(aMarker, "scalar has started" + scalarAdapter.getName());

      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(scalarAdapter.getResourceConn());
      final List<ValidatorConfigurationDetail> validatorConfigurationDetails = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(scalarAdapter.getResultSet());
        AtomicInteger i = new AtomicInteger(0);
        formattedQuery.forEach(sqlToExecute -> {
          log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
          Query query = handle.createQuery(sqlToExecute);
          ResultIterable<ValidatorConfigurationDetail> resultIterable = query.mapToBean(ValidatorConfigurationDetail.class);
          List<ValidatorConfigurationDetail> detailList = resultIterable.stream().collect(Collectors.toList());
          validatorConfigurationDetails.addAll(detailList);
          log.info(aMarker, "executed query from index {}", i.get());
        });
      });

      //Add summary audit - ${process-id}.sanitizer_summary - this should hold row count, correct row count, error_row_count
      insertSummaryAudit(jdbi, validatorConfigurationDetails.size(), 0, 0);
      doCompute(jdbi, validatorConfigurationDetails);
      //doProcess(jdbi, validatorConfigurationDetails);
      log.info(aMarker, "scalar has completed" + scalarAdapter.getName());
    } catch (Throwable e) {
      action.getContext().put(scalarAdapter.getName().concat(".error"), "true");
      log.error(aMarker, "The Exception occuered in Scalar Adpater ", e);
    }
  }

  /*  private void doProcess(final Jdbi jdbi, final List<ValidatorConfigurationDetail> validatorConfigurationDetails) {
        final int parallelism;
        if (scalarAdapter.getForkBatchSize() != null) {
            parallelism = Integer.parseInt(scalarAdapter.getForkBatchSize());
        } else {
            parallelism = 1;
        }
        log.info(aMarker, "total records to process {}", validatorConfigurationDetails.size());
        try {
            final int batchSize = validatorConfigurationDetails.size() / parallelism;
            if (parallelism > 1 && batchSize > 0) {
                log.info(aMarker, "parallel processing has started" + scalarAdapter.getName());
                final List<ValidatorConfigurationDetail> nerValidatorConfigurationDetails = validatorConfigurationDetails.stream().filter(validatorConfigurationDetail -> Objects.equals(validatorConfigurationDetail.getAllowedAdapter(), "")).collect(Collectors.toList());

                validatorConfigurationDetails.removeAll(nerValidatorConfigurationDetails);

                final List<List<ValidatorConfigurationDetail>> partition = Lists.partition(validatorConfigurationDetails, batchSize);
                final CountDownLatch countDownLatch = new CountDownLatch(partition.size());
                final ExecutorService executorService = Executors.newFixedThreadPool(parallelism);

                partition.forEach(items -> executorService.submit(() -> {
                    try {
                        items.forEach(validatorConfigurationDetail -> {

                            doCompute(jdbi, validatorConfigurationDetail);

                        });
                        log.info(aMarker, "total records to processed {}", items.size());
                    } finally {
                        countDownLatch.countDown();
                        log.info(aMarker, " {} batch processed", countDownLatch.getCount());
                    }
                }));

                if (!nerValidatorConfigurationDetails.isEmpty()) {
                    doProcess(jdbi, nerValidatorConfigurationDetails);
                }

                countDownLatch.await();

            } else {
                log.info(aMarker, "sequential processing has started" + scalarAdapter.getName());

                validatorConfigurationDetails.forEach(validatorConfigurationDetail -> {

                    doCompute(jdbi, validatorConfigurationDetail);

                });
            }
        } catch (Exception e) {
            log.error(aMarker, "The Failure Response {} --> {}", scalarAdapter.getName(), e.getMessage(), e);
        }
    }*/

  private void doCompute(final Jdbi jdbi, List<ValidatorConfigurationDetail> listOfDetails) {
    try {
      List<ValidatorConfigurationDetail> resultQueue = new ArrayList<>();
      for (ValidatorConfigurationDetail result : listOfDetails) {
        log.info(aMarker, "executing  validator {}", result);

        String inputValue = result.getInputValue();
        int wordScore = wordcountAction.getWordCount(inputValue,
                result.getWordLimit(), result.getWordThreshold());
        int charScore = charactercountAction.getCharCount(inputValue,
                result.getCharLimit(), result.getCharThreshold());
        Validator configurationDetails = Validator.builder()
                .inputValue(inputValue)
                .adapter(result.getAllowedAdapter())
                .allowedSpecialChar(result.getAllowedCharacters())
                .comparableChar(result.getComparableCharacters())
                .threshold(result.getValidatorThreshold())
                .build();

        int validatorScore = computeAdapterScore(configurationDetails);
        int validatorNegativeScore = 0;
        if (result.getRestrictedAdapterFlag() == 1 && validatorScore != 0) {
          configurationDetails.setAdapter(result.getRestrictedAdapter());
          validatorNegativeScore = computeAdapterScore(configurationDetails);
        }

        double confidenceScore = wordScore + charScore + validatorScore - validatorNegativeScore;
        result.setWordScore(wordScore);
        result.setCharScore(charScore);
        result.setValidatorScore(validatorScore);
        result.setValidatorNegativeScore(validatorNegativeScore);
        result.setConfidenceScore(confidenceScore);
        result.setProcessId(String.valueOf(action.getProcessId()));
        resultQueue.add(result);
        log.info(aMarker, "executed  validator {}", result);

        if (resultQueue.size() == this.writeBatchSize) {
          log.info(aMarker, "executing  batch {}", resultQueue.size());
          consumerBatch(jdbi, resultQueue);
          log.info(aMarker, "executed  batch {}", resultQueue.size());
          insertSummaryAudit(jdbi, listOfDetails.size(), resultQueue.size(), 0);
          resultQueue.clear();
          log.info(aMarker, "cleared batch {}", resultQueue.size());
        }
      }
      if (!resultQueue.isEmpty()) {
        log.info(aMarker, "executing final batch {}", resultQueue.size());
        consumerBatch(jdbi, resultQueue);
        log.info(aMarker, "executed final batch {}", resultQueue.size());
        insertSummaryAudit(jdbi, listOfDetails.size(), resultQueue.size(), 0);
        resultQueue.clear();
        log.info(aMarker, "cleared final batch {}", resultQueue.size());
      }
    } catch (Throwable e) {
      action.getContext().put(scalarAdapter.getName().concat(".error"), "true");
      log.error(aMarker, "The Exception occurred in Scalar Computation", e);
    }
  }

  void consumerBatch(final Jdbi jdbi, List<ValidatorConfigurationDetail> resultQueue) {
    try {
      resultQueue.forEach(insert -> {
                jdbi.useTransaction(handle -> {
                  try {
                    Update update = handle.createUpdate("  INSERT INTO sor_transaction.adapter_result_" + scalarAdapter.getProcessID() +
                            " ( origin_id, paper_no, group_id, process_id, sor_id, sor_item_id, sor_item_name,question, answer, created_user_id, tenant_id, created_on, word_score, char_score, validator_score_allowed, validator_score_negative, confidence_score,validation_name) " +
                            " VALUES( :originId, :paperNo, :groupId, :processId , :sorId, :sorItemId, :sorKey, :question ,:inputValue, :createdUserId, :tenantId, NOW(), :wordScore , :charScore , :validatorScore, :validatorNegativeScore, :confidenceScore,:allowedAdapter);" +
                            "   ");
                    Update bindBean = update.bindBean(insert);
                    bindBean.execute();
                  } catch (Throwable t) {
                    insertSummaryAudit(jdbi, 0, 0, 1);
                    log.error(aMarker, "error inserting result {}", resultQueue, t);
                  }
                });
              }
      );
    } catch (Throwable t) {
      insertSummaryAudit(jdbi, 0, 0, resultQueue.size());
      log.error(aMarker, "error inserting result {}", resultQueue, t);
    }
  }

  int computeAdapterScore(Validator inputDetail) {
    int confidenceScore = 0;
    try {
      switch (inputDetail.getAdapter()) {
        case "alpha":
          confidenceScore = this.alphaAction.getAlphaScore(inputDetail);
          break;
        case "alphanumeric":
          confidenceScore = this.alphaNumericAction.getAlphaNumericScore(inputDetail);
          break;
        case "numeric":
          confidenceScore = this.numericAction.getNumericScore(inputDetail);
          break;
        case NER:
          final String URI = action.getContext().get("copro.text-validation.url");
          confidenceScore = this.nerAction.getNerScore(inputDetail, URI);
          break;
        case "date":
          confidenceScore = this.dateAction.getDateScore(inputDetail);
          break;
      }
    } catch (Throwable t) {
      log.error(aMarker, "error adpater validation{}", inputDetail, t);
    }
    return confidenceScore;

  }

  void insertSummaryAudit(final Jdbi jdbi, int rowCount, int executeCount, int errorCount) {
    SanitarySummary summary = new SanitarySummary().builder()
            .rowCount(rowCount)
            .correctRowCount(executeCount)
            .errorRowCount(errorCount)
            .build();
    jdbi.useTransaction(handle -> {
      Update update = handle.createUpdate("  INSERT INTO sor_transaction.sanitizer_summary_" + scalarAdapter.getProcessID() +
              " ( row_count, correct_row_count, error_row_count, created_at) " +
              " VALUES(:rowCount, :correctRowCount, :errorRowCount, NOW());");
      Update bindBean = update.bindBean(summary);
      bindBean.execute();
    });
  }

  @Override
  public boolean executeIf() throws Exception {
    return scalarAdapter.getCondition();
  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class SanitarySummary {
    int rowCount;
    int correctRowCount;
    int errorRowCount;

  }

  @AllArgsConstructor
  @NoArgsConstructor
  @Data
  @Builder
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class ValidatorConfigurationDetail {
    private int sorId;
    private String originId;
    private String ProcessId;
    private String sorKey;
    private String question;
    private String inputValue;
    private String allowedAdapter;
    private String restrictedAdapter;
    private int wordLimit;
    private int wordThreshold;
    private int charLimit;
    private int charThreshold;
    private int validatorThreshold;
    private String allowedCharacters;
    private String comparableCharacters;
    private int restrictedAdapterFlag;
    private int paperNo;
    private Integer groupId;
    private int sorItemId;
    private String createdUserId;
    private String tenantId;
    private double wordScore;
    private double charScore;
    private double validatorScore;
    private double validatorNegativeScore;
    private double confidenceScore;
    private String sorItemName;
  }
}
