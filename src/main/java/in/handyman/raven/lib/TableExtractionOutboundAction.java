package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Lists;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.TableExtractionOutbound;
import in.handyman.raven.lib.model.tableextraction.outboud.TableExtractionAggregatedJson;
import in.handyman.raven.lib.model.tableextraction.outboud.TableExtractionOutboundInput;
import in.handyman.raven.lib.model.tableextraction.outboud.TableExtractionOutboundOutput;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.ExceptionUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.argument.Arguments;
import org.jdbi.v3.core.argument.NullArgument;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.PreparedBatch;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "TableExtractionOutbound"
)
public class TableExtractionOutboundAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final TableExtractionOutbound tableExtractionOutbound;

    private final Marker aMarker;

    private Jdbi jdbi;

    public TableExtractionOutboundAction(final ActionExecutionAudit action, final Logger log,
                                         final Object tableExtractionOutbound) {
        this.tableExtractionOutbound = (TableExtractionOutbound) tableExtractionOutbound;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" TableExtractionOutbound:" + this.tableExtractionOutbound.getName());
    }

    @Override
    public void execute() throws Exception {

        log.info(aMarker, "Table extraction outbound Action has been started {}", tableExtractionOutbound);

        jdbi = ResourceAccess.rdbmsJDBIConn(tableExtractionOutbound.getResourceConn());
        jdbi.getConfig(Arguments.class).setUntypedNullArgument(new NullArgument(Types.NULL));
        final List<TableExtractionOutboundInput> tableInfos = new ArrayList<>();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(tableExtractionOutbound.getQuerySet());
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<TableExtractionOutboundInput> resultIterable = query.mapToBean(TableExtractionOutboundInput.class);
                List<TableExtractionOutboundInput> detailList = resultIterable.stream().collect(Collectors.toList());
                tableInfos.addAll(detailList);
                log.info(aMarker, "executed query from index {}", i.get());
            });
        });

        List<TableExtractionOutboundOutput> tableExtractionOutboundOutputs = new ArrayList<>();

        if (tableExtractionOutbound.getInputAttribution().equals("csv")) {
            extractOutboundDateFromCsv(jdbi, tableInfos, tableExtractionOutboundOutputs);

        } else if (tableExtractionOutbound.getInputAttribution().equals("Json")) {
            extractOutboundDateFromJson(jdbi, tableInfos, tableExtractionOutboundOutputs);
        }


    }


    public void extractOutboundDateFromCsv(final Jdbi jdbi ,final List<TableExtractionOutboundInput> tableInfos, List<TableExtractionOutboundOutput> tableExtractionOutboundOutputs) {
        tableInfos.forEach(tableExtractionOutboundInput -> {
            final String csvFilePathStr = tableExtractionOutboundInput.getProcessedFilePath();

//            final String columnHeadersListStr = tableExtractionOutboundInput.getColumnHeader();

//            String columnHeadersList = columnHeadersListStr.substring(1, columnHeadersListStr.length() - 1);
//            String[] columnHeadersArray = columnHeadersList.split(",");
//
//            final List<String> columnHeaders = List.of(columnHeadersArray);
                String columnHeader =  tableExtractionOutboundInput.getColumnHeader();



                try {
                    Long totalRowCount = extractRowCount(csvFilePathStr);
                    double sumOfColumnValue = extractedFromFilepath(csvFilePathStr, columnHeader, totalRowCount);

                    TableExtractionAggregatedJson aggregatedJson = aggregatedJsonBuilder(columnHeader, sumOfColumnValue);

                    ObjectMapper objectMapper = new ObjectMapper();
                    String aggregatedJsonStr = objectMapper.writeValueAsString(aggregatedJson);
                    TableExtractionOutboundOutput tableExtractionOutboundOutput = transformInputOutput(tableExtractionOutboundInput, aggregatedJsonStr);
                    tableExtractionOutboundOutputs.add(tableExtractionOutboundOutput);
                } catch (IOException e) {
                    throw new HandymanException("Error in processing the csv file path", e, action);
                }



        });
        if(!tableExtractionOutboundOutputs.isEmpty()){
            consumerBatch(jdbi,tableExtractionOutboundOutputs);
        }

    }

    public void consumerBatch(final Jdbi jdbi, List<TableExtractionOutboundOutput> tableExtractionOutboundOutputs) {
        try {
            jdbi.useTransaction(handle -> {
                final PreparedBatch batch = handle.prepareBatch("INSERT INTO " + tableExtractionOutbound.getResultTable() + " (process_id, group_id, tenant_id, template_id, origin_id, paper_no, processed_file_path, table_response, status, stage, message, created_on, root_pipeline_id, bboxes, croppedimage, column_headers, truth_entity_name, model_name, aggregated_json,sor_item_id) " +
                        "VALUES(:process_id, :group_id, :tenant_id, :template_id, :origin_id, :paper_no, :processed_file_path, :table_response, :status, " +
                        ":stage, :message, :created_on, :root_pipeline_id, :bboxes, :croppedimage, :column_headers, :truth_entity_name, :model_name, :aggregatedJson, :sorItemId);");

                Lists.partition(tableExtractionOutboundOutputs, 100).forEach(resultLineItems -> {
                    log.info(aMarker, "inserting into trinity model_action {}", resultLineItems.size());
                    resultLineItems.forEach(resultLineItem -> batch.bind("process_id", resultLineItem.getProcessId()).bind("group_id", resultLineItem.getGroupId())
                                    .bind("tenant_id", resultLineItem.getTenantId()).bind("template_id",resultLineItem.getTemplateId() ).bind("origin_id",resultLineItem.getOriginId() )
                                    .bind("paper_no", resultLineItem.getPaperNo()).bind("processed_file_path", resultLineItem.getProcessedFilePath()).bind("table_response", resultLineItem.getTableResponse())
                                    .bind("status", resultLineItem.getStatus()).bind("stage", resultLineItem.getStage()).bind("message", resultLineItem.getMessage())
                                    .bind("created_on", resultLineItem.getCreatedOn()).bind("root_pipeline_id", resultLineItem.getRootPipelineId()).bind("bboxes", resultLineItem.getBboxes())
                                    .bind("croppedimage", resultLineItem.getCroppedimage()).bind("column_headers",resultLineItem.getColumnHeader() ).bind("truth_entity_name",resultLineItem.getTruthEntityName() )
                                    .bind("model_name", resultLineItem.getModelName())
                                    .bind("aggregatedJson",resultLineItem.getAggregatedJson())
                            .bind("sorItemId",resultLineItem.getSorItemId())

                            .add());
                    int[] counts = batch.execute();
                    log.info(aMarker, " persisted {} in trinity model_action", counts);
                });
            });
        } catch (Exception e) {
            insertSummaryAudit(jdbi, 0, 0, tableExtractionOutboundOutputs.size(), "failed in batch insert", action.getRootPipelineId());
            new HandymanException("error inserting result " + tableExtractionOutboundOutputs,e,action);
        }
    }

    void insertSummaryAudit(final Jdbi jdbi, int rowCount, int executeCount, int errorCount, String comments, Long tenantId) {
        try {
            SanitarySummary summary = new SanitarySummary().builder()
                    .rowCount(rowCount)
                    .correctRowCount(executeCount)
                    .errorRowCount(errorCount)
                    .comments(comments)
                    .tenantId(tenantId)
                    .build();
            jdbi.useTransaction(handle -> {
                Update update = handle.createUpdate(" INSERT INTO "+tableExtractionOutbound.getResultTable()+"_error ( row_count, correct_row_count, error_row_count,comments, created_at,root_pipeline_audit) " +
                        " VALUES(:rowCount, :correctRowCount, :errorRowCount, :comments, NOW(),:tenantId, :rootpipelineId);");
                Update bindBean = update.bindBean(summary);
                bindBean.execute();
            });
        } catch (Exception exception) {
            log.error(aMarker, "error inserting into batch insert audit  {}", ExceptionUtil.toString(exception));
            HandymanException handymanException = new HandymanException(exception);
            HandymanException.insertException("error inserting into batch insert audit", handymanException, action);

        }
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class SanitarySummary {
        private int rowCount;
        private int correctRowCount;
        private int errorRowCount;
        private String comments;
        private Long tenantId;

    }


    public TableExtractionAggregatedJson aggregatedJsonBuilder(final String columnHeader,final double sumOfColumnValue) {

        TableExtractionAggregatedJson tableExtractionAggregatedJson=new TableExtractionAggregatedJson();

        tableExtractionAggregatedJson.setColumnHeaderKey(columnHeader);
        tableExtractionAggregatedJson.setColumnHeaderValue(String.valueOf(sumOfColumnValue));

        return tableExtractionAggregatedJson;

    }

    private double extractedFromFilepath(String filePath, String columnName, Long rowCount) {
        double columnSum = 0.0;
        try {
            Reader reader = Files.newBufferedReader(Paths.get(filePath));

            CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader());

            for (CSVRecord csvRecord : csvParser) {

                Long totalRowCount = csvParser.getRecordNumber();

                String cellValue = csvRecord.get(columnName.trim());

                try{
                    //checking the cell value is empty or blank
                    if(!cellValue.isEmpty() && !cellValue.isBlank()){
                        double value = Double.parseDouble(cellValue);
                        //checking the total row count matches the current row count then break the loop
                        if (!Objects.equals(rowCount, totalRowCount)) {
                            columnSum += value;
                        } else {
                            //checking the total sum equals to the last cell of that column
                            if (columnSum == value) {
                                break;
                            }
                        }
                    }


                }catch (Exception e){
                    throw new HandymanException("cannot parse string '"+ cellValue +"' into the double variable ", e, action);
                }


            }

            csvParser.close();

        } catch (Exception e) {
            throw new HandymanException("Error in processing the csv file '"+filePath+"' ", e, action);
        }
        return columnSum;
    }


    public Long extractRowCount(String filePath) throws IOException {

        Reader reader = Files.newBufferedReader(Paths.get(filePath));

        // Create a CSVParser object
        CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader());

        Long rowCount = 0L;
        for (CSVRecord record : csvParser) {
            rowCount++;
        }

        // Close the CSVParser
        csvParser.close();

        return rowCount;

    }

    public TableExtractionOutboundOutput transformInputOutput(final TableExtractionOutboundInput tableExtractionOutboundInput, final String aggregatedJson) {
        TableExtractionOutboundOutput tableExtractionOutboundOutput = new TableExtractionOutboundOutput();

        tableExtractionOutboundOutput.setProcessId(tableExtractionOutboundInput.getProcessId());
        tableExtractionOutboundOutput.setGroupId(tableExtractionOutboundInput.getGroupId());
        tableExtractionOutboundOutput.setTenantId(tableExtractionOutboundInput.getTenantId());
        tableExtractionOutboundOutput.setTemplateId(tableExtractionOutboundInput.getTemplateId());
        tableExtractionOutboundOutput.setOriginId(tableExtractionOutboundInput.getOriginId());
        tableExtractionOutboundOutput.setPaperNo(tableExtractionOutboundInput.getPaperNo());
        tableExtractionOutboundOutput.setProcessedFilePath(tableExtractionOutboundInput.getProcessedFilePath());
        tableExtractionOutboundOutput.setTableResponse(tableExtractionOutboundInput.getTableResponse());
        tableExtractionOutboundOutput.setStatus(tableExtractionOutboundInput.getStatus());
        tableExtractionOutboundOutput.setStage(tableExtractionOutboundInput.getStage());
        tableExtractionOutboundOutput.setMessage(tableExtractionOutboundInput.getMessage());
        tableExtractionOutboundOutput.setCreatedOn(tableExtractionOutboundInput.getCreatedOn());
        tableExtractionOutboundOutput.setRootPipelineId(tableExtractionOutboundInput.getRootPipelineId());
        tableExtractionOutboundOutput.setBboxes(tableExtractionOutboundInput.getBboxes());
        tableExtractionOutboundOutput.setCroppedimage(tableExtractionOutboundInput.getCroppedimage());
        tableExtractionOutboundOutput.setColumnHeader(tableExtractionOutboundInput.getColumnHeader());
        tableExtractionOutboundOutput.setTruthEntityName(tableExtractionOutboundInput.getTruthEntityName());
        tableExtractionOutboundOutput.setModelName(tableExtractionOutboundInput.getModelName());
        tableExtractionOutboundOutput.setSorItemId(tableExtractionOutboundInput.getSorItemId());
        tableExtractionOutboundOutput.setAggregatedJson(aggregatedJson);

        return tableExtractionOutboundOutput;
    }

    public void extractOutboundDateFromJson(final Jdbi jdbi ,final List<TableExtractionOutboundInput> tableInfos, final List<TableExtractionOutboundOutput> tableExtractionOutboundOutputs) {
        //TODO implementation for the table extraction into outbound from Json should be completed

    }

    @Override
    public boolean executeIf() throws Exception {
        return tableExtractionOutbound.getCondition();
    }
}
