package in.handyman.raven.lib;

import com.zaxxer.hikari.HikariDataSource;
import in.handyman.raven.core.connection.ResourceAccess;
import in.handyman.raven.core.context.ActionContext;
import in.handyman.raven.core.context.ProcessContext;
import in.handyman.raven.core.process.ProcessEngine;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.LambdaAutowire;
import in.handyman.raven.lambda.LambdaExecution;
import in.handyman.raven.lib.model.CallProcess;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.MarkerManager;

import java.sql.SQLException;
import java.util.Map;
import java.util.stream.IntStream;

/**
 * Auto Generated By Raven
 */
@LambdaAutowire(
        lambdaName = "CallProcess"
)
@Log4j2
public class CallProcessAction implements LambdaExecution {
    private final ActionContext actionContext;

    private final CallProcess context;

    private final MarkerManager.Log4jMarker aMarker;

    public CallProcessAction(final ActionContext actionContext, final Object context) {
        this.context = (CallProcess) context;
        this.actionContext = actionContext;
        this.aMarker = new MarkerManager.Log4jMarker("CallProcess");
        this.actionContext.getDetailMap().putPOJO("context", context);
    }

    @Override
    public void execute() throws Exception {
        final String fileRelativePath = context.getSource();
        var targetProcess = context.getTarget();
        var dbSrc = context.getDatasource();
        var sql = context.getValue().replaceAll("\"", "");
        log.info(aMarker, " id#{}, name#{}, calledProcess#{}, calledFile#{}, db=#{}", actionContext.getProcessId(), actionContext.getName(), targetProcess, fileRelativePath, dbSrc);
        final HikariDataSource source = ResourceAccess.rdbmsConn(dbSrc);
        try (var conn = source.getConnection()) {
            try (var stmt = conn.createStatement()) {
                try (var rs = stmt.executeQuery(sql)) {
                    var columnCount = rs.getMetaData().getColumnCount();
                    while (rs.next()) {
                        final Map<String, String> configContext = actionContext.getContext();
                        IntStream.range(1, columnCount + 1).forEach(i -> {
                            try {
                                var key = rs.getMetaData().getColumnLabel(i);
                                var value = rs.getString(i);
                                configContext.put(key, value);
                                actionContext.getDetailMap().put("query.output." + key, value);
                            } catch (SQLException e) {
                                throw new HandymanException("Fetch config failed", e);
                            }
                        });
                        final ProcessContext processContext = ProcessEngine.start(fileRelativePath, targetProcess, actionContext.getProcessId(), configContext);
                        log.info(aMarker, processContext);
                    }
                }
            }
        }
        log.info(aMarker, "Completed name#{}, calledProcess#{}, calledFile#{}, db=#{}", actionContext.getName(), targetProcess, fileRelativePath, dbSrc);
    }

    @Override
    public boolean executeIf() throws Exception {
        return context.getCondition();
    }
}
