grammar in.handyman.Dsl with org.eclipse.xtext.common.Terminals

generate dsl "http://www.handyman.in/Dsl"

Process:
	'process' name=STRING
	'{'
	try=Try
	catch=Catch
	finally=Finally
	'}';

Try:
	'try'
	'{'
	(action+=Action)*
	'}';

Finally:
	'finally'
	'{'
	(action+=Action)*
	'}';

Catch:
	'catch'
	'{'
	(action+=Action)*
	'}';

Action:
	(Copydata
	| LoadCsv
	| WriteCsv
	| Transform
	| GooglecalPUT
	| SlackPUT
	| ClickSendSms
	| Updatedaudit
	| Callprocess
	| Fetch
	| TrelloPUT
	| TrelloGET
	| Rest
	| Doozle
	| Dropfile
	| FBCLead
	| FBFormDownload
	| SendMail
	| GooglecontactPUT
	| GooglecontactSelectAll
	| Abort
	| SmsLeadSms
	| FirebaseReactiveNotification
	| FirebaseDatabasePut
	| ExecJava
	| ElasticFBCLead
	| ElasticGET
	| Dropbox
	| S3
	| Extract
	| Checksum
	| DeleteFolder
	| Mail
	| TarGeneration
	| ModelGeneration
	| Mahout
	| Terminal
	| NLPTextPreprocessing
	| DropboxCleanup
	| Soap
	| JSONTransformation
	| SendEMail);

DeleteFolder:
	'deletefolder' 'as' name=STRING 'folder' foldersource=STRING 'zipfile' zipsource=STRING
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

DropboxCleanup:
	'dropboxcleanup' 'as' name=STRING 'auth' auth=STRING 'type' type=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Mail:
	'mail' 'as' name=STRING 'db' source=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

SendEMail:
	'sendemail' 'as' name=STRING 'db' source=STRING 'smtp-host' smtphost=STRING 'smtp-port' smtpport=STRING 
	'from' from=STRING 'pass' pass=STRING 'to' to=STRING 'cc' cc=STRING
	'bcc' bcc=STRING 'subject' subject=STRING 'body' body=STRING 'signature' signature=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

NLPTextPreprocessing:
	'nlptextpreprocessing' 'as' name=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

TarGeneration:
	'targeneration' 'as' name=STRING 'from' source=STRING 'audit' auditVal=STRING 'process_id' process_id=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

ModelGeneration:
	'modelgeneration' 'as' name=STRING 'from' source=STRING 'audit' auditVal=STRING 'process_id' process_id=STRING
	'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Mahout:
	'mahout' 'as' name=STRING 'id' id=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

Terminal:
	'terminal' 'as' name=STRING 'id' id=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

Extract:
	'extract' 'as' name=STRING 'db' db=STRING 'sdirectory' sdirectory=STRING 'ddirectory' ddirectory=STRING 'file'
	file=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Checksum:
	'checksum' 'as' name=STRING 'db' db=STRING 'cstype' cstype=STRING
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Dropbox:
	'dropbox' 'as' name=STRING 'db' db=STRING 'auth' auth=STRING 'source' source=STRING 'target' target=STRING 'type'
	type=STRING 'by-batch' limit=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

S3:
	's3' 'as' name=STRING 'db' db=STRING 'key' key=STRING 'token' token=STRING 'bucket' bucket=STRING 'type' type=STRING
	'by-batch' limit=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

ElasticFBCLead:
	'efblc' 'as' name=STRING 'secured-by' accessToken=STRING 'with-key' appSecret=STRING 'through-user' accountId=STRING
	'for-campaign' campaignId=STRING 'into' target=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

ElasticGET:
	'elasticget' 'as' name=STRING 'from' source=STRING 'to' to=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

ExecJava:
	"java" 'as' name=STRING 'using' classFqn=STRING 'name-sake-db' dbSrc=STRING
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

FirebaseDatabasePut:
	'fbdp' 'as' name=STRING 'on' url=STRING 'auth-by' fbjson=STRING 'for-group' groupPath=STRING 'from-source'
	dbSrc=STRING 'with-class' classFqn=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

FirebaseReactiveNotification:
	'fbrn' 'as' name=STRING 'on' url=STRING 'auth-by' fbjson=STRING 'for-group' groupPath=STRING 'with-class'
	classFqn=STRING 'using' dbSrc=STRING 'on-condition' condition=Expression;

SmsLeadSms:
	'smsleadssms' 'as' name=STRING 'on' url=STRING 'with-sender' sender=STRING 'through-account' account=STRING
	'secured-by' privateKey=STRING 'from-source' dbSrc=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression 'do-dryrun-with' dryrunNumber=STRING;

Abort:
	'abort' 'as' name=STRING
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

GooglecontactSelectAll:
	'gcontact-fetchall' 'as' name=STRING 'through-account' account=STRING 'secured-by' privateKey=STRING 'with-key'
	ptwelveFile=STRING 'for-project' project=STRING 'on-behalf-of' impersonatedUser=STRING 'to-target' dbSrc=STRING
	'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

SendMail:
	'sendmail' 'as' name=STRING 'secured-by' privateKey=STRING 'on-behalf-of' impersonatedUser=STRING 'from-source'
	dbSrc=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression 'do-dryrun-with' dryrunMail=STRING;

GooglecontactPUT:
	'gcontact' 'as' name=STRING 'through-account' account=STRING 'secured-by' privateKey=STRING 'with-key'
	ptwelveFile=STRING 'for-project' project=STRING 'on-behalf-of' impersonatedUser=STRING 'from-source' dbSrc=STRING
	'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

GooglecalPUT:
	'gcalendar' 'as' name=STRING 'through-account' account=STRING 'secured-by' privateKey=STRING 'with-key'
	ptwelveFile=STRING 'for-project' project=STRING 'on-behalf-of' impersonatedUser=STRING 'from-source' dbSrc=STRING
	'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

FBCLead:
	'fblc' 'as' name=STRING 'secured-by' accessToken=STRING 'with-key' appSecret=STRING 'through-user' accountId=STRING
	'for-campaign' campaignId=STRING 'into' target=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

FBFormDownload:
	'fbfd' 'as' name=STRING 'secured-by' accessToken=STRING 'with-key' appSecret=STRING 'through-user' accountId=STRING
	'for-form' formId=STRING 'into' target=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

Dropfile:
	'dropfile' 'as' name=STRING 'in-path' target=STRING 'on-condition' condition=Expression;

Doozle:
	'doozle' 'as' name=STRING 'in-table' target=STRING 'on' on=STRING 'using'
	'{'
	value=CreateStatement
	'}' 'on-condition' condition=Expression;

Rest:
	'rest' 'as' name=STRING 'secured-by' authtoken=STRING 'with-url' url=STRING 'and-method-as' method=STRING
	'with-authentication-type' authenticationType=STRING
	'{'
	'from' resourcedatafrom=STRING 'update-url-with' '{'
	urldata=SelectStatement
	'}'
	'from' headerdatafrom=STRING 'update-header-with' '{'
	headerdata=SelectStatement
	'}'
	'from' postdatafrom=STRING 'update-body-with' '{'
	'parent' 'as' parentName=STRING parentdata=SelectStatement
	parts+=(RestPart)*
	'}'
	'into' ackdatato=STRING 'store-ack-at' '{'
	ackdata=SelectStatement
	'}'
	'}' 'on-condition' condition=Expression;

Soap:
	'soap' 'as' name=STRING 'with-url' url=STRING 'and-method-as' method=STRING
	'content-type' contentType=STRING 'api-call-type' apiCallType=STRING
	'source' db=STRING 'for-auth-values' '{'
	sourceValue=SelectStatement
	'}'
	'select-distinct-company' '{'
	selectDistinctCompany=SelectStatement
	'}'
	'store-data-for-transform' '{'
	storeDataForTransform=SelectStatement
	'}'
	'update-page-max-based-on-company-code' '{'
	updatePageMaxValue=SelectStatement
	'}' 'on-condition' condition=Expression;

JSONTransformation:
	'jsontransformation' 'as' name=STRING 'source' db=STRING 'target-table-name' targetTableName=STRING
	'api-call-type' apiCallType=STRING 'key-value-input-for-json-iteration' '{'
	jsonKeyValue=SelectStatement
	'}'
	'input-for-insert-from-temp-table' '{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

RestPart:
	'part' 'as' partName=STRING 'with'
	partData=SelectStatement
	multiParts+=(MultiPartData)*;

PartData:
	'partsingleobject' 'as' partName=STRING onPath=STRING 'with' partData=SelectStatement;

MultiPartData:
	'partmultiobject' 'as' partName=STRING onPath=STRING 'with' partData=SelectStatement;

TrelloGET:
	'trelloget' 'as' name=STRING 'secured-by' authtoken=STRING 'with-key' key=STRING 'through-user' useraccount=STRING
	'from-board' board=STRING 'to' target=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

TrelloPUT:
	'trelloput' 'as' name=STRING 'secured-by' authtoken=STRING 'with-key' key=STRING 'through-user' useraccount=STRING
	'for-list' list=STRING 'from-source' source=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Fetch:
	'assign' 'as' name=STRING 'source' source=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

Callprocess:
	'callprocess' 'as' name=STRING 'with-target' target=STRING 'from-file' source=STRING 'using' datasource=STRING
	'for-every'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Updatedaudit:
	'log' 'as' name=STRING 'logto' logsink=STRING 'in' datasource=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

ClickSendSms:
	'c2sms' 'as' name=STRING 'with-user' userid=STRING 'secured-by' securityKey=STRING 'from-source' target=STRING
	'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

SlackPUT:
	'slackput' 'as' name=STRING 'to' team=STRING 'on' channel=STRING 'using'
	'{'
	value=STRING
	'}' 'on-condition' condition=Expression;

Copydata:
	'copydata' 'as' name=STRING 'from' source=STRING 'to' to=STRING 'target' target=STRING 'by-batch' limit=STRING
	'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

WriteCsv:
	'writecsv' 'as' name=STRING 'from' source=STRING 'to' to=STRING 'with' delim=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

LoadCsv:
	'loadcsv' 'as' name=STRING 'from' source=STRING 'to' to=STRING 'with' delim=STRING 'by-batch' limit=STRING
	'dbschema'
	dbschema=STRING 'using'
	'{'
	value=SelectStatement
	'}' 'on-condition' condition=Expression;

Transform:
	'transform' 'as' name=STRING 'on' on=STRING 'using'
	'{'
	value+=NonSelectStatement
	'}' 'on-condition' condition=Expression;

Column:
	STRING;

SelectStatement:
	STRING;

NonSelectStatement:
	STRING;

CreateStatement:
	STRING;

Expression:
	'if' lhs=STRING operator=Operator rhs=STRING;

Operator:
	'<' | '>' | '==' | 'contains';
