package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.Action;
import in.handyman.raven.lambda.doa.ResourceConnection;
import in.handyman.raven.lambda.process.CommandProxy;
import in.handyman.raven.lambda.process.LambdaEngine;
import in.handyman.raven.lib.model.Consumer;
import in.handyman.raven.lib.model.Producer;
import in.handyman.raven.lib.model.ProducerConsumerModel;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ProducerConsumerModel"
)
public class ProducerConsumerModelAction implements IActionExecution {
    private final Action action;

    private final Logger log;

    private final ProducerConsumerModel producerConsumerModel;

    private final Marker aMarker;

    public ProducerConsumerModelAction(final Action action, final Logger log,
                                       final Object producerConsumerModel) {
        this.producerConsumerModel = (ProducerConsumerModel) producerConsumerModel;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" ProducerConsumerModel:" + this.producerConsumerModel.getName());
    }

    @Override
    public void execute() throws Exception {

        log.info(aMarker, "Given {}", producerConsumerModel);
        final Integer pThreadCount = Optional.ofNullable(producerConsumerModel.getProduceThreadCount()).map(Integer::valueOf).orElse(1);
        final Integer cThreadCount = Optional.ofNullable(producerConsumerModel.getConsumeThreadCount()).map(Integer::valueOf).orElse(1);

        final ExecutorService pExecutorService = Executors.newWorkStealingPool(pThreadCount);
        final ExecutorService cExecutorService = Executors.newWorkStealingPool(cThreadCount);


        final List<ProducerAction> producerActions = producerConsumerModel.getProduce().stream().flatMap(producerContext -> {

            var producer = new Producer();
            CommandProxy.setTarget(producer, producerContext, action.getContext());
            log.info(aMarker, "{}", producerContext);

            final ResourceConnection source = producer.getSource();
            final List<Map<String, String>> maps = source.get()
                    .withHandle(handle -> handle.createQuery(producer.getStmt()).mapToMap().stream()
                            .map(stringObjectMap -> stringObjectMap.entrySet()
                                    .stream().collect(Collectors.toMap(Map.Entry::getKey,
                                            x -> String.valueOf(x.getValue()), (p, q) -> p)))
                            .collect(Collectors.toList()));

            return maps.stream().map(stringObjectMap -> {
                var vAction = LambdaEngine.getAction(producer.getName(), action);

                final Map<String, String> map = new HashMap<>(Map.copyOf(action.getContext()));
                map.putAll(stringObjectMap);
                vAction.setContext(map);

                return new ProducerAction(vAction, log, producer);
            });

        }).collect(Collectors.toList());

        final int size = producerActions.size();
        var countDown = new CountDownLatch(size);
        final BlockingQueue<String> nodes = new LinkedBlockingQueue<>(size + 1);
        final String poison = UUID.randomUUID().toString();

        final List<ConsumerAction> consumerActions = producerConsumerModel.getConsume().stream().map(consumerContext -> {
            var consumer = new Consumer();
            consumer.setNodes(nodes);
            consumer.setPoison(poison);

            CommandProxy.setTarget(consumer, consumerContext, action.getContext());
            log.info(aMarker, "{}", consumerContext);
            var vAction = LambdaEngine.getAction(consumer.getName(), action);
            return new ConsumerAction(vAction, log, consumer);
        }).collect(Collectors.toList());


        var consumerCountDown = new CountDownLatch(consumerActions.size());


        try {


            consumerActions.forEach(consumerAction -> {
                cExecutorService.submit(() -> {


                    try {
                        if (consumerAction.executeIf()) {
                            consumerAction.execute();
                        }
                    } finally {
                        consumerCountDown.countDown();
                    }

                });
            });

            producerActions.forEach(producerAction -> {

                pExecutorService.submit(() -> {

                    final Producer producer = producerAction.getProducer();
                    producer.setNodes(nodes);
                    producer.setPoison(poison);

                    try {
                        if (producerAction.executeIf()) {
                            producerAction.execute();
                        }
                    } finally {
                        countDown.countDown();
                    }

                });

            });

            try {
                countDown.await();
            } catch (InterruptedException e) {
                throw new HandymanException("Failed to execute", e);
            }
        } catch (Exception e) {
            throw new HandymanException("Failed to execute", e);
        } finally {
            nodes.add(poison);
        }


        try {
            consumerCountDown.await();
        } catch (InterruptedException e) {
            throw new HandymanException("Failed to execute", e);
        }
    }


    @Override
    public boolean executeIf() throws Exception {
        return producerConsumerModel.getCondition();
    }
}
