package in.handyman.raven.lib;

import com.zaxxer.hikari.HikariDataSource;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.Action;
import in.handyman.raven.lib.model.Transform;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.ExceptionUtil;
import in.handyman.raven.util.UniqueID;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLSyntaxErrorException;
import java.sql.Statement;
import java.util.Collections;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = TransformAction.TRANSFORM
)
public class TransformAction implements IActionExecution {

    protected static final String TRANSFORM = "Transform";

    private final Action action;
    private final Logger log;
    private final Transform transform;

    private final Marker aMarker;

    public TransformAction(final Action action, final Logger log, final Object transform) {
        this.transform = (Transform) transform;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(TRANSFORM);
    }

    @Override
    public void execute() {
        final String dbSrc = transform.getOn();
        log.info(aMarker, "Transform action input variables id: {}, name: {}, source-database: {} ", action.getActionId(), transform.getName(), dbSrc);
        log.info(aMarker, "Sql input post parameter ingestion \n {}", transform.getValue());
        final HikariDataSource hikariDataSource = ResourceAccess.rdbmsConn(dbSrc);
        try (final Connection connection = hikariDataSource.getConnection()) {
            connection.setAutoCommit(false);
            for (String givenQuery : transform.getValue()) {
                var sqlList = transform.getFormat() ? CommonQueryUtil.getFormattedQuery(givenQuery) : Collections.singletonList(givenQuery);
                for (var sqlToExecute : sqlList) {
                    log.info(aMarker, "Transform with id:{}, executing script {}", action.getActionId(), givenQuery);
                    final Long statementId = UniqueID.getId();
                    //TODO
                    try (final Statement stmt = connection.createStatement()) {
                        var rowCount = stmt.executeUpdate(sqlToExecute);
                        var warnings = ExceptionUtil.completeSQLWarning(stmt.getWarnings());
                        log.info(aMarker, sqlToExecute + ".count", rowCount);
                        log.info(aMarker, sqlToExecute + ".stmtCount", stmt.getUpdateCount());
                        log.info(aMarker, sqlToExecute + ".warnings", warnings);
                        log.info(aMarker, "Transform id# {}, executed script {} rows returned {}", statementId, sqlToExecute, rowCount);
                        stmt.clearWarnings();
                    } catch (SQLSyntaxErrorException ex) {
                        log.error(aMarker, "Stopping execution, General Error executing sql for {} with for {}", sqlToExecute, ex);
                        log.info(aMarker, sqlToExecute + ".exception", ExceptionUtil.toString(ex));
                        throw new HandymanException("Process failed", ex);
                    } catch (SQLException ex) {
                        log.error(aMarker, "Continuing to execute, even though SQL Error executing sql for {} ", sqlToExecute, ex);
                        log.info(aMarker, sqlToExecute + ".exception", ExceptionUtil.toString(ex));
                        throw new HandymanException("Process failed", ex);
                    } catch (Throwable ex) {
                        log.error(aMarker, "Stopping execution, General Error executing sql for {} with for {}", sqlToExecute, ex);
                        log.info(aMarker, sqlToExecute + ".exception", ExceptionUtil.toString(ex));
                        throw new HandymanException("Process failed", ex);
                    }
                }
                connection.commit();
                log.info(aMarker, "Completed Transform id#{}, name#{}, dbSrc#{}, sqlList#{}", action.getActionId(), transform.getName()
                        , dbSrc, sqlList);
            }
        } catch (SQLException ex) {
            log.error(aMarker, "Stopping execution, Fetching connection failed", ex);
            log.info(aMarker, "connection.exception {}", ExceptionUtil.toString(ex));
            throw new HandymanException("Process failed", ex);
        }
    }


    @Override
    public boolean executeIf() {
        return transform.getCondition();
    }
}
