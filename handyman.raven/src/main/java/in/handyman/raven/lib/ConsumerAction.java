package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.Action;
import in.handyman.raven.lambda.process.LambdaEngine;
import in.handyman.raven.lib.model.Consumer;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "Consumer"
)
public class ConsumerAction implements IActionExecution {

    private static final String PAYLOAD = "payload";
    private static final String ID = "id";
    private final Action action;
    private final Logger log;
    private final Consumer consumer;
    private final Marker aMarker;

    public ConsumerAction(final Action action, final Logger log, final Object consumer) {
        this.consumer = (Consumer) consumer;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" Consumer:" + this.consumer.getName());
    }

    @Override
    public void execute() {

        final int limit = Optional.ofNullable(consumer.getLimit()).map(Integer::valueOf).orElse(1);
        while (true) {
            final List<Map<String, Object>> maps = consumer.getSource().get()
                    .withHandle(handle -> handle.createQuery("SELECT id,payload FROM pcm_event where pcm_id = ? and process = 0 order by created_date limit ?")
                            .bind(0, this.consumer.getPcmId())
                            .bind(1, limit)
                            .mapToMap().list());
            final List<Map<String, Object>> collect = maps.stream()
                    .filter(stringObjectMap -> stringObjectMap.containsKey(PAYLOAD) && stringObjectMap.containsKey(ID))
                    .collect(Collectors.toList());
            final Set<String> payloads = new HashSet<>();
            for (var node : collect) {
                final String payload = String.valueOf(node.get(PAYLOAD));
                if (Objects.equals(payload, consumer.getPoison())) {
                    payloads.add(payload);
                }
                try {
                    if (!Objects.equals(payload, consumer.getPoison())) {

                        final Map<String, String> context = new HashMap<>(action.getContext());
                        context.put(consumer.getPop(), payload);

                        Optional.ofNullable(consumer.getActions()).filter(x -> !x.isEmpty())
                                .ifPresent(actionContexts -> {
                                    actionContexts.stream()
                                            .map(actionContext -> {
                                                var vAction = LambdaEngine.getAction(consumer.getName(), action);
                                                vAction.setContext(context);

                                                return new ActionCallable(actionContext, vAction, null);
                                            })
                                            .forEach(ActionCallable::run);
                                });
                    }
                } catch (Exception e) {
                    throw new HandymanException("", e);
                }
                final Long id = Optional.ofNullable(node.get(ID)).map(String::valueOf).map(Long::valueOf).orElse(0L);
                consumer.getSource().get()
                        .useHandle(handle -> handle.createUpdate("UPDATE pcm_event SET process = 1, last_modified_date = current_timestamp WHERE id = ?")
                                .bind(0, id).execute());
            }
            if (!payloads.isEmpty()) {
                log.info("consumer breaking with {}", consumer.getPoison());
                break;
            }
        }

    }

    public Action getAction() {
        return action;
    }

    @Override
    public boolean executeIf() {
        return consumer.getCondition();
    }
}
